{"ast":null,"code":"var _asyncToGenerator = require(\"I:/Angular/angular-blog/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst isexe = require('isexe');\nconst {\n  join,\n  delimiter,\n  sep,\n  posix\n} = require('path');\nconst isWindows = process.platform === 'win32';\n\n// used to check for slashed in commands passed in. always checks for the posix\n// seperator on all platforms, and checks for the current separator when not on\n// a posix platform. don't use the isWindows check for this since that is mocked\n// in tests but we still need the code to actually work when called. that is also\n// why it is ignored from coverage.\n/* istanbul ignore next */\nconst rSlash = new RegExp(`[${posix.sep}${sep === posix.sep ? '' : sep}]`.replace(/(\\\\)/g, '\\\\$1'));\nconst rRel = new RegExp(`^\\\\.${rSlash.source}`);\nconst getNotFoundError = cmd => Object.assign(new Error(`not found: ${cmd}`), {\n  code: 'ENOENT'\n});\nconst getPathInfo = (cmd, {\n  path: optPath = process.env.PATH,\n  pathExt: optPathExt = process.env.PATHEXT,\n  delimiter: optDelimiter = delimiter\n}) => {\n  // If it has a slash, then we don't bother searching the pathenv.\n  // just check the file itself, and that's it.\n  const pathEnv = cmd.match(rSlash) ? [''] : [\n  // windows always checks the cwd first\n  ...(isWindows ? [process.cwd()] : []), ...(optPath || /* istanbul ignore next: very unusual */'').split(optDelimiter)];\n  if (isWindows) {\n    const pathExtExe = optPathExt || ['.EXE', '.CMD', '.BAT', '.COM'].join(optDelimiter);\n    const pathExt = pathExtExe.split(optDelimiter).reduce((acc, item) => {\n      acc.push(item);\n      acc.push(item.toLowerCase());\n      return acc;\n    }, []);\n    if (cmd.includes('.') && pathExt[0] !== '') {\n      pathExt.unshift('');\n    }\n    return {\n      pathEnv,\n      pathExt,\n      pathExtExe\n    };\n  }\n  return {\n    pathEnv,\n    pathExt: ['']\n  };\n};\nconst getPathPart = (raw, cmd) => {\n  const pathPart = /^\".*\"$/.test(raw) ? raw.slice(1, -1) : raw;\n  const prefix = !pathPart && rRel.test(cmd) ? cmd.slice(0, 2) : '';\n  return prefix + join(pathPart, cmd);\n};\nconst which = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (cmd, opt = {}) {\n    const {\n      pathEnv,\n      pathExt,\n      pathExtExe\n    } = getPathInfo(cmd, opt);\n    const found = [];\n    for (const envPart of pathEnv) {\n      const p = getPathPart(envPart, cmd);\n      for (const ext of pathExt) {\n        const withExt = p + ext;\n        const is = yield isexe(withExt, {\n          pathExt: pathExtExe,\n          ignoreErrors: true\n        });\n        if (is) {\n          if (!opt.all) {\n            return withExt;\n          }\n          found.push(withExt);\n        }\n      }\n    }\n    if (opt.all && found.length) {\n      return found;\n    }\n    if (opt.nothrow) {\n      return null;\n    }\n    throw getNotFoundError(cmd);\n  });\n  return function which(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nconst whichSync = (cmd, opt = {}) => {\n  const {\n    pathEnv,\n    pathExt,\n    pathExtExe\n  } = getPathInfo(cmd, opt);\n  const found = [];\n  for (const pathEnvPart of pathEnv) {\n    const p = getPathPart(pathEnvPart, cmd);\n    for (const ext of pathExt) {\n      const withExt = p + ext;\n      const is = isexe.sync(withExt, {\n        pathExt: pathExtExe,\n        ignoreErrors: true\n      });\n      if (is) {\n        if (!opt.all) {\n          return withExt;\n        }\n        found.push(withExt);\n      }\n    }\n  }\n  if (opt.all && found.length) {\n    return found;\n  }\n  if (opt.nothrow) {\n    return null;\n  }\n  throw getNotFoundError(cmd);\n};\nmodule.exports = which;\nwhich.sync = whichSync;","map":{"version":3,"names":["isexe","require","join","delimiter","sep","posix","isWindows","process","platform","rSlash","RegExp","replace","rRel","source","getNotFoundError","cmd","Object","assign","Error","code","getPathInfo","path","optPath","env","PATH","pathExt","optPathExt","PATHEXT","optDelimiter","pathEnv","match","cwd","split","pathExtExe","reduce","acc","item","push","toLowerCase","includes","unshift","getPathPart","raw","pathPart","test","slice","prefix","which","opt","found","envPart","p","ext","withExt","is","ignoreErrors","all","length","nothrow","whichSync","pathEnvPart","sync","module","exports"],"sources":["I:/Angular/angular-blog/node_modules/@npmcli/promise-spawn/node_modules/which/lib/index.js"],"sourcesContent":["const isexe = require('isexe')\nconst { join, delimiter, sep, posix } = require('path')\n\nconst isWindows = process.platform === 'win32'\n\n// used to check for slashed in commands passed in. always checks for the posix\n// seperator on all platforms, and checks for the current separator when not on\n// a posix platform. don't use the isWindows check for this since that is mocked\n// in tests but we still need the code to actually work when called. that is also\n// why it is ignored from coverage.\n/* istanbul ignore next */\nconst rSlash = new RegExp(`[${posix.sep}${sep === posix.sep ? '' : sep}]`.replace(/(\\\\)/g, '\\\\$1'))\nconst rRel = new RegExp(`^\\\\.${rSlash.source}`)\n\nconst getNotFoundError = (cmd) =>\n  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' })\n\nconst getPathInfo = (cmd, {\n  path: optPath = process.env.PATH,\n  pathExt: optPathExt = process.env.PATHEXT,\n  delimiter: optDelimiter = delimiter,\n}) => {\n  // If it has a slash, then we don't bother searching the pathenv.\n  // just check the file itself, and that's it.\n  const pathEnv = cmd.match(rSlash) ? [''] : [\n    // windows always checks the cwd first\n    ...(isWindows ? [process.cwd()] : []),\n    ...(optPath || /* istanbul ignore next: very unusual */ '').split(optDelimiter),\n  ]\n\n  if (isWindows) {\n    const pathExtExe = optPathExt ||\n      ['.EXE', '.CMD', '.BAT', '.COM'].join(optDelimiter)\n    const pathExt = pathExtExe.split(optDelimiter).reduce((acc, item) => {\n      acc.push(item)\n      acc.push(item.toLowerCase())\n      return acc\n    }, [])\n    if (cmd.includes('.') && pathExt[0] !== '') {\n      pathExt.unshift('')\n    }\n    return { pathEnv, pathExt, pathExtExe }\n  }\n\n  return { pathEnv, pathExt: [''] }\n}\n\nconst getPathPart = (raw, cmd) => {\n  const pathPart = /^\".*\"$/.test(raw) ? raw.slice(1, -1) : raw\n  const prefix = !pathPart && rRel.test(cmd) ? cmd.slice(0, 2) : ''\n  return prefix + join(pathPart, cmd)\n}\n\nconst which = async (cmd, opt = {}) => {\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  for (const envPart of pathEnv) {\n    const p = getPathPart(envPart, cmd)\n\n    for (const ext of pathExt) {\n      const withExt = p + ext\n      const is = await isexe(withExt, { pathExt: pathExtExe, ignoreErrors: true })\n      if (is) {\n        if (!opt.all) {\n          return withExt\n        }\n        found.push(withExt)\n      }\n    }\n  }\n\n  if (opt.all && found.length) {\n    return found\n  }\n\n  if (opt.nothrow) {\n    return null\n  }\n\n  throw getNotFoundError(cmd)\n}\n\nconst whichSync = (cmd, opt = {}) => {\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  for (const pathEnvPart of pathEnv) {\n    const p = getPathPart(pathEnvPart, cmd)\n\n    for (const ext of pathExt) {\n      const withExt = p + ext\n      const is = isexe.sync(withExt, { pathExt: pathExtExe, ignoreErrors: true })\n      if (is) {\n        if (!opt.all) {\n          return withExt\n        }\n        found.push(withExt)\n      }\n    }\n  }\n\n  if (opt.all && found.length) {\n    return found\n  }\n\n  if (opt.nothrow) {\n    return null\n  }\n\n  throw getNotFoundError(cmd)\n}\n\nmodule.exports = which\nwhich.sync = whichSync\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}