{"ast":null,"code":"var _asyncToGenerator = require(\"I:/Angular/angular-blog/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst makeSpawnArgs = require('./make-spawn-args.js');\nconst promiseSpawn = require('@npmcli/promise-spawn');\nconst packageEnvs = require('./package-envs.js');\nconst {\n  isNodeGypPackage,\n  defaultGypInstallScript\n} = require('@npmcli/node-gyp');\nconst signalManager = require('./signal-manager.js');\nconst isServerPackage = require('./is-server-package.js');\n\n// you wouldn't like me when I'm angry...\nconst bruce = (id, event, cmd, args) => {\n  let banner = id ? `\\n> ${id} ${event}\\n` : `\\n> ${event}\\n`;\n  banner += `> ${cmd.trim().replace(/\\n/g, '\\n> ')}`;\n  if (args.length) {\n    banner += ` ${args.join(' ')}`;\n  }\n  banner += '\\n';\n  return banner;\n};\nconst runScriptPkg = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (options) {\n    const {\n      event,\n      path,\n      scriptShell,\n      binPaths = false,\n      env = {},\n      stdio = 'pipe',\n      pkg,\n      args = [],\n      stdioString,\n      // note: only used when stdio:inherit\n      banner = true,\n      // how long to wait for a process.kill signal\n      // only exposed here so that we can make the test go a bit faster.\n      signalTimeout = 500\n    } = options;\n    const {\n      scripts = {},\n      gypfile\n    } = pkg;\n    let cmd = null;\n    if (options.cmd) {\n      cmd = options.cmd;\n    } else if (pkg.scripts && pkg.scripts[event]) {\n      cmd = pkg.scripts[event];\n    } else if (\n    // If there is no preinstall or install script, default to rebuilding node-gyp packages.\n    event === 'install' && !scripts.install && !scripts.preinstall && gypfile !== false && (yield isNodeGypPackage(path))) {\n      cmd = defaultGypInstallScript;\n    } else if (event === 'start' && (yield isServerPackage(path))) {\n      cmd = 'node server.js';\n    }\n    if (!cmd) {\n      return {\n        code: 0,\n        signal: null\n      };\n    }\n    if (stdio === 'inherit' && banner !== false) {\n      // we're dumping to the parent's stdout, so print the banner\n      console.log(bruce(pkg._id, event, cmd, args));\n    }\n    const [spawnShell, spawnArgs, spawnOpts] = makeSpawnArgs({\n      event,\n      path,\n      scriptShell,\n      binPaths,\n      env: packageEnvs(env, pkg),\n      stdio,\n      cmd,\n      args,\n      stdioString\n    });\n    const p = promiseSpawn(spawnShell, spawnArgs, spawnOpts, {\n      event,\n      script: cmd,\n      pkgid: pkg._id,\n      path\n    });\n    if (stdio === 'inherit') {\n      signalManager.add(p.process);\n    }\n    if (p.stdin) {\n      p.stdin.end();\n    }\n    return p.catch(er => {\n      const {\n        signal\n      } = er;\n      if (stdio === 'inherit' && signal) {\n        // by the time we reach here, the child has already exited. we send the\n        // signal back to ourselves again so that npm will exit with the same\n        // status as the child\n        process.kill(process.pid, signal);\n\n        // just in case we don't die, reject after 500ms\n        // this also keeps the node process open long enough to actually\n        // get the signal, rather than terminating gracefully.\n        return new Promise((res, rej) => setTimeout(() => rej(er), signalTimeout));\n      } else {\n        throw er;\n      }\n    });\n  });\n  return function runScriptPkg(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nmodule.exports = runScriptPkg;","map":{"version":3,"names":["makeSpawnArgs","require","promiseSpawn","packageEnvs","isNodeGypPackage","defaultGypInstallScript","signalManager","isServerPackage","bruce","id","event","cmd","args","banner","trim","replace","length","join","runScriptPkg","options","path","scriptShell","binPaths","env","stdio","pkg","stdioString","signalTimeout","scripts","gypfile","install","preinstall","code","signal","console","log","_id","spawnShell","spawnArgs","spawnOpts","p","script","pkgid","add","process","stdin","end","catch","er","kill","pid","Promise","res","rej","setTimeout","module","exports"],"sources":["I:/Angular/angular-blog/node_modules/@npmcli/run-script/lib/run-script-pkg.js"],"sourcesContent":["const makeSpawnArgs = require('./make-spawn-args.js')\nconst promiseSpawn = require('@npmcli/promise-spawn')\nconst packageEnvs = require('./package-envs.js')\nconst { isNodeGypPackage, defaultGypInstallScript } = require('@npmcli/node-gyp')\nconst signalManager = require('./signal-manager.js')\nconst isServerPackage = require('./is-server-package.js')\n\n// you wouldn't like me when I'm angry...\nconst bruce = (id, event, cmd, args) => {\n  let banner = id\n    ? `\\n> ${id} ${event}\\n`\n    : `\\n> ${event}\\n`\n  banner += `> ${cmd.trim().replace(/\\n/g, '\\n> ')}`\n  if (args.length) {\n    banner += ` ${args.join(' ')}`\n  }\n  banner += '\\n'\n  return banner\n}\n\nconst runScriptPkg = async options => {\n  const {\n    event,\n    path,\n    scriptShell,\n    binPaths = false,\n    env = {},\n    stdio = 'pipe',\n    pkg,\n    args = [],\n    stdioString,\n    // note: only used when stdio:inherit\n    banner = true,\n    // how long to wait for a process.kill signal\n    // only exposed here so that we can make the test go a bit faster.\n    signalTimeout = 500,\n  } = options\n\n  const { scripts = {}, gypfile } = pkg\n  let cmd = null\n  if (options.cmd) {\n    cmd = options.cmd\n  } else if (pkg.scripts && pkg.scripts[event]) {\n    cmd = pkg.scripts[event]\n  } else if (\n    // If there is no preinstall or install script, default to rebuilding node-gyp packages.\n    event === 'install' &&\n    !scripts.install &&\n    !scripts.preinstall &&\n    gypfile !== false &&\n    await isNodeGypPackage(path)\n  ) {\n    cmd = defaultGypInstallScript\n  } else if (event === 'start' && await isServerPackage(path)) {\n    cmd = 'node server.js'\n  }\n\n  if (!cmd) {\n    return { code: 0, signal: null }\n  }\n\n  if (stdio === 'inherit' && banner !== false) {\n    // we're dumping to the parent's stdout, so print the banner\n    console.log(bruce(pkg._id, event, cmd, args))\n  }\n\n  const [spawnShell, spawnArgs, spawnOpts] = makeSpawnArgs({\n    event,\n    path,\n    scriptShell,\n    binPaths,\n    env: packageEnvs(env, pkg),\n    stdio,\n    cmd,\n    args,\n    stdioString,\n  })\n\n  const p = promiseSpawn(spawnShell, spawnArgs, spawnOpts, {\n    event,\n    script: cmd,\n    pkgid: pkg._id,\n    path,\n  })\n\n  if (stdio === 'inherit') {\n    signalManager.add(p.process)\n  }\n\n  if (p.stdin) {\n    p.stdin.end()\n  }\n\n  return p.catch(er => {\n    const { signal } = er\n    if (stdio === 'inherit' && signal) {\n      // by the time we reach here, the child has already exited. we send the\n      // signal back to ourselves again so that npm will exit with the same\n      // status as the child\n      process.kill(process.pid, signal)\n\n      // just in case we don't die, reject after 500ms\n      // this also keeps the node process open long enough to actually\n      // get the signal, rather than terminating gracefully.\n      return new Promise((res, rej) => setTimeout(() => rej(er), signalTimeout))\n    } else {\n      throw er\n    }\n  })\n}\n\nmodule.exports = runScriptPkg\n"],"mappings":";AAAA,MAAMA,aAAa,GAAGC,OAAO,CAAC,sBAAsB,CAAC;AACrD,MAAMC,YAAY,GAAGD,OAAO,CAAC,uBAAuB,CAAC;AACrD,MAAME,WAAW,GAAGF,OAAO,CAAC,mBAAmB,CAAC;AAChD,MAAM;EAAEG,gBAAgB;EAAEC;AAAwB,CAAC,GAAGJ,OAAO,CAAC,kBAAkB,CAAC;AACjF,MAAMK,aAAa,GAAGL,OAAO,CAAC,qBAAqB,CAAC;AACpD,MAAMM,eAAe,GAAGN,OAAO,CAAC,wBAAwB,CAAC;;AAEzD;AACA,MAAMO,KAAK,GAAG,CAACC,EAAE,EAAEC,KAAK,EAAEC,GAAG,EAAEC,IAAI,KAAK;EACtC,IAAIC,MAAM,GAAGJ,EAAE,GACV,OAAMA,EAAG,IAAGC,KAAM,IAAG,GACrB,OAAMA,KAAM,IAAG;EACpBG,MAAM,IAAK,KAAIF,GAAG,CAACG,IAAI,EAAE,CAACC,OAAO,CAAC,KAAK,EAAE,MAAM,CAAE,EAAC;EAClD,IAAIH,IAAI,CAACI,MAAM,EAAE;IACfH,MAAM,IAAK,IAAGD,IAAI,CAACK,IAAI,CAAC,GAAG,CAAE,EAAC;EAChC;EACAJ,MAAM,IAAI,IAAI;EACd,OAAOA,MAAM;AACf,CAAC;AAED,MAAMK,YAAY;EAAA,6BAAG,WAAMC,OAAO,EAAI;IACpC,MAAM;MACJT,KAAK;MACLU,IAAI;MACJC,WAAW;MACXC,QAAQ,GAAG,KAAK;MAChBC,GAAG,GAAG,CAAC,CAAC;MACRC,KAAK,GAAG,MAAM;MACdC,GAAG;MACHb,IAAI,GAAG,EAAE;MACTc,WAAW;MACX;MACAb,MAAM,GAAG,IAAI;MACb;MACA;MACAc,aAAa,GAAG;IAClB,CAAC,GAAGR,OAAO;IAEX,MAAM;MAAES,OAAO,GAAG,CAAC,CAAC;MAAEC;IAAQ,CAAC,GAAGJ,GAAG;IACrC,IAAId,GAAG,GAAG,IAAI;IACd,IAAIQ,OAAO,CAACR,GAAG,EAAE;MACfA,GAAG,GAAGQ,OAAO,CAACR,GAAG;IACnB,CAAC,MAAM,IAAIc,GAAG,CAACG,OAAO,IAAIH,GAAG,CAACG,OAAO,CAAClB,KAAK,CAAC,EAAE;MAC5CC,GAAG,GAAGc,GAAG,CAACG,OAAO,CAAClB,KAAK,CAAC;IAC1B,CAAC,MAAM;IACL;IACAA,KAAK,KAAK,SAAS,IACnB,CAACkB,OAAO,CAACE,OAAO,IAChB,CAACF,OAAO,CAACG,UAAU,IACnBF,OAAO,KAAK,KAAK,WACXzB,gBAAgB,CAACgB,IAAI,CAAC,GAC5B;MACAT,GAAG,GAAGN,uBAAuB;IAC/B,CAAC,MAAM,IAAIK,KAAK,KAAK,OAAO,WAAUH,eAAe,CAACa,IAAI,CAAC,GAAE;MAC3DT,GAAG,GAAG,gBAAgB;IACxB;IAEA,IAAI,CAACA,GAAG,EAAE;MACR,OAAO;QAAEqB,IAAI,EAAE,CAAC;QAAEC,MAAM,EAAE;MAAK,CAAC;IAClC;IAEA,IAAIT,KAAK,KAAK,SAAS,IAAIX,MAAM,KAAK,KAAK,EAAE;MAC3C;MACAqB,OAAO,CAACC,GAAG,CAAC3B,KAAK,CAACiB,GAAG,CAACW,GAAG,EAAE1B,KAAK,EAAEC,GAAG,EAAEC,IAAI,CAAC,CAAC;IAC/C;IAEA,MAAM,CAACyB,UAAU,EAAEC,SAAS,EAAEC,SAAS,CAAC,GAAGvC,aAAa,CAAC;MACvDU,KAAK;MACLU,IAAI;MACJC,WAAW;MACXC,QAAQ;MACRC,GAAG,EAAEpB,WAAW,CAACoB,GAAG,EAAEE,GAAG,CAAC;MAC1BD,KAAK;MACLb,GAAG;MACHC,IAAI;MACJc;IACF,CAAC,CAAC;IAEF,MAAMc,CAAC,GAAGtC,YAAY,CAACmC,UAAU,EAAEC,SAAS,EAAEC,SAAS,EAAE;MACvD7B,KAAK;MACL+B,MAAM,EAAE9B,GAAG;MACX+B,KAAK,EAAEjB,GAAG,CAACW,GAAG;MACdhB;IACF,CAAC,CAAC;IAEF,IAAII,KAAK,KAAK,SAAS,EAAE;MACvBlB,aAAa,CAACqC,GAAG,CAACH,CAAC,CAACI,OAAO,CAAC;IAC9B;IAEA,IAAIJ,CAAC,CAACK,KAAK,EAAE;MACXL,CAAC,CAACK,KAAK,CAACC,GAAG,EAAE;IACf;IAEA,OAAON,CAAC,CAACO,KAAK,CAACC,EAAE,IAAI;MACnB,MAAM;QAAEf;MAAO,CAAC,GAAGe,EAAE;MACrB,IAAIxB,KAAK,KAAK,SAAS,IAAIS,MAAM,EAAE;QACjC;QACA;QACA;QACAW,OAAO,CAACK,IAAI,CAACL,OAAO,CAACM,GAAG,EAAEjB,MAAM,CAAC;;QAEjC;QACA;QACA;QACA,OAAO,IAAIkB,OAAO,CAAC,CAACC,GAAG,EAAEC,GAAG,KAAKC,UAAU,CAAC,MAAMD,GAAG,CAACL,EAAE,CAAC,EAAErB,aAAa,CAAC,CAAC;MAC5E,CAAC,MAAM;QACL,MAAMqB,EAAE;MACV;IACF,CAAC,CAAC;EACJ,CAAC;EAAA,gBAzFK9B,YAAY;IAAA;EAAA;AAAA,GAyFjB;AAEDqC,MAAM,CAACC,OAAO,GAAGtC,YAAY"},"metadata":{},"sourceType":"script","externalDependencies":[]}