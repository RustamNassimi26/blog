{"ast":null,"code":"\"use strict\";\n\n// synchronous utility for filtering entries and calculating subwalks\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Processor = exports.SubWalks = exports.MatchRecord = exports.HasWalkedCache = void 0;\nconst minimatch_1 = require(\"minimatch\");\n/**\n * A cache of which patterns have been processed for a given Path\n */\nclass HasWalkedCache {\n  store;\n  constructor(store = new Map()) {\n    this.store = store;\n  }\n  copy() {\n    return new HasWalkedCache(new Map(this.store));\n  }\n  hasWalked(target, pattern) {\n    return this.store.get(target.fullpath())?.has(pattern.globString());\n  }\n  storeWalked(target, pattern) {\n    const fullpath = target.fullpath();\n    const cached = this.store.get(fullpath);\n    if (cached) cached.add(pattern.globString());else this.store.set(fullpath, new Set([pattern.globString()]));\n  }\n}\nexports.HasWalkedCache = HasWalkedCache;\n/**\n * A record of which paths have been matched in a given walk step,\n * and whether they only are considered a match if they are a directory,\n * and whether their absolute or relative path should be returned.\n */\nclass MatchRecord {\n  store = new Map();\n  add(target, absolute, ifDir) {\n    const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);\n    const current = this.store.get(target);\n    this.store.set(target, current === undefined ? n : n & current);\n  }\n  // match, absolute, ifdir\n  entries() {\n    return [...this.store.entries()].map(([path, n]) => [path, !!(n & 2), !!(n & 1)]);\n  }\n}\nexports.MatchRecord = MatchRecord;\n/**\n * A collection of patterns that must be processed in a subsequent step\n * for a given path.\n */\nclass SubWalks {\n  store = new Map();\n  add(target, pattern) {\n    if (!target.canReaddir()) {\n      return;\n    }\n    const subs = this.store.get(target);\n    if (subs) {\n      if (!subs.find(p => p.globString() === pattern.globString())) {\n        subs.push(pattern);\n      }\n    } else this.store.set(target, [pattern]);\n  }\n  get(target) {\n    const subs = this.store.get(target);\n    /* c8 ignore start */\n    if (!subs) {\n      throw new Error('attempting to walk unknown path');\n    }\n    /* c8 ignore stop */\n    return subs;\n  }\n  entries() {\n    return this.keys().map(k => [k, this.store.get(k)]);\n  }\n  keys() {\n    return [...this.store.keys()].filter(t => t.canReaddir());\n  }\n}\nexports.SubWalks = SubWalks;\n/**\n * The class that processes patterns for a given path.\n *\n * Handles child entry filtering, and determining whether a path's\n * directory contents must be read.\n */\nclass Processor {\n  hasWalkedCache;\n  matches = new MatchRecord();\n  subwalks = new SubWalks();\n  patterns;\n  follow;\n  dot;\n  opts;\n  constructor(opts, hasWalkedCache) {\n    this.opts = opts;\n    this.follow = !!opts.follow;\n    this.dot = !!opts.dot;\n    this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();\n  }\n  processPatterns(target, patterns) {\n    this.patterns = patterns;\n    const processingSet = patterns.map(p => [target, p]);\n    // map of paths to the magic-starting subwalks they need to walk\n    // first item in patterns is the filter\n    for (let [t, pattern] of processingSet) {\n      this.hasWalkedCache.storeWalked(t, pattern);\n      const root = pattern.root();\n      const absolute = pattern.isAbsolute() && this.opts.absolute !== false;\n      // start absolute patterns at root\n      if (root) {\n        t = t.resolve(root === '/' && this.opts.root !== undefined ? this.opts.root : root);\n        const rest = pattern.rest();\n        if (!rest) {\n          this.matches.add(t, true, false);\n          continue;\n        } else {\n          pattern = rest;\n        }\n      }\n      if (t.isENOENT()) continue;\n      let p;\n      let rest;\n      let changed = false;\n      while (typeof (p = pattern.pattern()) === 'string' && (rest = pattern.rest())) {\n        const c = t.resolve(p);\n        t = c;\n        pattern = rest;\n        changed = true;\n      }\n      p = pattern.pattern();\n      rest = pattern.rest();\n      if (changed) {\n        if (this.hasWalkedCache.hasWalked(t, pattern)) continue;\n        this.hasWalkedCache.storeWalked(t, pattern);\n      }\n      // now we have either a final string for a known entry,\n      // more strings for an unknown entry,\n      // or a pattern starting with magic, mounted on t.\n      if (typeof p === 'string') {\n        // must not be final entry, otherwise we would have\n        // concatenated it earlier.\n        const ifDir = p === '..' || p === '' || p === '.';\n        this.matches.add(t.resolve(p), absolute, ifDir);\n        continue;\n      } else if (p === minimatch_1.GLOBSTAR) {\n        // if no rest, match and subwalk pattern\n        // if rest, process rest and subwalk pattern\n        // if it's a symlink, but we didn't get here by way of a\n        // globstar match (meaning it's the first time THIS globstar\n        // has traversed a symlink), then we follow it. Otherwise, stop.\n        if (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) {\n          this.subwalks.add(t, pattern);\n        }\n        const rp = rest?.pattern();\n        const rrest = rest?.rest();\n        if (!rest || (rp === '' || rp === '.') && !rrest) {\n          // only HAS to be a dir if it ends in **/ or **/.\n          // but ending in ** will match files as well.\n          this.matches.add(t, absolute, rp === '' || rp === '.');\n        } else {\n          if (rp === '..') {\n            // this would mean you're matching **/.. at the fs root,\n            // and no thanks, I'm not gonna test that specific case.\n            /* c8 ignore start */\n            const tp = t.parent || t;\n            /* c8 ignore stop */\n            if (!rrest) this.matches.add(tp, absolute, true);else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {\n              this.subwalks.add(tp, rrest);\n            }\n          }\n        }\n      } else if (p instanceof RegExp) {\n        this.subwalks.add(t, pattern);\n      }\n    }\n    return this;\n  }\n  subwalkTargets() {\n    return this.subwalks.keys();\n  }\n  child() {\n    return new Processor(this.opts, this.hasWalkedCache);\n  }\n  // return a new Processor containing the subwalks for each\n  // child entry, and a set of matches, and\n  // a hasWalkedCache that's a copy of this one\n  // then we're going to call\n  filterEntries(parent, entries) {\n    const patterns = this.subwalks.get(parent);\n    // put matches and entry walks into the results processor\n    const results = this.child();\n    for (const e of entries) {\n      for (const pattern of patterns) {\n        const absolute = pattern.isAbsolute();\n        const p = pattern.pattern();\n        const rest = pattern.rest();\n        if (p === minimatch_1.GLOBSTAR) {\n          results.testGlobstar(e, pattern, rest, absolute);\n        } else if (p instanceof RegExp) {\n          results.testRegExp(e, p, rest, absolute);\n        } else {\n          results.testString(e, p, rest, absolute);\n        }\n      }\n    }\n    return results;\n  }\n  testGlobstar(e, pattern, rest, absolute) {\n    if (this.dot || !e.name.startsWith('.')) {\n      if (!pattern.hasMore()) {\n        this.matches.add(e, absolute, false);\n      }\n      if (e.canReaddir()) {\n        // if we're in follow mode or it's not a symlink, just keep\n        // testing the same pattern. If there's more after the globstar,\n        // then this symlink consumes the globstar. If not, then we can\n        // follow at most ONE symlink along the way, so we mark it, which\n        // also checks to ensure that it wasn't already marked.\n        if (this.follow || !e.isSymbolicLink()) {\n          this.subwalks.add(e, pattern);\n        } else if (e.isSymbolicLink()) {\n          if (rest && pattern.checkFollowGlobstar()) {\n            this.subwalks.add(e, rest);\n          } else if (pattern.markFollowGlobstar()) {\n            this.subwalks.add(e, pattern);\n          }\n        }\n      }\n    }\n    // if the NEXT thing matches this entry, then also add\n    // the rest.\n    if (rest) {\n      const rp = rest.pattern();\n      if (typeof rp === 'string' &&\n      // dots and empty were handled already\n      rp !== '..' && rp !== '' && rp !== '.') {\n        this.testString(e, rp, rest.rest(), absolute);\n      } else if (rp === '..') {\n        /* c8 ignore start */\n        const ep = e.parent || e;\n        /* c8 ignore stop */\n        this.subwalks.add(ep, rest);\n      } else if (rp instanceof RegExp) {\n        this.testRegExp(e, rp, rest.rest(), absolute);\n      }\n    }\n  }\n  testRegExp(e, p, rest, absolute) {\n    if (!p.test(e.name)) return;\n    if (!rest) {\n      this.matches.add(e, absolute, false);\n    } else {\n      this.subwalks.add(e, rest);\n    }\n  }\n  testString(e, p, rest, absolute) {\n    // should never happen?\n    if (!e.isNamed(p)) return;\n    if (!rest) {\n      this.matches.add(e, absolute, false);\n    } else {\n      this.subwalks.add(e, rest);\n    }\n  }\n}\nexports.Processor = Processor;","map":{"version":3,"names":["Object","defineProperty","exports","value","Processor","SubWalks","MatchRecord","HasWalkedCache","minimatch_1","require","store","constructor","Map","copy","hasWalked","target","pattern","get","fullpath","has","globString","storeWalked","cached","add","set","Set","absolute","ifDir","n","current","undefined","entries","map","path","canReaddir","subs","find","p","push","Error","keys","k","filter","t","hasWalkedCache","matches","subwalks","patterns","follow","dot","opts","processPatterns","processingSet","root","isAbsolute","resolve","rest","isENOENT","changed","c","GLOBSTAR","isSymbolicLink","checkFollowGlobstar","rp","rrest","tp","parent","RegExp","subwalkTargets","child","filterEntries","results","e","testGlobstar","testRegExp","testString","name","startsWith","hasMore","markFollowGlobstar","ep","test","isNamed"],"sources":["I:/Angular/angular-blog/node_modules/read-package-json/node_modules/glob/dist/commonjs/processor.js"],"sourcesContent":["\"use strict\";\n// synchronous utility for filtering entries and calculating subwalks\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Processor = exports.SubWalks = exports.MatchRecord = exports.HasWalkedCache = void 0;\nconst minimatch_1 = require(\"minimatch\");\n/**\n * A cache of which patterns have been processed for a given Path\n */\nclass HasWalkedCache {\n    store;\n    constructor(store = new Map()) {\n        this.store = store;\n    }\n    copy() {\n        return new HasWalkedCache(new Map(this.store));\n    }\n    hasWalked(target, pattern) {\n        return this.store.get(target.fullpath())?.has(pattern.globString());\n    }\n    storeWalked(target, pattern) {\n        const fullpath = target.fullpath();\n        const cached = this.store.get(fullpath);\n        if (cached)\n            cached.add(pattern.globString());\n        else\n            this.store.set(fullpath, new Set([pattern.globString()]));\n    }\n}\nexports.HasWalkedCache = HasWalkedCache;\n/**\n * A record of which paths have been matched in a given walk step,\n * and whether they only are considered a match if they are a directory,\n * and whether their absolute or relative path should be returned.\n */\nclass MatchRecord {\n    store = new Map();\n    add(target, absolute, ifDir) {\n        const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);\n        const current = this.store.get(target);\n        this.store.set(target, current === undefined ? n : n & current);\n    }\n    // match, absolute, ifdir\n    entries() {\n        return [...this.store.entries()].map(([path, n]) => [\n            path,\n            !!(n & 2),\n            !!(n & 1),\n        ]);\n    }\n}\nexports.MatchRecord = MatchRecord;\n/**\n * A collection of patterns that must be processed in a subsequent step\n * for a given path.\n */\nclass SubWalks {\n    store = new Map();\n    add(target, pattern) {\n        if (!target.canReaddir()) {\n            return;\n        }\n        const subs = this.store.get(target);\n        if (subs) {\n            if (!subs.find(p => p.globString() === pattern.globString())) {\n                subs.push(pattern);\n            }\n        }\n        else\n            this.store.set(target, [pattern]);\n    }\n    get(target) {\n        const subs = this.store.get(target);\n        /* c8 ignore start */\n        if (!subs) {\n            throw new Error('attempting to walk unknown path');\n        }\n        /* c8 ignore stop */\n        return subs;\n    }\n    entries() {\n        return this.keys().map(k => [k, this.store.get(k)]);\n    }\n    keys() {\n        return [...this.store.keys()].filter(t => t.canReaddir());\n    }\n}\nexports.SubWalks = SubWalks;\n/**\n * The class that processes patterns for a given path.\n *\n * Handles child entry filtering, and determining whether a path's\n * directory contents must be read.\n */\nclass Processor {\n    hasWalkedCache;\n    matches = new MatchRecord();\n    subwalks = new SubWalks();\n    patterns;\n    follow;\n    dot;\n    opts;\n    constructor(opts, hasWalkedCache) {\n        this.opts = opts;\n        this.follow = !!opts.follow;\n        this.dot = !!opts.dot;\n        this.hasWalkedCache = hasWalkedCache\n            ? hasWalkedCache.copy()\n            : new HasWalkedCache();\n    }\n    processPatterns(target, patterns) {\n        this.patterns = patterns;\n        const processingSet = patterns.map(p => [target, p]);\n        // map of paths to the magic-starting subwalks they need to walk\n        // first item in patterns is the filter\n        for (let [t, pattern] of processingSet) {\n            this.hasWalkedCache.storeWalked(t, pattern);\n            const root = pattern.root();\n            const absolute = pattern.isAbsolute() && this.opts.absolute !== false;\n            // start absolute patterns at root\n            if (root) {\n                t = t.resolve(root === '/' && this.opts.root !== undefined\n                    ? this.opts.root\n                    : root);\n                const rest = pattern.rest();\n                if (!rest) {\n                    this.matches.add(t, true, false);\n                    continue;\n                }\n                else {\n                    pattern = rest;\n                }\n            }\n            if (t.isENOENT())\n                continue;\n            let p;\n            let rest;\n            let changed = false;\n            while (typeof (p = pattern.pattern()) === 'string' &&\n                (rest = pattern.rest())) {\n                const c = t.resolve(p);\n                t = c;\n                pattern = rest;\n                changed = true;\n            }\n            p = pattern.pattern();\n            rest = pattern.rest();\n            if (changed) {\n                if (this.hasWalkedCache.hasWalked(t, pattern))\n                    continue;\n                this.hasWalkedCache.storeWalked(t, pattern);\n            }\n            // now we have either a final string for a known entry,\n            // more strings for an unknown entry,\n            // or a pattern starting with magic, mounted on t.\n            if (typeof p === 'string') {\n                // must not be final entry, otherwise we would have\n                // concatenated it earlier.\n                const ifDir = p === '..' || p === '' || p === '.';\n                this.matches.add(t.resolve(p), absolute, ifDir);\n                continue;\n            }\n            else if (p === minimatch_1.GLOBSTAR) {\n                // if no rest, match and subwalk pattern\n                // if rest, process rest and subwalk pattern\n                // if it's a symlink, but we didn't get here by way of a\n                // globstar match (meaning it's the first time THIS globstar\n                // has traversed a symlink), then we follow it. Otherwise, stop.\n                if (!t.isSymbolicLink() ||\n                    this.follow ||\n                    pattern.checkFollowGlobstar()) {\n                    this.subwalks.add(t, pattern);\n                }\n                const rp = rest?.pattern();\n                const rrest = rest?.rest();\n                if (!rest || ((rp === '' || rp === '.') && !rrest)) {\n                    // only HAS to be a dir if it ends in **/ or **/.\n                    // but ending in ** will match files as well.\n                    this.matches.add(t, absolute, rp === '' || rp === '.');\n                }\n                else {\n                    if (rp === '..') {\n                        // this would mean you're matching **/.. at the fs root,\n                        // and no thanks, I'm not gonna test that specific case.\n                        /* c8 ignore start */\n                        const tp = t.parent || t;\n                        /* c8 ignore stop */\n                        if (!rrest)\n                            this.matches.add(tp, absolute, true);\n                        else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {\n                            this.subwalks.add(tp, rrest);\n                        }\n                    }\n                }\n            }\n            else if (p instanceof RegExp) {\n                this.subwalks.add(t, pattern);\n            }\n        }\n        return this;\n    }\n    subwalkTargets() {\n        return this.subwalks.keys();\n    }\n    child() {\n        return new Processor(this.opts, this.hasWalkedCache);\n    }\n    // return a new Processor containing the subwalks for each\n    // child entry, and a set of matches, and\n    // a hasWalkedCache that's a copy of this one\n    // then we're going to call\n    filterEntries(parent, entries) {\n        const patterns = this.subwalks.get(parent);\n        // put matches and entry walks into the results processor\n        const results = this.child();\n        for (const e of entries) {\n            for (const pattern of patterns) {\n                const absolute = pattern.isAbsolute();\n                const p = pattern.pattern();\n                const rest = pattern.rest();\n                if (p === minimatch_1.GLOBSTAR) {\n                    results.testGlobstar(e, pattern, rest, absolute);\n                }\n                else if (p instanceof RegExp) {\n                    results.testRegExp(e, p, rest, absolute);\n                }\n                else {\n                    results.testString(e, p, rest, absolute);\n                }\n            }\n        }\n        return results;\n    }\n    testGlobstar(e, pattern, rest, absolute) {\n        if (this.dot || !e.name.startsWith('.')) {\n            if (!pattern.hasMore()) {\n                this.matches.add(e, absolute, false);\n            }\n            if (e.canReaddir()) {\n                // if we're in follow mode or it's not a symlink, just keep\n                // testing the same pattern. If there's more after the globstar,\n                // then this symlink consumes the globstar. If not, then we can\n                // follow at most ONE symlink along the way, so we mark it, which\n                // also checks to ensure that it wasn't already marked.\n                if (this.follow || !e.isSymbolicLink()) {\n                    this.subwalks.add(e, pattern);\n                }\n                else if (e.isSymbolicLink()) {\n                    if (rest && pattern.checkFollowGlobstar()) {\n                        this.subwalks.add(e, rest);\n                    }\n                    else if (pattern.markFollowGlobstar()) {\n                        this.subwalks.add(e, pattern);\n                    }\n                }\n            }\n        }\n        // if the NEXT thing matches this entry, then also add\n        // the rest.\n        if (rest) {\n            const rp = rest.pattern();\n            if (typeof rp === 'string' &&\n                // dots and empty were handled already\n                rp !== '..' &&\n                rp !== '' &&\n                rp !== '.') {\n                this.testString(e, rp, rest.rest(), absolute);\n            }\n            else if (rp === '..') {\n                /* c8 ignore start */\n                const ep = e.parent || e;\n                /* c8 ignore stop */\n                this.subwalks.add(ep, rest);\n            }\n            else if (rp instanceof RegExp) {\n                this.testRegExp(e, rp, rest.rest(), absolute);\n            }\n        }\n    }\n    testRegExp(e, p, rest, absolute) {\n        if (!p.test(e.name))\n            return;\n        if (!rest) {\n            this.matches.add(e, absolute, false);\n        }\n        else {\n            this.subwalks.add(e, rest);\n        }\n    }\n    testString(e, p, rest, absolute) {\n        // should never happen?\n        if (!e.isNamed(p))\n            return;\n        if (!rest) {\n            this.matches.add(e, absolute, false);\n        }\n        else {\n            this.subwalks.add(e, rest);\n        }\n    }\n}\nexports.Processor = Processor;\n"],"mappings":"AAAA,YAAY;;AACZ;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,SAAS,GAAGF,OAAO,CAACG,QAAQ,GAAGH,OAAO,CAACI,WAAW,GAAGJ,OAAO,CAACK,cAAc,GAAG,KAAK,CAAC;AAC5F,MAAMC,WAAW,GAAGC,OAAO,CAAC,WAAW,CAAC;AACxC;AACA;AACA;AACA,MAAMF,cAAc,CAAC;EACjBG,KAAK;EACLC,WAAW,CAACD,KAAK,GAAG,IAAIE,GAAG,EAAE,EAAE;IAC3B,IAAI,CAACF,KAAK,GAAGA,KAAK;EACtB;EACAG,IAAI,GAAG;IACH,OAAO,IAAIN,cAAc,CAAC,IAAIK,GAAG,CAAC,IAAI,CAACF,KAAK,CAAC,CAAC;EAClD;EACAI,SAAS,CAACC,MAAM,EAAEC,OAAO,EAAE;IACvB,OAAO,IAAI,CAACN,KAAK,CAACO,GAAG,CAACF,MAAM,CAACG,QAAQ,EAAE,CAAC,EAAEC,GAAG,CAACH,OAAO,CAACI,UAAU,EAAE,CAAC;EACvE;EACAC,WAAW,CAACN,MAAM,EAAEC,OAAO,EAAE;IACzB,MAAME,QAAQ,GAAGH,MAAM,CAACG,QAAQ,EAAE;IAClC,MAAMI,MAAM,GAAG,IAAI,CAACZ,KAAK,CAACO,GAAG,CAACC,QAAQ,CAAC;IACvC,IAAII,MAAM,EACNA,MAAM,CAACC,GAAG,CAACP,OAAO,CAACI,UAAU,EAAE,CAAC,CAAC,KAEjC,IAAI,CAACV,KAAK,CAACc,GAAG,CAACN,QAAQ,EAAE,IAAIO,GAAG,CAAC,CAACT,OAAO,CAACI,UAAU,EAAE,CAAC,CAAC,CAAC;EACjE;AACJ;AACAlB,OAAO,CAACK,cAAc,GAAGA,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA,MAAMD,WAAW,CAAC;EACdI,KAAK,GAAG,IAAIE,GAAG,EAAE;EACjBW,GAAG,CAACR,MAAM,EAAEW,QAAQ,EAAEC,KAAK,EAAE;IACzB,MAAMC,CAAC,GAAG,CAACF,QAAQ,GAAG,CAAC,GAAG,CAAC,KAAKC,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;IAC9C,MAAME,OAAO,GAAG,IAAI,CAACnB,KAAK,CAACO,GAAG,CAACF,MAAM,CAAC;IACtC,IAAI,CAACL,KAAK,CAACc,GAAG,CAACT,MAAM,EAAEc,OAAO,KAAKC,SAAS,GAAGF,CAAC,GAAGA,CAAC,GAAGC,OAAO,CAAC;EACnE;EACA;EACAE,OAAO,GAAG;IACN,OAAO,CAAC,GAAG,IAAI,CAACrB,KAAK,CAACqB,OAAO,EAAE,CAAC,CAACC,GAAG,CAAC,CAAC,CAACC,IAAI,EAAEL,CAAC,CAAC,KAAK,CAChDK,IAAI,EACJ,CAAC,EAAEL,CAAC,GAAG,CAAC,CAAC,EACT,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC,CACZ,CAAC;EACN;AACJ;AACA1B,OAAO,CAACI,WAAW,GAAGA,WAAW;AACjC;AACA;AACA;AACA;AACA,MAAMD,QAAQ,CAAC;EACXK,KAAK,GAAG,IAAIE,GAAG,EAAE;EACjBW,GAAG,CAACR,MAAM,EAAEC,OAAO,EAAE;IACjB,IAAI,CAACD,MAAM,CAACmB,UAAU,EAAE,EAAE;MACtB;IACJ;IACA,MAAMC,IAAI,GAAG,IAAI,CAACzB,KAAK,CAACO,GAAG,CAACF,MAAM,CAAC;IACnC,IAAIoB,IAAI,EAAE;MACN,IAAI,CAACA,IAAI,CAACC,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACjB,UAAU,EAAE,KAAKJ,OAAO,CAACI,UAAU,EAAE,CAAC,EAAE;QAC1De,IAAI,CAACG,IAAI,CAACtB,OAAO,CAAC;MACtB;IACJ,CAAC,MAEG,IAAI,CAACN,KAAK,CAACc,GAAG,CAACT,MAAM,EAAE,CAACC,OAAO,CAAC,CAAC;EACzC;EACAC,GAAG,CAACF,MAAM,EAAE;IACR,MAAMoB,IAAI,GAAG,IAAI,CAACzB,KAAK,CAACO,GAAG,CAACF,MAAM,CAAC;IACnC;IACA,IAAI,CAACoB,IAAI,EAAE;MACP,MAAM,IAAII,KAAK,CAAC,iCAAiC,CAAC;IACtD;IACA;IACA,OAAOJ,IAAI;EACf;EACAJ,OAAO,GAAG;IACN,OAAO,IAAI,CAACS,IAAI,EAAE,CAACR,GAAG,CAACS,CAAC,IAAI,CAACA,CAAC,EAAE,IAAI,CAAC/B,KAAK,CAACO,GAAG,CAACwB,CAAC,CAAC,CAAC,CAAC;EACvD;EACAD,IAAI,GAAG;IACH,OAAO,CAAC,GAAG,IAAI,CAAC9B,KAAK,CAAC8B,IAAI,EAAE,CAAC,CAACE,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACT,UAAU,EAAE,CAAC;EAC7D;AACJ;AACAhC,OAAO,CAACG,QAAQ,GAAGA,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,MAAMD,SAAS,CAAC;EACZwC,cAAc;EACdC,OAAO,GAAG,IAAIvC,WAAW,EAAE;EAC3BwC,QAAQ,GAAG,IAAIzC,QAAQ,EAAE;EACzB0C,QAAQ;EACRC,MAAM;EACNC,GAAG;EACHC,IAAI;EACJvC,WAAW,CAACuC,IAAI,EAAEN,cAAc,EAAE;IAC9B,IAAI,CAACM,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACF,MAAM,GAAG,CAAC,CAACE,IAAI,CAACF,MAAM;IAC3B,IAAI,CAACC,GAAG,GAAG,CAAC,CAACC,IAAI,CAACD,GAAG;IACrB,IAAI,CAACL,cAAc,GAAGA,cAAc,GAC9BA,cAAc,CAAC/B,IAAI,EAAE,GACrB,IAAIN,cAAc,EAAE;EAC9B;EACA4C,eAAe,CAACpC,MAAM,EAAEgC,QAAQ,EAAE;IAC9B,IAAI,CAACA,QAAQ,GAAGA,QAAQ;IACxB,MAAMK,aAAa,GAAGL,QAAQ,CAACf,GAAG,CAACK,CAAC,IAAI,CAACtB,MAAM,EAAEsB,CAAC,CAAC,CAAC;IACpD;IACA;IACA,KAAK,IAAI,CAACM,CAAC,EAAE3B,OAAO,CAAC,IAAIoC,aAAa,EAAE;MACpC,IAAI,CAACR,cAAc,CAACvB,WAAW,CAACsB,CAAC,EAAE3B,OAAO,CAAC;MAC3C,MAAMqC,IAAI,GAAGrC,OAAO,CAACqC,IAAI,EAAE;MAC3B,MAAM3B,QAAQ,GAAGV,OAAO,CAACsC,UAAU,EAAE,IAAI,IAAI,CAACJ,IAAI,CAACxB,QAAQ,KAAK,KAAK;MACrE;MACA,IAAI2B,IAAI,EAAE;QACNV,CAAC,GAAGA,CAAC,CAACY,OAAO,CAACF,IAAI,KAAK,GAAG,IAAI,IAAI,CAACH,IAAI,CAACG,IAAI,KAAKvB,SAAS,GACpD,IAAI,CAACoB,IAAI,CAACG,IAAI,GACdA,IAAI,CAAC;QACX,MAAMG,IAAI,GAAGxC,OAAO,CAACwC,IAAI,EAAE;QAC3B,IAAI,CAACA,IAAI,EAAE;UACP,IAAI,CAACX,OAAO,CAACtB,GAAG,CAACoB,CAAC,EAAE,IAAI,EAAE,KAAK,CAAC;UAChC;QACJ,CAAC,MACI;UACD3B,OAAO,GAAGwC,IAAI;QAClB;MACJ;MACA,IAAIb,CAAC,CAACc,QAAQ,EAAE,EACZ;MACJ,IAAIpB,CAAC;MACL,IAAImB,IAAI;MACR,IAAIE,OAAO,GAAG,KAAK;MACnB,OAAO,QAAQrB,CAAC,GAAGrB,OAAO,CAACA,OAAO,EAAE,CAAC,KAAK,QAAQ,KAC7CwC,IAAI,GAAGxC,OAAO,CAACwC,IAAI,EAAE,CAAC,EAAE;QACzB,MAAMG,CAAC,GAAGhB,CAAC,CAACY,OAAO,CAAClB,CAAC,CAAC;QACtBM,CAAC,GAAGgB,CAAC;QACL3C,OAAO,GAAGwC,IAAI;QACdE,OAAO,GAAG,IAAI;MAClB;MACArB,CAAC,GAAGrB,OAAO,CAACA,OAAO,EAAE;MACrBwC,IAAI,GAAGxC,OAAO,CAACwC,IAAI,EAAE;MACrB,IAAIE,OAAO,EAAE;QACT,IAAI,IAAI,CAACd,cAAc,CAAC9B,SAAS,CAAC6B,CAAC,EAAE3B,OAAO,CAAC,EACzC;QACJ,IAAI,CAAC4B,cAAc,CAACvB,WAAW,CAACsB,CAAC,EAAE3B,OAAO,CAAC;MAC/C;MACA;MACA;MACA;MACA,IAAI,OAAOqB,CAAC,KAAK,QAAQ,EAAE;QACvB;QACA;QACA,MAAMV,KAAK,GAAGU,CAAC,KAAK,IAAI,IAAIA,CAAC,KAAK,EAAE,IAAIA,CAAC,KAAK,GAAG;QACjD,IAAI,CAACQ,OAAO,CAACtB,GAAG,CAACoB,CAAC,CAACY,OAAO,CAAClB,CAAC,CAAC,EAAEX,QAAQ,EAAEC,KAAK,CAAC;QAC/C;MACJ,CAAC,MACI,IAAIU,CAAC,KAAK7B,WAAW,CAACoD,QAAQ,EAAE;QACjC;QACA;QACA;QACA;QACA;QACA,IAAI,CAACjB,CAAC,CAACkB,cAAc,EAAE,IACnB,IAAI,CAACb,MAAM,IACXhC,OAAO,CAAC8C,mBAAmB,EAAE,EAAE;UAC/B,IAAI,CAAChB,QAAQ,CAACvB,GAAG,CAACoB,CAAC,EAAE3B,OAAO,CAAC;QACjC;QACA,MAAM+C,EAAE,GAAGP,IAAI,EAAExC,OAAO,EAAE;QAC1B,MAAMgD,KAAK,GAAGR,IAAI,EAAEA,IAAI,EAAE;QAC1B,IAAI,CAACA,IAAI,IAAK,CAACO,EAAE,KAAK,EAAE,IAAIA,EAAE,KAAK,GAAG,KAAK,CAACC,KAAM,EAAE;UAChD;UACA;UACA,IAAI,CAACnB,OAAO,CAACtB,GAAG,CAACoB,CAAC,EAAEjB,QAAQ,EAAEqC,EAAE,KAAK,EAAE,IAAIA,EAAE,KAAK,GAAG,CAAC;QAC1D,CAAC,MACI;UACD,IAAIA,EAAE,KAAK,IAAI,EAAE;YACb;YACA;YACA;YACA,MAAME,EAAE,GAAGtB,CAAC,CAACuB,MAAM,IAAIvB,CAAC;YACxB;YACA,IAAI,CAACqB,KAAK,EACN,IAAI,CAACnB,OAAO,CAACtB,GAAG,CAAC0C,EAAE,EAAEvC,QAAQ,EAAE,IAAI,CAAC,CAAC,KACpC,IAAI,CAAC,IAAI,CAACkB,cAAc,CAAC9B,SAAS,CAACmD,EAAE,EAAED,KAAK,CAAC,EAAE;cAChD,IAAI,CAAClB,QAAQ,CAACvB,GAAG,CAAC0C,EAAE,EAAED,KAAK,CAAC;YAChC;UACJ;QACJ;MACJ,CAAC,MACI,IAAI3B,CAAC,YAAY8B,MAAM,EAAE;QAC1B,IAAI,CAACrB,QAAQ,CAACvB,GAAG,CAACoB,CAAC,EAAE3B,OAAO,CAAC;MACjC;IACJ;IACA,OAAO,IAAI;EACf;EACAoD,cAAc,GAAG;IACb,OAAO,IAAI,CAACtB,QAAQ,CAACN,IAAI,EAAE;EAC/B;EACA6B,KAAK,GAAG;IACJ,OAAO,IAAIjE,SAAS,CAAC,IAAI,CAAC8C,IAAI,EAAE,IAAI,CAACN,cAAc,CAAC;EACxD;EACA;EACA;EACA;EACA;EACA0B,aAAa,CAACJ,MAAM,EAAEnC,OAAO,EAAE;IAC3B,MAAMgB,QAAQ,GAAG,IAAI,CAACD,QAAQ,CAAC7B,GAAG,CAACiD,MAAM,CAAC;IAC1C;IACA,MAAMK,OAAO,GAAG,IAAI,CAACF,KAAK,EAAE;IAC5B,KAAK,MAAMG,CAAC,IAAIzC,OAAO,EAAE;MACrB,KAAK,MAAMf,OAAO,IAAI+B,QAAQ,EAAE;QAC5B,MAAMrB,QAAQ,GAAGV,OAAO,CAACsC,UAAU,EAAE;QACrC,MAAMjB,CAAC,GAAGrB,OAAO,CAACA,OAAO,EAAE;QAC3B,MAAMwC,IAAI,GAAGxC,OAAO,CAACwC,IAAI,EAAE;QAC3B,IAAInB,CAAC,KAAK7B,WAAW,CAACoD,QAAQ,EAAE;UAC5BW,OAAO,CAACE,YAAY,CAACD,CAAC,EAAExD,OAAO,EAAEwC,IAAI,EAAE9B,QAAQ,CAAC;QACpD,CAAC,MACI,IAAIW,CAAC,YAAY8B,MAAM,EAAE;UAC1BI,OAAO,CAACG,UAAU,CAACF,CAAC,EAAEnC,CAAC,EAAEmB,IAAI,EAAE9B,QAAQ,CAAC;QAC5C,CAAC,MACI;UACD6C,OAAO,CAACI,UAAU,CAACH,CAAC,EAAEnC,CAAC,EAAEmB,IAAI,EAAE9B,QAAQ,CAAC;QAC5C;MACJ;IACJ;IACA,OAAO6C,OAAO;EAClB;EACAE,YAAY,CAACD,CAAC,EAAExD,OAAO,EAAEwC,IAAI,EAAE9B,QAAQ,EAAE;IACrC,IAAI,IAAI,CAACuB,GAAG,IAAI,CAACuB,CAAC,CAACI,IAAI,CAACC,UAAU,CAAC,GAAG,CAAC,EAAE;MACrC,IAAI,CAAC7D,OAAO,CAAC8D,OAAO,EAAE,EAAE;QACpB,IAAI,CAACjC,OAAO,CAACtB,GAAG,CAACiD,CAAC,EAAE9C,QAAQ,EAAE,KAAK,CAAC;MACxC;MACA,IAAI8C,CAAC,CAACtC,UAAU,EAAE,EAAE;QAChB;QACA;QACA;QACA;QACA;QACA,IAAI,IAAI,CAACc,MAAM,IAAI,CAACwB,CAAC,CAACX,cAAc,EAAE,EAAE;UACpC,IAAI,CAACf,QAAQ,CAACvB,GAAG,CAACiD,CAAC,EAAExD,OAAO,CAAC;QACjC,CAAC,MACI,IAAIwD,CAAC,CAACX,cAAc,EAAE,EAAE;UACzB,IAAIL,IAAI,IAAIxC,OAAO,CAAC8C,mBAAmB,EAAE,EAAE;YACvC,IAAI,CAAChB,QAAQ,CAACvB,GAAG,CAACiD,CAAC,EAAEhB,IAAI,CAAC;UAC9B,CAAC,MACI,IAAIxC,OAAO,CAAC+D,kBAAkB,EAAE,EAAE;YACnC,IAAI,CAACjC,QAAQ,CAACvB,GAAG,CAACiD,CAAC,EAAExD,OAAO,CAAC;UACjC;QACJ;MACJ;IACJ;IACA;IACA;IACA,IAAIwC,IAAI,EAAE;MACN,MAAMO,EAAE,GAAGP,IAAI,CAACxC,OAAO,EAAE;MACzB,IAAI,OAAO+C,EAAE,KAAK,QAAQ;MACtB;MACAA,EAAE,KAAK,IAAI,IACXA,EAAE,KAAK,EAAE,IACTA,EAAE,KAAK,GAAG,EAAE;QACZ,IAAI,CAACY,UAAU,CAACH,CAAC,EAAET,EAAE,EAAEP,IAAI,CAACA,IAAI,EAAE,EAAE9B,QAAQ,CAAC;MACjD,CAAC,MACI,IAAIqC,EAAE,KAAK,IAAI,EAAE;QAClB;QACA,MAAMiB,EAAE,GAAGR,CAAC,CAACN,MAAM,IAAIM,CAAC;QACxB;QACA,IAAI,CAAC1B,QAAQ,CAACvB,GAAG,CAACyD,EAAE,EAAExB,IAAI,CAAC;MAC/B,CAAC,MACI,IAAIO,EAAE,YAAYI,MAAM,EAAE;QAC3B,IAAI,CAACO,UAAU,CAACF,CAAC,EAAET,EAAE,EAAEP,IAAI,CAACA,IAAI,EAAE,EAAE9B,QAAQ,CAAC;MACjD;IACJ;EACJ;EACAgD,UAAU,CAACF,CAAC,EAAEnC,CAAC,EAAEmB,IAAI,EAAE9B,QAAQ,EAAE;IAC7B,IAAI,CAACW,CAAC,CAAC4C,IAAI,CAACT,CAAC,CAACI,IAAI,CAAC,EACf;IACJ,IAAI,CAACpB,IAAI,EAAE;MACP,IAAI,CAACX,OAAO,CAACtB,GAAG,CAACiD,CAAC,EAAE9C,QAAQ,EAAE,KAAK,CAAC;IACxC,CAAC,MACI;MACD,IAAI,CAACoB,QAAQ,CAACvB,GAAG,CAACiD,CAAC,EAAEhB,IAAI,CAAC;IAC9B;EACJ;EACAmB,UAAU,CAACH,CAAC,EAAEnC,CAAC,EAAEmB,IAAI,EAAE9B,QAAQ,EAAE;IAC7B;IACA,IAAI,CAAC8C,CAAC,CAACU,OAAO,CAAC7C,CAAC,CAAC,EACb;IACJ,IAAI,CAACmB,IAAI,EAAE;MACP,IAAI,CAACX,OAAO,CAACtB,GAAG,CAACiD,CAAC,EAAE9C,QAAQ,EAAE,KAAK,CAAC;IACxC,CAAC,MACI;MACD,IAAI,CAACoB,QAAQ,CAACvB,GAAG,CAACiD,CAAC,EAAEhB,IAAI,CAAC;IAC9B;EACJ;AACJ;AACAtD,OAAO,CAACE,SAAS,GAAGA,SAAS"},"metadata":{},"sourceType":"script","externalDependencies":[]}