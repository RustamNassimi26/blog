{"ast":null,"code":"\"use strict\";\n\n// parse a single path portion\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AST = void 0;\nconst brace_expressions_js_1 = require(\"./brace-expressions.js\");\nconst unescape_js_1 = require(\"./unescape.js\");\nconst types = new Set(['!', '?', '+', '*', '@']);\nconst isExtglobType = c => types.has(c);\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))';\nconst startNoDot = '(?!\\\\.)';\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.']);\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.']);\nconst reSpecials = new Set('().*{}+?[]^$\\\\!');\nconst regExpEscape = s => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// any single thing other than /\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?';\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\nclass AST {\n  type;\n  #root;\n  #hasMagic;\n  #uflag = false;\n  #parts = [];\n  #parent;\n  #parentIndex;\n  #negs;\n  #filledNegs = false;\n  #options;\n  #toString;\n  // set to true if it's an extglob with no children\n  // (which really means one child of '')\n  #emptyExt = false;\n  constructor(type, parent, options = {}) {\n    this.type = type;\n    // extglobs are inherently magical\n    if (type) this.#hasMagic = true;\n    this.#parent = parent;\n    this.#root = this.#parent ? this.#parent.#root : this;\n    this.#options = this.#root === this ? options : this.#root.#options;\n    this.#negs = this.#root === this ? [] : this.#root.#negs;\n    if (type === '!' && !this.#root.#filledNegs) this.#negs.push(this);\n    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;\n  }\n  get hasMagic() {\n    /* c8 ignore start */\n    if (this.#hasMagic !== undefined) return this.#hasMagic;\n    /* c8 ignore stop */\n    for (const p of this.#parts) {\n      if (typeof p === 'string') continue;\n      if (p.type || p.hasMagic) return this.#hasMagic = true;\n    }\n    // note: will be undefined until we generate the regexp src and find out\n    return this.#hasMagic;\n  }\n  // reconstructs the pattern\n  toString() {\n    if (this.#toString !== undefined) return this.#toString;\n    if (!this.type) {\n      return this.#toString = this.#parts.map(p => String(p)).join('');\n    } else {\n      return this.#toString = this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')';\n    }\n  }\n  #fillNegs() {\n    /* c8 ignore start */\n    if (this !== this.#root) throw new Error('should only call on root');\n    if (this.#filledNegs) return this;\n    /* c8 ignore stop */\n    // call toString() once to fill this out\n    this.toString();\n    this.#filledNegs = true;\n    let n;\n    while (n = this.#negs.pop()) {\n      if (n.type !== '!') continue;\n      // walk up the tree, appending everthing that comes AFTER parentIndex\n      let p = n;\n      let pp = p.#parent;\n      while (pp) {\n        for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {\n          for (const part of n.#parts) {\n            /* c8 ignore start */\n            if (typeof part === 'string') {\n              throw new Error('string part in extglob AST??');\n            }\n            /* c8 ignore stop */\n            part.copyIn(pp.#parts[i]);\n          }\n        }\n        p = pp;\n        pp = p.#parent;\n      }\n    }\n    return this;\n  }\n  push(...parts) {\n    for (const p of parts) {\n      if (p === '') continue;\n      /* c8 ignore start */\n      if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n        throw new Error('invalid part: ' + p);\n      }\n      /* c8 ignore stop */\n      this.#parts.push(p);\n    }\n  }\n  toJSON() {\n    const ret = this.type === null ? this.#parts.slice().map(p => typeof p === 'string' ? p : p.toJSON()) : [this.type, ...this.#parts.map(p => p.toJSON())];\n    if (this.isStart() && !this.type) ret.unshift([]);\n    if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === '!')) {\n      ret.push({});\n    }\n    return ret;\n  }\n  isStart() {\n    if (this.#root === this) return true;\n    // if (this.type) return !!this.#parent?.isStart()\n    if (!this.#parent?.isStart()) return false;\n    if (this.#parentIndex === 0) return true;\n    // if everything AHEAD of this is a negation, then it's still the \"start\"\n    const p = this.#parent;\n    for (let i = 0; i < this.#parentIndex; i++) {\n      const pp = p.#parts[i];\n      if (!(pp instanceof AST && pp.type === '!')) {\n        return false;\n      }\n    }\n    return true;\n  }\n  isEnd() {\n    if (this.#root === this) return true;\n    if (this.#parent?.type === '!') return true;\n    if (!this.#parent?.isEnd()) return false;\n    if (!this.type) return this.#parent?.isEnd();\n    // if not root, it'll always have a parent\n    /* c8 ignore start */\n    const pl = this.#parent ? this.#parent.#parts.length : 0;\n    /* c8 ignore stop */\n    return this.#parentIndex === pl - 1;\n  }\n  copyIn(part) {\n    if (typeof part === 'string') this.push(part);else this.push(part.clone(this));\n  }\n  clone(parent) {\n    const c = new AST(this.type, parent);\n    for (const p of this.#parts) {\n      c.copyIn(p);\n    }\n    return c;\n  }\n  static #parseAST(str, ast, pos, opt) {\n    let escaping = false;\n    let inBrace = false;\n    let braceStart = -1;\n    let braceNeg = false;\n    if (ast.type === null) {\n      // outside of a extglob, append until we find a start\n      let i = pos;\n      let acc = '';\n      while (i < str.length) {\n        const c = str.charAt(i++);\n        // still accumulate escapes at this point, but we do ignore\n        // starts that are escaped\n        if (escaping || c === '\\\\') {\n          escaping = !escaping;\n          acc += c;\n          continue;\n        }\n        if (inBrace) {\n          if (i === braceStart + 1) {\n            if (c === '^' || c === '!') {\n              braceNeg = true;\n            }\n          } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n            inBrace = false;\n          }\n          acc += c;\n          continue;\n        } else if (c === '[') {\n          inBrace = true;\n          braceStart = i;\n          braceNeg = false;\n          acc += c;\n          continue;\n        }\n        if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n          ast.push(acc);\n          acc = '';\n          const ext = new AST(c, ast);\n          i = AST.#parseAST(str, ext, i, opt);\n          ast.push(ext);\n          continue;\n        }\n        acc += c;\n      }\n      ast.push(acc);\n      return i;\n    }\n    // some kind of extglob, pos is at the (\n    // find the next | or )\n    let i = pos + 1;\n    let part = new AST(null, ast);\n    const parts = [];\n    let acc = '';\n    while (i < str.length) {\n      const c = str.charAt(i++);\n      // still accumulate escapes at this point, but we do ignore\n      // starts that are escaped\n      if (escaping || c === '\\\\') {\n        escaping = !escaping;\n        acc += c;\n        continue;\n      }\n      if (inBrace) {\n        if (i === braceStart + 1) {\n          if (c === '^' || c === '!') {\n            braceNeg = true;\n          }\n        } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n          inBrace = false;\n        }\n        acc += c;\n        continue;\n      } else if (c === '[') {\n        inBrace = true;\n        braceStart = i;\n        braceNeg = false;\n        acc += c;\n        continue;\n      }\n      if (isExtglobType(c) && str.charAt(i) === '(') {\n        part.push(acc);\n        acc = '';\n        const ext = new AST(c, part);\n        part.push(ext);\n        i = AST.#parseAST(str, ext, i, opt);\n        continue;\n      }\n      if (c === '|') {\n        part.push(acc);\n        acc = '';\n        parts.push(part);\n        part = new AST(null, ast);\n        continue;\n      }\n      if (c === ')') {\n        if (acc === '' && ast.#parts.length === 0) {\n          ast.#emptyExt = true;\n        }\n        part.push(acc);\n        acc = '';\n        ast.push(...parts, part);\n        return i;\n      }\n      acc += c;\n    }\n    // unfinished extglob\n    // if we got here, it was a malformed extglob! not an extglob, but\n    // maybe something else in there.\n    ast.type = null;\n    ast.#hasMagic = undefined;\n    ast.#parts = [str.substring(pos - 1)];\n    return i;\n  }\n  static fromGlob(pattern, options = {}) {\n    const ast = new AST(null, undefined, options);\n    AST.#parseAST(pattern, ast, 0, options);\n    return ast;\n  }\n  // returns the regular expression if there's magic, or the unescaped\n  // string if not.\n  toMMPattern() {\n    // should only be called on root\n    /* c8 ignore start */\n    if (this !== this.#root) return this.#root.toMMPattern();\n    /* c8 ignore stop */\n    const glob = this.toString();\n    const [re, body, hasMagic, uflag] = this.toRegExpSource();\n    // if we're in nocase mode, and not nocaseMagicOnly, then we do\n    // still need a regular expression if we have to case-insensitively\n    // match capital/lowercase characters.\n    const anyMagic = hasMagic || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();\n    if (!anyMagic) {\n      return body;\n    }\n    const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');\n    return Object.assign(new RegExp(`^${re}$`, flags), {\n      _src: re,\n      _glob: glob\n    });\n  }\n  // returns the string match, the regexp source, whether there's magic\n  // in the regexp (so a regular expression is required) and whether or\n  // not the uflag is needed for the regular expression (for posix classes)\n  // TODO: instead of injecting the start/end at this point, just return\n  // the BODY of the regexp, along with the start/end portions suitable\n  // for binding the start/end in either a joined full-path makeRe context\n  // (where we bind to (^|/), or a standalone matchPart context (where\n  // we bind to ^, and not /).  Otherwise slashes get duped!\n  //\n  // In part-matching mode, the start is:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n  // - if dots allowed or not possible: ^\n  // - if dots possible and not allowed: ^(?!\\.)\n  // end is:\n  // - if not isEnd(): nothing\n  // - else: $\n  //\n  // In full-path matching mode, we put the slash at the START of the\n  // pattern, so start is:\n  // - if first pattern: same as part-matching mode\n  // - if not isStart(): nothing\n  // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n  // - if dots allowed or not possible: /\n  // - if dots possible and not allowed: /(?!\\.)\n  // end is:\n  // - if last pattern, same as part-matching mode\n  // - else nothing\n  //\n  // Always put the (?:$|/) on negated tails, though, because that has to be\n  // there to bind the end of the negated pattern portion, and it's easier to\n  // just stick it in now rather than try to inject it later in the middle of\n  // the pattern.\n  //\n  // We can just always return the same end, and leave it up to the caller\n  // to know whether it's going to be used joined or in parts.\n  // And, if the start is adjusted slightly, can do the same there:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n  // - if dots allowed or not possible: (?:/|^)\n  // - if dots possible and not allowed: (?:/|^)(?!\\.)\n  //\n  // But it's better to have a simpler binding without a conditional, for\n  // performance, so probably better to return both start options.\n  //\n  // Then the caller just ignores the end if it's not the first pattern,\n  // and the start always gets applied.\n  //\n  // But that's always going to be $ if it's the ending pattern, or nothing,\n  // so the caller can just attach $ at the end of the pattern when building.\n  //\n  // So the todo is:\n  // - better detect what kind of start is needed\n  // - return both flavors of starting pattern\n  // - attach $ at the end of the pattern when creating the actual RegExp\n  //\n  // Ah, but wait, no, that all only applies to the root when the first pattern\n  // is not an extglob. If the first pattern IS an extglob, then we need all\n  // that dot prevention biz to live in the extglob portions, because eg\n  // +(*|.x*) can match .xy but not .yx.\n  //\n  // So, return the two flavors if it's #root and the first child is not an\n  // AST, otherwise leave it to the child AST to handle it, and there,\n  // use the (?:^|/) style of start binding.\n  //\n  // Even simplified further:\n  // - Since the start for a join is eg /(?!\\.) and the start for a part\n  // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n  // or start or whatever) and prepend ^ or / at the Regexp construction.\n  toRegExpSource(allowDot) {\n    const dot = allowDot ?? !!this.#options.dot;\n    if (this.#root === this) this.#fillNegs();\n    if (!this.type) {\n      const noEmpty = this.isStart() && this.isEnd();\n      const src = this.#parts.map(p => {\n        const [re, _, hasMagic, uflag] = typeof p === 'string' ? AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);\n        this.#hasMagic = this.#hasMagic || hasMagic;\n        this.#uflag = this.#uflag || uflag;\n        return re;\n      }).join('');\n      let start = '';\n      if (this.isStart()) {\n        if (typeof this.#parts[0] === 'string') {\n          // this is the string that will match the start of the pattern,\n          // so we need to protect against dots and such.\n          // '.' and '..' cannot match unless the pattern is that exactly,\n          // even if it starts with . or dot:true is set.\n          const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);\n          if (!dotTravAllowed) {\n            const aps = addPatternStart;\n            // check if we have a possibility of matching . or ..,\n            // and prevent that.\n            const needNoTrav =\n            // dots are allowed, and the pattern starts with [ or .\n            dot && aps.has(src.charAt(0)) ||\n            // the pattern starts with \\., and then [ or .\n            src.startsWith('\\\\.') && aps.has(src.charAt(2)) ||\n            // the pattern starts with \\.\\., and then [ or .\n            src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4));\n            // no need to prevent dots if it can't match a dot, or if a\n            // sub-pattern will be preventing it anyway.\n            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));\n            start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';\n          }\n        }\n      }\n      // append the \"end of path portion\" pattern to negation tails\n      let end = '';\n      if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === '!') {\n        end = '(?:$|\\\\/)';\n      }\n      const final = start + src + end;\n      return [final, (0, unescape_js_1.unescape)(src), this.#hasMagic = !!this.#hasMagic, this.#uflag];\n    }\n    // We need to calculate the body *twice* if it's a repeat pattern\n    // at the start, once in nodot mode, then again in dot mode, so a\n    // pattern like *(?) can match 'x.y'\n    const repeated = this.type === '*' || this.type === '+';\n    // some kind of extglob\n    const start = this.type === '!' ? '(?:(?!(?:' : '(?:';\n    let body = this.#partsToRegExp(dot);\n    if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n      // invalid extglob, has to at least be *something* present, if it's\n      // the entire path portion.\n      const s = this.toString();\n      this.#parts = [s];\n      this.type = null;\n      this.#hasMagic = undefined;\n      return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];\n    }\n    // XXX abstract out this map method\n    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? '' : this.#partsToRegExp(true);\n    if (bodyDotAllowed === body) {\n      bodyDotAllowed = '';\n    }\n    if (bodyDotAllowed) {\n      body = `(?:${body})(?:${bodyDotAllowed})*?`;\n    }\n    // an empty !() is exactly equivalent to a starNoEmpty\n    let final = '';\n    if (this.type === '!' && this.#emptyExt) {\n      final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;\n    } else {\n      const close = this.type === '!' ?\n      // !() must match something,but !(x) can match ''\n      '))' + (this.isStart() && !dot && !allowDot ? startNoDot : '') + star + ')' : this.type === '@' ? ')' : this.type === '?' ? ')?' : this.type === '+' && bodyDotAllowed ? ')' : this.type === '*' && bodyDotAllowed ? `)?` : `)${this.type}`;\n      final = start + body + close;\n    }\n    return [final, (0, unescape_js_1.unescape)(body), this.#hasMagic = !!this.#hasMagic, this.#uflag];\n  }\n  #partsToRegExp(dot) {\n    return this.#parts.map(p => {\n      // extglob ASTs should only contain parent ASTs\n      /* c8 ignore start */\n      if (typeof p === 'string') {\n        throw new Error('string type in extglob ast??');\n      }\n      /* c8 ignore stop */\n      // can ignore hasMagic, because extglobs are already always magic\n      const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);\n      this.#uflag = this.#uflag || uflag;\n      return re;\n    }).filter(p => !(this.isStart() && this.isEnd()) || !!p).join('|');\n  }\n  static #parseGlob(glob, hasMagic, noEmpty = false) {\n    let escaping = false;\n    let re = '';\n    let uflag = false;\n    for (let i = 0; i < glob.length; i++) {\n      const c = glob.charAt(i);\n      if (escaping) {\n        escaping = false;\n        re += (reSpecials.has(c) ? '\\\\' : '') + c;\n        continue;\n      }\n      if (c === '\\\\') {\n        if (i === glob.length - 1) {\n          re += '\\\\\\\\';\n        } else {\n          escaping = true;\n        }\n        continue;\n      }\n      if (c === '[') {\n        const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);\n        if (consumed) {\n          re += src;\n          uflag = uflag || needUflag;\n          i += consumed - 1;\n          hasMagic = hasMagic || magic;\n          continue;\n        }\n      }\n      if (c === '*') {\n        if (noEmpty && glob === '*') re += starNoEmpty;else re += star;\n        hasMagic = true;\n        continue;\n      }\n      if (c === '?') {\n        re += qmark;\n        hasMagic = true;\n        continue;\n      }\n      re += regExpEscape(c);\n    }\n    return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];\n  }\n}\nexports.AST = AST;","map":{"version":3,"names":["Object","defineProperty","exports","value","AST","brace_expressions_js_1","require","unescape_js_1","types","Set","isExtglobType","c","has","startNoTraversal","startNoDot","addPatternStart","justDots","reSpecials","regExpEscape","s","replace","qmark","star","starNoEmpty","type","root","hasMagic","uflag","parts","parent","parentIndex","negs","filledNegs","options","toString","emptyExt","constructor","push","length","undefined","p","map","String","join","fillNegs","Error","n","pop","pp","i","part","copyIn","toJSON","ret","slice","isStart","unshift","isEnd","pl","clone","parseAST","str","ast","pos","opt","escaping","inBrace","braceStart","braceNeg","acc","charAt","noext","ext","substring","fromGlob","pattern","toMMPattern","glob","re","body","toRegExpSource","anyMagic","nocase","nocaseMagicOnly","toUpperCase","toLowerCase","flags","assign","RegExp","_src","_glob","allowDot","dot","noEmpty","src","_","parseGlob","start","dotTravAllowed","aps","needNoTrav","startsWith","needNoDot","end","final","unescape","repeated","partsToRegExp","bodyDotAllowed","close","_hasMagic","filter","needUflag","consumed","magic","parseClass"],"sources":["I:/Angular/angular-blog/node_modules/ignore-walk/node_modules/minimatch/dist/cjs/ast.js"],"sourcesContent":["\"use strict\";\n// parse a single path portion\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AST = void 0;\nconst brace_expressions_js_1 = require(\"./brace-expressions.js\");\nconst unescape_js_1 = require(\"./unescape.js\");\nconst types = new Set(['!', '?', '+', '*', '@']);\nconst isExtglobType = (c) => types.has(c);\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))';\nconst startNoDot = '(?!\\\\.)';\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.']);\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.']);\nconst reSpecials = new Set('().*{}+?[]^$\\\\!');\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// any single thing other than /\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?';\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\nclass AST {\n    type;\n    #root;\n    #hasMagic;\n    #uflag = false;\n    #parts = [];\n    #parent;\n    #parentIndex;\n    #negs;\n    #filledNegs = false;\n    #options;\n    #toString;\n    // set to true if it's an extglob with no children\n    // (which really means one child of '')\n    #emptyExt = false;\n    constructor(type, parent, options = {}) {\n        this.type = type;\n        // extglobs are inherently magical\n        if (type)\n            this.#hasMagic = true;\n        this.#parent = parent;\n        this.#root = this.#parent ? this.#parent.#root : this;\n        this.#options = this.#root === this ? options : this.#root.#options;\n        this.#negs = this.#root === this ? [] : this.#root.#negs;\n        if (type === '!' && !this.#root.#filledNegs)\n            this.#negs.push(this);\n        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;\n    }\n    get hasMagic() {\n        /* c8 ignore start */\n        if (this.#hasMagic !== undefined)\n            return this.#hasMagic;\n        /* c8 ignore stop */\n        for (const p of this.#parts) {\n            if (typeof p === 'string')\n                continue;\n            if (p.type || p.hasMagic)\n                return (this.#hasMagic = true);\n        }\n        // note: will be undefined until we generate the regexp src and find out\n        return this.#hasMagic;\n    }\n    // reconstructs the pattern\n    toString() {\n        if (this.#toString !== undefined)\n            return this.#toString;\n        if (!this.type) {\n            return (this.#toString = this.#parts.map(p => String(p)).join(''));\n        }\n        else {\n            return (this.#toString =\n                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');\n        }\n    }\n    #fillNegs() {\n        /* c8 ignore start */\n        if (this !== this.#root)\n            throw new Error('should only call on root');\n        if (this.#filledNegs)\n            return this;\n        /* c8 ignore stop */\n        // call toString() once to fill this out\n        this.toString();\n        this.#filledNegs = true;\n        let n;\n        while ((n = this.#negs.pop())) {\n            if (n.type !== '!')\n                continue;\n            // walk up the tree, appending everthing that comes AFTER parentIndex\n            let p = n;\n            let pp = p.#parent;\n            while (pp) {\n                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {\n                    for (const part of n.#parts) {\n                        /* c8 ignore start */\n                        if (typeof part === 'string') {\n                            throw new Error('string part in extglob AST??');\n                        }\n                        /* c8 ignore stop */\n                        part.copyIn(pp.#parts[i]);\n                    }\n                }\n                p = pp;\n                pp = p.#parent;\n            }\n        }\n        return this;\n    }\n    push(...parts) {\n        for (const p of parts) {\n            if (p === '')\n                continue;\n            /* c8 ignore start */\n            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n                throw new Error('invalid part: ' + p);\n            }\n            /* c8 ignore stop */\n            this.#parts.push(p);\n        }\n    }\n    toJSON() {\n        const ret = this.type === null\n            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n            : [this.type, ...this.#parts.map(p => p.toJSON())];\n        if (this.isStart() && !this.type)\n            ret.unshift([]);\n        if (this.isEnd() &&\n            (this === this.#root ||\n                (this.#root.#filledNegs && this.#parent?.type === '!'))) {\n            ret.push({});\n        }\n        return ret;\n    }\n    isStart() {\n        if (this.#root === this)\n            return true;\n        // if (this.type) return !!this.#parent?.isStart()\n        if (!this.#parent?.isStart())\n            return false;\n        if (this.#parentIndex === 0)\n            return true;\n        // if everything AHEAD of this is a negation, then it's still the \"start\"\n        const p = this.#parent;\n        for (let i = 0; i < this.#parentIndex; i++) {\n            const pp = p.#parts[i];\n            if (!(pp instanceof AST && pp.type === '!')) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isEnd() {\n        if (this.#root === this)\n            return true;\n        if (this.#parent?.type === '!')\n            return true;\n        if (!this.#parent?.isEnd())\n            return false;\n        if (!this.type)\n            return this.#parent?.isEnd();\n        // if not root, it'll always have a parent\n        /* c8 ignore start */\n        const pl = this.#parent ? this.#parent.#parts.length : 0;\n        /* c8 ignore stop */\n        return this.#parentIndex === pl - 1;\n    }\n    copyIn(part) {\n        if (typeof part === 'string')\n            this.push(part);\n        else\n            this.push(part.clone(this));\n    }\n    clone(parent) {\n        const c = new AST(this.type, parent);\n        for (const p of this.#parts) {\n            c.copyIn(p);\n        }\n        return c;\n    }\n    static #parseAST(str, ast, pos, opt) {\n        let escaping = false;\n        let inBrace = false;\n        let braceStart = -1;\n        let braceNeg = false;\n        if (ast.type === null) {\n            // outside of a extglob, append until we find a start\n            let i = pos;\n            let acc = '';\n            while (i < str.length) {\n                const c = str.charAt(i++);\n                // still accumulate escapes at this point, but we do ignore\n                // starts that are escaped\n                if (escaping || c === '\\\\') {\n                    escaping = !escaping;\n                    acc += c;\n                    continue;\n                }\n                if (inBrace) {\n                    if (i === braceStart + 1) {\n                        if (c === '^' || c === '!') {\n                            braceNeg = true;\n                        }\n                    }\n                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                        inBrace = false;\n                    }\n                    acc += c;\n                    continue;\n                }\n                else if (c === '[') {\n                    inBrace = true;\n                    braceStart = i;\n                    braceNeg = false;\n                    acc += c;\n                    continue;\n                }\n                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n                    ast.push(acc);\n                    acc = '';\n                    const ext = new AST(c, ast);\n                    i = AST.#parseAST(str, ext, i, opt);\n                    ast.push(ext);\n                    continue;\n                }\n                acc += c;\n            }\n            ast.push(acc);\n            return i;\n        }\n        // some kind of extglob, pos is at the (\n        // find the next | or )\n        let i = pos + 1;\n        let part = new AST(null, ast);\n        const parts = [];\n        let acc = '';\n        while (i < str.length) {\n            const c = str.charAt(i++);\n            // still accumulate escapes at this point, but we do ignore\n            // starts that are escaped\n            if (escaping || c === '\\\\') {\n                escaping = !escaping;\n                acc += c;\n                continue;\n            }\n            if (inBrace) {\n                if (i === braceStart + 1) {\n                    if (c === '^' || c === '!') {\n                        braceNeg = true;\n                    }\n                }\n                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                    inBrace = false;\n                }\n                acc += c;\n                continue;\n            }\n            else if (c === '[') {\n                inBrace = true;\n                braceStart = i;\n                braceNeg = false;\n                acc += c;\n                continue;\n            }\n            if (isExtglobType(c) && str.charAt(i) === '(') {\n                part.push(acc);\n                acc = '';\n                const ext = new AST(c, part);\n                part.push(ext);\n                i = AST.#parseAST(str, ext, i, opt);\n                continue;\n            }\n            if (c === '|') {\n                part.push(acc);\n                acc = '';\n                parts.push(part);\n                part = new AST(null, ast);\n                continue;\n            }\n            if (c === ')') {\n                if (acc === '' && ast.#parts.length === 0) {\n                    ast.#emptyExt = true;\n                }\n                part.push(acc);\n                acc = '';\n                ast.push(...parts, part);\n                return i;\n            }\n            acc += c;\n        }\n        // unfinished extglob\n        // if we got here, it was a malformed extglob! not an extglob, but\n        // maybe something else in there.\n        ast.type = null;\n        ast.#hasMagic = undefined;\n        ast.#parts = [str.substring(pos - 1)];\n        return i;\n    }\n    static fromGlob(pattern, options = {}) {\n        const ast = new AST(null, undefined, options);\n        AST.#parseAST(pattern, ast, 0, options);\n        return ast;\n    }\n    // returns the regular expression if there's magic, or the unescaped\n    // string if not.\n    toMMPattern() {\n        // should only be called on root\n        /* c8 ignore start */\n        if (this !== this.#root)\n            return this.#root.toMMPattern();\n        /* c8 ignore stop */\n        const glob = this.toString();\n        const [re, body, hasMagic, uflag] = this.toRegExpSource();\n        // if we're in nocase mode, and not nocaseMagicOnly, then we do\n        // still need a regular expression if we have to case-insensitively\n        // match capital/lowercase characters.\n        const anyMagic = hasMagic ||\n            this.#hasMagic ||\n            (this.#options.nocase &&\n                !this.#options.nocaseMagicOnly &&\n                glob.toUpperCase() !== glob.toLowerCase());\n        if (!anyMagic) {\n            return body;\n        }\n        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');\n        return Object.assign(new RegExp(`^${re}$`, flags), {\n            _src: re,\n            _glob: glob,\n        });\n    }\n    // returns the string match, the regexp source, whether there's magic\n    // in the regexp (so a regular expression is required) and whether or\n    // not the uflag is needed for the regular expression (for posix classes)\n    // TODO: instead of injecting the start/end at this point, just return\n    // the BODY of the regexp, along with the start/end portions suitable\n    // for binding the start/end in either a joined full-path makeRe context\n    // (where we bind to (^|/), or a standalone matchPart context (where\n    // we bind to ^, and not /).  Otherwise slashes get duped!\n    //\n    // In part-matching mode, the start is:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n    // - if dots allowed or not possible: ^\n    // - if dots possible and not allowed: ^(?!\\.)\n    // end is:\n    // - if not isEnd(): nothing\n    // - else: $\n    //\n    // In full-path matching mode, we put the slash at the START of the\n    // pattern, so start is:\n    // - if first pattern: same as part-matching mode\n    // - if not isStart(): nothing\n    // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n    // - if dots allowed or not possible: /\n    // - if dots possible and not allowed: /(?!\\.)\n    // end is:\n    // - if last pattern, same as part-matching mode\n    // - else nothing\n    //\n    // Always put the (?:$|/) on negated tails, though, because that has to be\n    // there to bind the end of the negated pattern portion, and it's easier to\n    // just stick it in now rather than try to inject it later in the middle of\n    // the pattern.\n    //\n    // We can just always return the same end, and leave it up to the caller\n    // to know whether it's going to be used joined or in parts.\n    // And, if the start is adjusted slightly, can do the same there:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n    // - if dots allowed or not possible: (?:/|^)\n    // - if dots possible and not allowed: (?:/|^)(?!\\.)\n    //\n    // But it's better to have a simpler binding without a conditional, for\n    // performance, so probably better to return both start options.\n    //\n    // Then the caller just ignores the end if it's not the first pattern,\n    // and the start always gets applied.\n    //\n    // But that's always going to be $ if it's the ending pattern, or nothing,\n    // so the caller can just attach $ at the end of the pattern when building.\n    //\n    // So the todo is:\n    // - better detect what kind of start is needed\n    // - return both flavors of starting pattern\n    // - attach $ at the end of the pattern when creating the actual RegExp\n    //\n    // Ah, but wait, no, that all only applies to the root when the first pattern\n    // is not an extglob. If the first pattern IS an extglob, then we need all\n    // that dot prevention biz to live in the extglob portions, because eg\n    // +(*|.x*) can match .xy but not .yx.\n    //\n    // So, return the two flavors if it's #root and the first child is not an\n    // AST, otherwise leave it to the child AST to handle it, and there,\n    // use the (?:^|/) style of start binding.\n    //\n    // Even simplified further:\n    // - Since the start for a join is eg /(?!\\.) and the start for a part\n    // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n    // or start or whatever) and prepend ^ or / at the Regexp construction.\n    toRegExpSource(allowDot) {\n        const dot = allowDot ?? !!this.#options.dot;\n        if (this.#root === this)\n            this.#fillNegs();\n        if (!this.type) {\n            const noEmpty = this.isStart() && this.isEnd();\n            const src = this.#parts\n                .map(p => {\n                const [re, _, hasMagic, uflag] = typeof p === 'string'\n                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n                    : p.toRegExpSource(allowDot);\n                this.#hasMagic = this.#hasMagic || hasMagic;\n                this.#uflag = this.#uflag || uflag;\n                return re;\n            })\n                .join('');\n            let start = '';\n            if (this.isStart()) {\n                if (typeof this.#parts[0] === 'string') {\n                    // this is the string that will match the start of the pattern,\n                    // so we need to protect against dots and such.\n                    // '.' and '..' cannot match unless the pattern is that exactly,\n                    // even if it starts with . or dot:true is set.\n                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);\n                    if (!dotTravAllowed) {\n                        const aps = addPatternStart;\n                        // check if we have a possibility of matching . or ..,\n                        // and prevent that.\n                        const needNoTrav = \n                        // dots are allowed, and the pattern starts with [ or .\n                        (dot && aps.has(src.charAt(0))) ||\n                            // the pattern starts with \\., and then [ or .\n                            (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n                            // the pattern starts with \\.\\., and then [ or .\n                            (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)));\n                        // no need to prevent dots if it can't match a dot, or if a\n                        // sub-pattern will be preventing it anyway.\n                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));\n                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';\n                    }\n                }\n            }\n            // append the \"end of path portion\" pattern to negation tails\n            let end = '';\n            if (this.isEnd() &&\n                this.#root.#filledNegs &&\n                this.#parent?.type === '!') {\n                end = '(?:$|\\\\/)';\n            }\n            const final = start + src + end;\n            return [\n                final,\n                (0, unescape_js_1.unescape)(src),\n                (this.#hasMagic = !!this.#hasMagic),\n                this.#uflag,\n            ];\n        }\n        // We need to calculate the body *twice* if it's a repeat pattern\n        // at the start, once in nodot mode, then again in dot mode, so a\n        // pattern like *(?) can match 'x.y'\n        const repeated = this.type === '*' || this.type === '+';\n        // some kind of extglob\n        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';\n        let body = this.#partsToRegExp(dot);\n        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n            // invalid extglob, has to at least be *something* present, if it's\n            // the entire path portion.\n            const s = this.toString();\n            this.#parts = [s];\n            this.type = null;\n            this.#hasMagic = undefined;\n            return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];\n        }\n        // XXX abstract out this map method\n        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot\n            ? ''\n            : this.#partsToRegExp(true);\n        if (bodyDotAllowed === body) {\n            bodyDotAllowed = '';\n        }\n        if (bodyDotAllowed) {\n            body = `(?:${body})(?:${bodyDotAllowed})*?`;\n        }\n        // an empty !() is exactly equivalent to a starNoEmpty\n        let final = '';\n        if (this.type === '!' && this.#emptyExt) {\n            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;\n        }\n        else {\n            const close = this.type === '!'\n                ? // !() must match something,but !(x) can match ''\n                    '))' +\n                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n                        star +\n                        ')'\n                : this.type === '@'\n                    ? ')'\n                    : this.type === '?'\n                        ? ')?'\n                        : this.type === '+' && bodyDotAllowed\n                            ? ')'\n                            : this.type === '*' && bodyDotAllowed\n                                ? `)?`\n                                : `)${this.type}`;\n            final = start + body + close;\n        }\n        return [\n            final,\n            (0, unescape_js_1.unescape)(body),\n            (this.#hasMagic = !!this.#hasMagic),\n            this.#uflag,\n        ];\n    }\n    #partsToRegExp(dot) {\n        return this.#parts\n            .map(p => {\n            // extglob ASTs should only contain parent ASTs\n            /* c8 ignore start */\n            if (typeof p === 'string') {\n                throw new Error('string type in extglob ast??');\n            }\n            /* c8 ignore stop */\n            // can ignore hasMagic, because extglobs are already always magic\n            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);\n            this.#uflag = this.#uflag || uflag;\n            return re;\n        })\n            .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n            .join('|');\n    }\n    static #parseGlob(glob, hasMagic, noEmpty = false) {\n        let escaping = false;\n        let re = '';\n        let uflag = false;\n        for (let i = 0; i < glob.length; i++) {\n            const c = glob.charAt(i);\n            if (escaping) {\n                escaping = false;\n                re += (reSpecials.has(c) ? '\\\\' : '') + c;\n                continue;\n            }\n            if (c === '\\\\') {\n                if (i === glob.length - 1) {\n                    re += '\\\\\\\\';\n                }\n                else {\n                    escaping = true;\n                }\n                continue;\n            }\n            if (c === '[') {\n                const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);\n                if (consumed) {\n                    re += src;\n                    uflag = uflag || needUflag;\n                    i += consumed - 1;\n                    hasMagic = hasMagic || magic;\n                    continue;\n                }\n            }\n            if (c === '*') {\n                if (noEmpty && glob === '*')\n                    re += starNoEmpty;\n                else\n                    re += star;\n                hasMagic = true;\n                continue;\n            }\n            if (c === '?') {\n                re += qmark;\n                hasMagic = true;\n                continue;\n            }\n            re += regExpEscape(c);\n        }\n        return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];\n    }\n}\nexports.AST = AST;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}