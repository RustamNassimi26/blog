{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\nconst npa = require('npm-package-arg');\nconst {\n  URL\n} = require('url');\n\n// Find the longest registry key that is used for some kind of auth\n// in the options.\nconst regKeyFromURI = (uri, opts) => {\n  const parsed = new URL(uri);\n  // try to find a config key indicating we have auth for this registry\n  // can be one of :_authToken, :_auth, :_password and :username, or\n  // :certfile and :keyfile\n  // We walk up the \"path\" until we're left with just //<host>[:<port>],\n  // stopping when we reach '//'.\n  let regKey = `//${parsed.host}${parsed.pathname}`;\n  while (regKey.length > '//'.length) {\n    // got some auth for this URI\n    if (hasAuth(regKey, opts)) {\n      return regKey;\n    }\n\n    // can be either //host/some/path/:_auth or //host/some/path:_auth\n    // walk up by removing EITHER what's after the slash OR the slash itself\n    regKey = regKey.replace(/([^/]+|\\/)$/, '');\n  }\n};\nconst hasAuth = (regKey, opts) => opts[`${regKey}:_authToken`] || opts[`${regKey}:_auth`] || opts[`${regKey}:username`] && opts[`${regKey}:_password`] || opts[`${regKey}:certfile`] && opts[`${regKey}:keyfile`];\nconst sameHost = (a, b) => {\n  const parsedA = new URL(a);\n  const parsedB = new URL(b);\n  return parsedA.host === parsedB.host;\n};\nconst getRegistry = opts => {\n  const {\n    spec\n  } = opts;\n  const {\n    scope: specScope,\n    subSpec\n  } = spec ? npa(spec) : {};\n  const subSpecScope = subSpec && subSpec.scope;\n  const scope = subSpec ? subSpecScope : specScope;\n  const scopeReg = scope && opts[`${scope}:registry`];\n  return scopeReg || opts.registry;\n};\nconst maybeReadFile = file => {\n  try {\n    return fs.readFileSync(file, 'utf8');\n  } catch (er) {\n    if (er.code !== 'ENOENT') {\n      throw er;\n    }\n    return null;\n  }\n};\nconst getAuth = (uri, opts = {}) => {\n  const {\n    forceAuth\n  } = opts;\n  if (!uri) {\n    throw new Error('URI is required');\n  }\n  const regKey = regKeyFromURI(uri, forceAuth || opts);\n\n  // we are only allowed to use what's in forceAuth if specified\n  if (forceAuth && !regKey) {\n    return new Auth({\n      scopeAuthKey: null,\n      token: forceAuth._authToken || forceAuth.token,\n      username: forceAuth.username,\n      password: forceAuth._password || forceAuth.password,\n      auth: forceAuth._auth || forceAuth.auth,\n      certfile: forceAuth.certfile,\n      keyfile: forceAuth.keyfile\n    });\n  }\n\n  // no auth for this URI, but might have it for the registry\n  if (!regKey) {\n    const registry = getRegistry(opts);\n    if (registry && uri !== registry && sameHost(uri, registry)) {\n      return getAuth(registry, opts);\n    } else if (registry !== opts.registry) {\n      // If making a tarball request to a different base URI than the\n      // registry where we logged in, but the same auth SHOULD be sent\n      // to that artifact host, then we track where it was coming in from,\n      // and warn the user if we get a 4xx error on it.\n      const scopeAuthKey = regKeyFromURI(registry, opts);\n      return new Auth({\n        scopeAuthKey\n      });\n    }\n  }\n  const {\n    [`${regKey}:_authToken`]: token,\n    [`${regKey}:username`]: username,\n    [`${regKey}:_password`]: password,\n    [`${regKey}:_auth`]: auth,\n    [`${regKey}:certfile`]: certfile,\n    [`${regKey}:keyfile`]: keyfile\n  } = opts;\n  return new Auth({\n    scopeAuthKey: null,\n    token,\n    auth,\n    username,\n    password,\n    certfile,\n    keyfile\n  });\n};\nclass Auth {\n  constructor({\n    token,\n    auth,\n    username,\n    password,\n    scopeAuthKey,\n    certfile,\n    keyfile\n  }) {\n    this.scopeAuthKey = scopeAuthKey;\n    this.token = null;\n    this.auth = null;\n    this.isBasicAuth = false;\n    this.cert = null;\n    this.key = null;\n    if (token) {\n      this.token = token;\n    } else if (auth) {\n      this.auth = auth;\n    } else if (username && password) {\n      const p = Buffer.from(password, 'base64').toString('utf8');\n      this.auth = Buffer.from(`${username}:${p}`, 'utf8').toString('base64');\n      this.isBasicAuth = true;\n    }\n    // mTLS may be used in conjunction with another auth method above\n    if (certfile && keyfile) {\n      const cert = maybeReadFile(certfile, 'utf-8');\n      const key = maybeReadFile(keyfile, 'utf-8');\n      if (cert && key) {\n        this.cert = cert;\n        this.key = key;\n      }\n    }\n  }\n}\nmodule.exports = getAuth;","map":{"version":3,"names":["fs","require","npa","URL","regKeyFromURI","uri","opts","parsed","regKey","host","pathname","length","hasAuth","replace","sameHost","a","b","parsedA","parsedB","getRegistry","spec","scope","specScope","subSpec","subSpecScope","scopeReg","registry","maybeReadFile","file","readFileSync","er","code","getAuth","forceAuth","Error","Auth","scopeAuthKey","token","_authToken","username","password","_password","auth","_auth","certfile","keyfile","constructor","isBasicAuth","cert","key","p","Buffer","from","toString","module","exports"],"sources":["I:/Angular/angular-blog/node_modules/npm-registry-fetch/lib/auth.js"],"sourcesContent":["'use strict'\nconst fs = require('fs')\nconst npa = require('npm-package-arg')\nconst { URL } = require('url')\n\n// Find the longest registry key that is used for some kind of auth\n// in the options.\nconst regKeyFromURI = (uri, opts) => {\n  const parsed = new URL(uri)\n  // try to find a config key indicating we have auth for this registry\n  // can be one of :_authToken, :_auth, :_password and :username, or\n  // :certfile and :keyfile\n  // We walk up the \"path\" until we're left with just //<host>[:<port>],\n  // stopping when we reach '//'.\n  let regKey = `//${parsed.host}${parsed.pathname}`\n  while (regKey.length > '//'.length) {\n    // got some auth for this URI\n    if (hasAuth(regKey, opts)) {\n      return regKey\n    }\n\n    // can be either //host/some/path/:_auth or //host/some/path:_auth\n    // walk up by removing EITHER what's after the slash OR the slash itself\n    regKey = regKey.replace(/([^/]+|\\/)$/, '')\n  }\n}\n\nconst hasAuth = (regKey, opts) => (\n  opts[`${regKey}:_authToken`] ||\n  opts[`${regKey}:_auth`] ||\n  opts[`${regKey}:username`] && opts[`${regKey}:_password`] ||\n  opts[`${regKey}:certfile`] && opts[`${regKey}:keyfile`]\n)\n\nconst sameHost = (a, b) => {\n  const parsedA = new URL(a)\n  const parsedB = new URL(b)\n  return parsedA.host === parsedB.host\n}\n\nconst getRegistry = opts => {\n  const { spec } = opts\n  const { scope: specScope, subSpec } = spec ? npa(spec) : {}\n  const subSpecScope = subSpec && subSpec.scope\n  const scope = subSpec ? subSpecScope : specScope\n  const scopeReg = scope && opts[`${scope}:registry`]\n  return scopeReg || opts.registry\n}\n\nconst maybeReadFile = file => {\n  try {\n    return fs.readFileSync(file, 'utf8')\n  } catch (er) {\n    if (er.code !== 'ENOENT') {\n      throw er\n    }\n    return null\n  }\n}\n\nconst getAuth = (uri, opts = {}) => {\n  const { forceAuth } = opts\n  if (!uri) {\n    throw new Error('URI is required')\n  }\n  const regKey = regKeyFromURI(uri, forceAuth || opts)\n\n  // we are only allowed to use what's in forceAuth if specified\n  if (forceAuth && !regKey) {\n    return new Auth({\n      scopeAuthKey: null,\n      token: forceAuth._authToken || forceAuth.token,\n      username: forceAuth.username,\n      password: forceAuth._password || forceAuth.password,\n      auth: forceAuth._auth || forceAuth.auth,\n      certfile: forceAuth.certfile,\n      keyfile: forceAuth.keyfile,\n    })\n  }\n\n  // no auth for this URI, but might have it for the registry\n  if (!regKey) {\n    const registry = getRegistry(opts)\n    if (registry && uri !== registry && sameHost(uri, registry)) {\n      return getAuth(registry, opts)\n    } else if (registry !== opts.registry) {\n      // If making a tarball request to a different base URI than the\n      // registry where we logged in, but the same auth SHOULD be sent\n      // to that artifact host, then we track where it was coming in from,\n      // and warn the user if we get a 4xx error on it.\n      const scopeAuthKey = regKeyFromURI(registry, opts)\n      return new Auth({ scopeAuthKey })\n    }\n  }\n\n  const {\n    [`${regKey}:_authToken`]: token,\n    [`${regKey}:username`]: username,\n    [`${regKey}:_password`]: password,\n    [`${regKey}:_auth`]: auth,\n    [`${regKey}:certfile`]: certfile,\n    [`${regKey}:keyfile`]: keyfile,\n  } = opts\n\n  return new Auth({\n    scopeAuthKey: null,\n    token,\n    auth,\n    username,\n    password,\n    certfile,\n    keyfile,\n  })\n}\n\nclass Auth {\n  constructor ({ token, auth, username, password, scopeAuthKey, certfile, keyfile }) {\n    this.scopeAuthKey = scopeAuthKey\n    this.token = null\n    this.auth = null\n    this.isBasicAuth = false\n    this.cert = null\n    this.key = null\n    if (token) {\n      this.token = token\n    } else if (auth) {\n      this.auth = auth\n    } else if (username && password) {\n      const p = Buffer.from(password, 'base64').toString('utf8')\n      this.auth = Buffer.from(`${username}:${p}`, 'utf8').toString('base64')\n      this.isBasicAuth = true\n    }\n    // mTLS may be used in conjunction with another auth method above\n    if (certfile && keyfile) {\n      const cert = maybeReadFile(certfile, 'utf-8')\n      const key = maybeReadFile(keyfile, 'utf-8')\n      if (cert && key) {\n        this.cert = cert\n        this.key = key\n      }\n    }\n  }\n}\n\nmodule.exports = getAuth\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}