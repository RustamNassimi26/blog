{"ast":null,"code":"var _asyncToGenerator = require(\"I:/Angular/angular-blog/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n// The goal here is to minimize both git workload and\n// the number of refs we download over the network.\n//\n// Every method ends up with the checked out working dir\n// at the specified ref, and resolves with the git sha.\n\n// Only certain whitelisted hosts get shallow cloning.\n// Many hosts (including GHE) don't always support it.\n// A failed shallow fetch takes a LOT longer than a full\n// fetch in most cases, so we skip it entirely.\n// Set opts.gitShallow = true/false to force this behavior\n// one way or the other.\nconst shallowHosts = new Set(['github.com', 'gist.github.com', 'gitlab.com', 'bitbucket.com', 'bitbucket.org']);\n// we have to use url.parse until we add the same shim that hosted-git-info has\n// to handle scp:// urls\nconst {\n  parse\n} = require('url'); // eslint-disable-line node/no-deprecated-api\nconst path = require('path');\nconst getRevs = require('./revs.js');\nconst spawn = require('./spawn.js');\nconst {\n  isWindows\n} = require('./utils.js');\nconst pickManifest = require('npm-pick-manifest');\nconst fs = require('fs/promises');\nmodule.exports = (repo, ref = 'HEAD', target = null, opts = {}) => getRevs(repo, opts).then(revs => clone(repo, revs, ref, resolveRef(revs, ref, opts), target || defaultTarget(repo, opts.cwd), opts));\nconst maybeShallow = (repo, opts) => {\n  if (opts.gitShallow === false || opts.gitShallow) {\n    return opts.gitShallow;\n  }\n  return shallowHosts.has(parse(repo).host);\n};\nconst defaultTarget = (repo, /* istanbul ignore next */cwd = process.cwd()) => path.resolve(cwd, path.basename(repo.replace(/[/\\\\]?\\.git$/, '')));\nconst clone = (repo, revs, ref, revDoc, target, opts) => {\n  if (!revDoc) {\n    return unresolved(repo, ref, target, opts);\n  }\n  if (revDoc.sha === revs.refs.HEAD.sha) {\n    return plain(repo, revDoc, target, opts);\n  }\n  if (revDoc.type === 'tag' || revDoc.type === 'branch') {\n    return branch(repo, revDoc, target, opts);\n  }\n  return other(repo, revDoc, target, opts);\n};\nconst resolveRef = (revs, ref, opts) => {\n  const {\n    spec = {}\n  } = opts;\n  ref = spec.gitCommittish || ref;\n  /* istanbul ignore next - will fail anyway, can't pull */\n  if (!revs) {\n    return null;\n  }\n  if (spec.gitRange) {\n    return pickManifest(revs, spec.gitRange, opts);\n  }\n  if (!ref) {\n    return revs.refs.HEAD;\n  }\n  if (revs.refs[ref]) {\n    return revs.refs[ref];\n  }\n  if (revs.shas[ref]) {\n    return revs.refs[revs.shas[ref][0]];\n  }\n  return null;\n};\n\n// pull request or some other kind of advertised ref\nconst other = (repo, revDoc, target, opts) => {\n  const shallow = maybeShallow(repo, opts);\n  const fetchOrigin = ['fetch', 'origin', revDoc.rawRef].concat(shallow ? ['--depth=1'] : []);\n  const git = args => spawn(args, {\n    ...opts,\n    cwd: target\n  });\n  return fs.mkdir(target, {\n    recursive: true\n  }).then(() => git(['init'])).then(() => isWindows(opts) ? git(['config', '--local', '--add', 'core.longpaths', 'true']) : null).then(() => git(['remote', 'add', 'origin', repo])).then(() => git(fetchOrigin)).then(() => git(['checkout', revDoc.sha])).then(() => updateSubmodules(target, opts)).then(() => revDoc.sha);\n};\n\n// tag or branches.  use -b\nconst branch = (repo, revDoc, target, opts) => {\n  const args = ['clone', '-b', revDoc.ref, repo, target, '--recurse-submodules'];\n  if (maybeShallow(repo, opts)) {\n    args.push('--depth=1');\n  }\n  if (isWindows(opts)) {\n    args.push('--config', 'core.longpaths=true');\n  }\n  return spawn(args, opts).then(() => revDoc.sha);\n};\n\n// just the head.  clone it\nconst plain = (repo, revDoc, target, opts) => {\n  const args = ['clone', repo, target, '--recurse-submodules'];\n  if (maybeShallow(repo, opts)) {\n    args.push('--depth=1');\n  }\n  if (isWindows(opts)) {\n    args.push('--config', 'core.longpaths=true');\n  }\n  return spawn(args, opts).then(() => revDoc.sha);\n};\nconst updateSubmodules = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (target, opts) {\n    const hasSubmodules = yield fs.stat(`${target}/.gitmodules`).then(() => true).catch(() => false);\n    if (!hasSubmodules) {\n      return null;\n    }\n    return spawn(['submodule', 'update', '-q', '--init', '--recursive'], {\n      ...opts,\n      cwd: target\n    });\n  });\n  return function updateSubmodules(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\nconst unresolved = (repo, ref, target, opts) => {\n  // can't do this one shallowly, because the ref isn't advertised\n  // but we can avoid checking out the working dir twice, at least\n  const lp = isWindows(opts) ? ['--config', 'core.longpaths=true'] : [];\n  const cloneArgs = ['clone', '--mirror', '-q', repo, target + '/.git'];\n  const git = args => spawn(args, {\n    ...opts,\n    cwd: target\n  });\n  return fs.mkdir(target, {\n    recursive: true\n  }).then(() => git(cloneArgs.concat(lp))).then(() => git(['init'])).then(() => git(['checkout', ref])).then(() => updateSubmodules(target, opts)).then(() => git(['rev-parse', '--revs-only', 'HEAD'])).then(({\n    stdout\n  }) => stdout.trim());\n};","map":{"version":3,"names":["shallowHosts","Set","parse","require","path","getRevs","spawn","isWindows","pickManifest","fs","module","exports","repo","ref","target","opts","then","revs","clone","resolveRef","defaultTarget","cwd","maybeShallow","gitShallow","has","host","process","resolve","basename","replace","revDoc","unresolved","sha","refs","HEAD","plain","type","branch","other","spec","gitCommittish","gitRange","shas","shallow","fetchOrigin","rawRef","concat","git","args","mkdir","recursive","updateSubmodules","push","hasSubmodules","stat","catch","lp","cloneArgs","stdout","trim"],"sources":["I:/Angular/angular-blog/node_modules/@npmcli/git/lib/clone.js"],"sourcesContent":["// The goal here is to minimize both git workload and\n// the number of refs we download over the network.\n//\n// Every method ends up with the checked out working dir\n// at the specified ref, and resolves with the git sha.\n\n// Only certain whitelisted hosts get shallow cloning.\n// Many hosts (including GHE) don't always support it.\n// A failed shallow fetch takes a LOT longer than a full\n// fetch in most cases, so we skip it entirely.\n// Set opts.gitShallow = true/false to force this behavior\n// one way or the other.\nconst shallowHosts = new Set([\n  'github.com',\n  'gist.github.com',\n  'gitlab.com',\n  'bitbucket.com',\n  'bitbucket.org',\n])\n// we have to use url.parse until we add the same shim that hosted-git-info has\n// to handle scp:// urls\nconst { parse } = require('url') // eslint-disable-line node/no-deprecated-api\nconst path = require('path')\n\nconst getRevs = require('./revs.js')\nconst spawn = require('./spawn.js')\nconst { isWindows } = require('./utils.js')\n\nconst pickManifest = require('npm-pick-manifest')\nconst fs = require('fs/promises')\n\nmodule.exports = (repo, ref = 'HEAD', target = null, opts = {}) =>\n  getRevs(repo, opts).then(revs => clone(\n    repo,\n    revs,\n    ref,\n    resolveRef(revs, ref, opts),\n    target || defaultTarget(repo, opts.cwd),\n    opts\n  ))\n\nconst maybeShallow = (repo, opts) => {\n  if (opts.gitShallow === false || opts.gitShallow) {\n    return opts.gitShallow\n  }\n  return shallowHosts.has(parse(repo).host)\n}\n\nconst defaultTarget = (repo, /* istanbul ignore next */ cwd = process.cwd()) =>\n  path.resolve(cwd, path.basename(repo.replace(/[/\\\\]?\\.git$/, '')))\n\nconst clone = (repo, revs, ref, revDoc, target, opts) => {\n  if (!revDoc) {\n    return unresolved(repo, ref, target, opts)\n  }\n  if (revDoc.sha === revs.refs.HEAD.sha) {\n    return plain(repo, revDoc, target, opts)\n  }\n  if (revDoc.type === 'tag' || revDoc.type === 'branch') {\n    return branch(repo, revDoc, target, opts)\n  }\n  return other(repo, revDoc, target, opts)\n}\n\nconst resolveRef = (revs, ref, opts) => {\n  const { spec = {} } = opts\n  ref = spec.gitCommittish || ref\n  /* istanbul ignore next - will fail anyway, can't pull */\n  if (!revs) {\n    return null\n  }\n  if (spec.gitRange) {\n    return pickManifest(revs, spec.gitRange, opts)\n  }\n  if (!ref) {\n    return revs.refs.HEAD\n  }\n  if (revs.refs[ref]) {\n    return revs.refs[ref]\n  }\n  if (revs.shas[ref]) {\n    return revs.refs[revs.shas[ref][0]]\n  }\n  return null\n}\n\n// pull request or some other kind of advertised ref\nconst other = (repo, revDoc, target, opts) => {\n  const shallow = maybeShallow(repo, opts)\n\n  const fetchOrigin = ['fetch', 'origin', revDoc.rawRef]\n    .concat(shallow ? ['--depth=1'] : [])\n\n  const git = (args) => spawn(args, { ...opts, cwd: target })\n  return fs.mkdir(target, { recursive: true })\n    .then(() => git(['init']))\n    .then(() => isWindows(opts)\n      ? git(['config', '--local', '--add', 'core.longpaths', 'true'])\n      : null)\n    .then(() => git(['remote', 'add', 'origin', repo]))\n    .then(() => git(fetchOrigin))\n    .then(() => git(['checkout', revDoc.sha]))\n    .then(() => updateSubmodules(target, opts))\n    .then(() => revDoc.sha)\n}\n\n// tag or branches.  use -b\nconst branch = (repo, revDoc, target, opts) => {\n  const args = [\n    'clone',\n    '-b',\n    revDoc.ref,\n    repo,\n    target,\n    '--recurse-submodules',\n  ]\n  if (maybeShallow(repo, opts)) {\n    args.push('--depth=1')\n  }\n  if (isWindows(opts)) {\n    args.push('--config', 'core.longpaths=true')\n  }\n  return spawn(args, opts).then(() => revDoc.sha)\n}\n\n// just the head.  clone it\nconst plain = (repo, revDoc, target, opts) => {\n  const args = [\n    'clone',\n    repo,\n    target,\n    '--recurse-submodules',\n  ]\n  if (maybeShallow(repo, opts)) {\n    args.push('--depth=1')\n  }\n  if (isWindows(opts)) {\n    args.push('--config', 'core.longpaths=true')\n  }\n  return spawn(args, opts).then(() => revDoc.sha)\n}\n\nconst updateSubmodules = async (target, opts) => {\n  const hasSubmodules = await fs.stat(`${target}/.gitmodules`)\n    .then(() => true)\n    .catch(() => false)\n  if (!hasSubmodules) {\n    return null\n  }\n  return spawn([\n    'submodule',\n    'update',\n    '-q',\n    '--init',\n    '--recursive',\n  ], { ...opts, cwd: target })\n}\n\nconst unresolved = (repo, ref, target, opts) => {\n  // can't do this one shallowly, because the ref isn't advertised\n  // but we can avoid checking out the working dir twice, at least\n  const lp = isWindows(opts) ? ['--config', 'core.longpaths=true'] : []\n  const cloneArgs = ['clone', '--mirror', '-q', repo, target + '/.git']\n  const git = (args) => spawn(args, { ...opts, cwd: target })\n  return fs.mkdir(target, { recursive: true })\n    .then(() => git(cloneArgs.concat(lp)))\n    .then(() => git(['init']))\n    .then(() => git(['checkout', ref]))\n    .then(() => updateSubmodules(target, opts))\n    .then(() => git(['rev-parse', '--revs-only', 'HEAD']))\n    .then(({ stdout }) => stdout.trim())\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}