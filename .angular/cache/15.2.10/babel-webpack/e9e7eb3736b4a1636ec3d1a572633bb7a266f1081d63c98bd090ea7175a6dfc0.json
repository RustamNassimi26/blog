{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"I:/Angular/angular-blog/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Minipass = exports.isWritable = exports.isReadable = exports.isStream = void 0;\nconst proc = typeof process === 'object' && process ? process : {\n  stdout: null,\n  stderr: null\n};\nconst events_1 = require(\"events\");\nconst stream_1 = __importDefault(require(\"stream\"));\nconst string_decoder_1 = require(\"string_decoder\");\n/**\n * Return true if the argument is a Minipass stream, Node stream, or something\n * else that Minipass can interact with.\n */\nconst isStream = s => !!s && typeof s === 'object' && (s instanceof Minipass || s instanceof stream_1.default || (0, exports.isReadable)(s) || (0, exports.isWritable)(s));\nexports.isStream = isStream;\n/**\n * Return true if the argument is a valid {@link Minipass.Readable}\n */\nconst isReadable = s => !!s && typeof s === 'object' && s instanceof events_1.EventEmitter && typeof s.pipe === 'function' &&\n// node core Writable streams have a pipe() method, but it throws\ns.pipe !== stream_1.default.Writable.prototype.pipe;\nexports.isReadable = isReadable;\n/**\n * Return true if the argument is a valid {@link Minipass.Writable}\n */\nconst isWritable = s => !!s && typeof s === 'object' && s instanceof events_1.EventEmitter && typeof s.write === 'function' && typeof s.end === 'function';\nexports.isWritable = isWritable;\nconst EOF = Symbol('EOF');\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd');\nconst EMITTED_END = Symbol('emittedEnd');\nconst EMITTING_END = Symbol('emittingEnd');\nconst EMITTED_ERROR = Symbol('emittedError');\nconst CLOSED = Symbol('closed');\nconst READ = Symbol('read');\nconst FLUSH = Symbol('flush');\nconst FLUSHCHUNK = Symbol('flushChunk');\nconst ENCODING = Symbol('encoding');\nconst DECODER = Symbol('decoder');\nconst FLOWING = Symbol('flowing');\nconst PAUSED = Symbol('paused');\nconst RESUME = Symbol('resume');\nconst BUFFER = Symbol('buffer');\nconst PIPES = Symbol('pipes');\nconst BUFFERLENGTH = Symbol('bufferLength');\nconst BUFFERPUSH = Symbol('bufferPush');\nconst BUFFERSHIFT = Symbol('bufferShift');\nconst OBJECTMODE = Symbol('objectMode');\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed');\n// internal event when stream has an error\nconst ERROR = Symbol('error');\nconst EMITDATA = Symbol('emitData');\nconst EMITEND = Symbol('emitEnd');\nconst EMITEND2 = Symbol('emitEnd2');\nconst ASYNC = Symbol('async');\nconst ABORT = Symbol('abort');\nconst ABORTED = Symbol('aborted');\nconst SIGNAL = Symbol('signal');\nconst DATALISTENERS = Symbol('dataListeners');\nconst DISCARDED = Symbol('discarded');\nconst defer = fn => Promise.resolve().then(fn);\nconst nodefer = fn => fn();\nconst isEndish = ev => ev === 'end' || ev === 'finish' || ev === 'prefinish';\nconst isArrayBufferLike = b => b instanceof ArrayBuffer || !!b && typeof b === 'object' && b.constructor && b.constructor.name === 'ArrayBuffer' && b.byteLength >= 0;\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);\n/**\n * Internal class representing a pipe to a destination stream.\n *\n * @internal\n */\nclass Pipe {\n  src;\n  dest;\n  opts;\n  ondrain;\n  constructor(src, dest, opts) {\n    this.src = src;\n    this.dest = dest;\n    this.opts = opts;\n    this.ondrain = () => src[RESUME]();\n    this.dest.on('drain', this.ondrain);\n  }\n  unpipe() {\n    this.dest.removeListener('drain', this.ondrain);\n  }\n  // only here for the prototype\n  /* c8 ignore start */\n  proxyErrors(_er) {}\n  /* c8 ignore stop */\n  end() {\n    this.unpipe();\n    if (this.opts.end) this.dest.end();\n  }\n}\n/**\n * Internal class representing a pipe to a destination stream where\n * errors are proxied.\n *\n * @internal\n */\nclass PipeProxyErrors extends Pipe {\n  unpipe() {\n    this.src.removeListener('error', this.proxyErrors);\n    super.unpipe();\n  }\n  constructor(src, dest, opts) {\n    super(src, dest, opts);\n    this.proxyErrors = er => dest.emit('error', er);\n    src.on('error', this.proxyErrors);\n  }\n}\nconst isObjectModeOptions = o => !!o.objectMode;\nconst isEncodingOptions = o => !o.objectMode && !!o.encoding && o.encoding !== 'buffer';\n/**\n * Main export, the Minipass class\n *\n * `RType` is the type of data emitted, defaults to Buffer\n *\n * `WType` is the type of data to be written, if RType is buffer or string,\n * then any {@link Minipass.ContiguousData} is allowed.\n *\n * `Events` is the set of event handler signatures that this object\n * will emit, see {@link Minipass.Events}\n */\nclass Minipass extends events_1.EventEmitter {\n  [FLOWING] = false;\n  [PAUSED] = false;\n  [PIPES] = [];\n  [BUFFER] = [];\n  [OBJECTMODE];\n  [ENCODING];\n  [ASYNC];\n  [DECODER];\n  [EOF] = false;\n  [EMITTED_END] = false;\n  [EMITTING_END] = false;\n  [CLOSED] = false;\n  [EMITTED_ERROR] = null;\n  [BUFFERLENGTH] = 0;\n  [DESTROYED] = false;\n  [SIGNAL];\n  [ABORTED] = false;\n  [DATALISTENERS] = 0;\n  [DISCARDED] = false;\n  /**\n   * true if the stream can be written\n   */\n  writable = true;\n  /**\n   * true if the stream can be read\n   */\n  readable = true;\n  /**\n   * If `RType` is Buffer, then options do not need to be provided.\n   * Otherwise, an options object must be provided to specify either\n   * {@link Minipass.SharedOptions.objectMode} or\n   * {@link Minipass.SharedOptions.encoding}, as appropriate.\n   */\n  constructor(...args) {\n    const options = args[0] || {};\n    super();\n    if (options.objectMode && typeof options.encoding === 'string') {\n      throw new TypeError('Encoding and objectMode may not be used together');\n    }\n    if (isObjectModeOptions(options)) {\n      this[OBJECTMODE] = true;\n      this[ENCODING] = null;\n    } else if (isEncodingOptions(options)) {\n      this[ENCODING] = options.encoding;\n      this[OBJECTMODE] = false;\n    } else {\n      this[OBJECTMODE] = false;\n      this[ENCODING] = null;\n    }\n    this[ASYNC] = !!options.async;\n    this[DECODER] = this[ENCODING] ? new string_decoder_1.StringDecoder(this[ENCODING]) : null;\n    //@ts-ignore - private option for debugging and testing\n    if (options && options.debugExposeBuffer === true) {\n      Object.defineProperty(this, 'buffer', {\n        get: () => this[BUFFER]\n      });\n    }\n    //@ts-ignore - private option for debugging and testing\n    if (options && options.debugExposePipes === true) {\n      Object.defineProperty(this, 'pipes', {\n        get: () => this[PIPES]\n      });\n    }\n    const {\n      signal\n    } = options;\n    if (signal) {\n      this[SIGNAL] = signal;\n      if (signal.aborted) {\n        this[ABORT]();\n      } else {\n        signal.addEventListener('abort', () => this[ABORT]());\n      }\n    }\n  }\n  /**\n   * The amount of data stored in the buffer waiting to be read.\n   *\n   * For Buffer strings, this will be the total byte length.\n   * For string encoding streams, this will be the string character length,\n   * according to JavaScript's `string.length` logic.\n   * For objectMode streams, this is a count of the items waiting to be\n   * emitted.\n   */\n  get bufferLength() {\n    return this[BUFFERLENGTH];\n  }\n  /**\n   * The `BufferEncoding` currently in use, or `null`\n   */\n  get encoding() {\n    return this[ENCODING];\n  }\n  /**\n   * @deprecated - This is a read only property\n   */\n  set encoding(_enc) {\n    throw new Error('Encoding must be set at instantiation time');\n  }\n  /**\n   * @deprecated - Encoding may only be set at instantiation time\n   */\n  setEncoding(_enc) {\n    throw new Error('Encoding must be set at instantiation time');\n  }\n  /**\n   * True if this is an objectMode stream\n   */\n  get objectMode() {\n    return this[OBJECTMODE];\n  }\n  /**\n   * @deprecated - This is a read-only property\n   */\n  set objectMode(_om) {\n    throw new Error('objectMode must be set at instantiation time');\n  }\n  /**\n   * true if this is an async stream\n   */\n  get ['async']() {\n    return this[ASYNC];\n  }\n  /**\n   * Set to true to make this stream async.\n   *\n   * Once set, it cannot be unset, as this would potentially cause incorrect\n   * behavior.  Ie, a sync stream can be made async, but an async stream\n   * cannot be safely made sync.\n   */\n  set ['async'](a) {\n    this[ASYNC] = this[ASYNC] || !!a;\n  }\n  // drop everything and get out of the flow completely\n  [ABORT]() {\n    this[ABORTED] = true;\n    this.emit('abort', this[SIGNAL]?.reason);\n    this.destroy(this[SIGNAL]?.reason);\n  }\n  /**\n   * True if the stream has been aborted.\n   */\n  get aborted() {\n    return this[ABORTED];\n  }\n  /**\n   * No-op setter. Stream aborted status is set via the AbortSignal provided\n   * in the constructor options.\n   */\n  set aborted(_) {}\n  write(chunk, encoding, cb) {\n    if (this[ABORTED]) return false;\n    if (this[EOF]) throw new Error('write after end');\n    if (this[DESTROYED]) {\n      this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), {\n        code: 'ERR_STREAM_DESTROYED'\n      }));\n      return true;\n    }\n    if (typeof encoding === 'function') {\n      cb = encoding;\n      encoding = 'utf8';\n    }\n    if (!encoding) encoding = 'utf8';\n    const fn = this[ASYNC] ? defer : nodefer;\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything is only allowed if in object mode, so throw\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk)) {\n        //@ts-ignore - sinful unsafe type changing\n        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n      } else if (isArrayBufferLike(chunk)) {\n        //@ts-ignore - sinful unsafe type changing\n        chunk = Buffer.from(chunk);\n      } else if (typeof chunk !== 'string') {\n        throw new Error('Non-contiguous data written to non-objectMode stream');\n      }\n    }\n    // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n    if (this[OBJECTMODE]) {\n      // maybe impossible?\n      /* c8 ignore start */\n      if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true);\n      /* c8 ignore stop */\n      if (this[FLOWING]) this.emit('data', chunk);else this[BUFFERPUSH](chunk);\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n      if (cb) fn(cb);\n      return this[FLOWING];\n    }\n    // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!chunk.length) {\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n      if (cb) fn(cb);\n      return this[FLOWING];\n    }\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (typeof chunk === 'string' &&\n    // unless it is a string already ready for us to use\n    !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {\n      //@ts-ignore - sinful unsafe type change\n      chunk = Buffer.from(chunk, encoding);\n    }\n    if (Buffer.isBuffer(chunk) && this[ENCODING]) {\n      //@ts-ignore - sinful unsafe type change\n      chunk = this[DECODER].write(chunk);\n    }\n    // Note: flushing CAN potentially switch us into not-flowing mode\n    if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true);\n    if (this[FLOWING]) this.emit('data', chunk);else this[BUFFERPUSH](chunk);\n    if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n    if (cb) fn(cb);\n    return this[FLOWING];\n  }\n  /**\n   * Low-level explicit read method.\n   *\n   * In objectMode, the argument is ignored, and one item is returned if\n   * available.\n   *\n   * `n` is the number of bytes (or in the case of encoding streams,\n   * characters) to consume. If `n` is not provided, then the entire buffer\n   * is returned, or `null` is returned if no data is available.\n   *\n   * If `n` is greater that the amount of data in the internal buffer,\n   * then `null` is returned.\n   */\n  read(n) {\n    if (this[DESTROYED]) return null;\n    this[DISCARDED] = false;\n    if (this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH]) {\n      this[MAYBE_EMIT_END]();\n      return null;\n    }\n    if (this[OBJECTMODE]) n = null;\n    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n      // not object mode, so if we have an encoding, then RType is string\n      // otherwise, must be Buffer\n      this[BUFFER] = [this[ENCODING] ? this[BUFFER].join('') : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])];\n    }\n    const ret = this[READ](n || null, this[BUFFER][0]);\n    this[MAYBE_EMIT_END]();\n    return ret;\n  }\n  [READ](n, chunk) {\n    if (this[OBJECTMODE]) this[BUFFERSHIFT]();else {\n      const c = chunk;\n      if (n === c.length || n === null) this[BUFFERSHIFT]();else if (typeof c === 'string') {\n        this[BUFFER][0] = c.slice(n);\n        chunk = c.slice(0, n);\n        this[BUFFERLENGTH] -= n;\n      } else {\n        this[BUFFER][0] = c.subarray(n);\n        chunk = c.subarray(0, n);\n        this[BUFFERLENGTH] -= n;\n      }\n    }\n    this.emit('data', chunk);\n    if (!this[BUFFER].length && !this[EOF]) this.emit('drain');\n    return chunk;\n  }\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') {\n      cb = chunk;\n      chunk = undefined;\n    }\n    if (typeof encoding === 'function') {\n      cb = encoding;\n      encoding = 'utf8';\n    }\n    if (chunk !== undefined) this.write(chunk, encoding);\n    if (cb) this.once('end', cb);\n    this[EOF] = true;\n    this.writable = false;\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this[FLOWING] || !this[PAUSED]) this[MAYBE_EMIT_END]();\n    return this;\n  }\n  // don't let the internal resume be overwritten\n  [RESUME]() {\n    if (this[DESTROYED]) return;\n    if (!this[DATALISTENERS] && !this[PIPES].length) {\n      this[DISCARDED] = true;\n    }\n    this[PAUSED] = false;\n    this[FLOWING] = true;\n    this.emit('resume');\n    if (this[BUFFER].length) this[FLUSH]();else if (this[EOF]) this[MAYBE_EMIT_END]();else this.emit('drain');\n  }\n  /**\n   * Resume the stream if it is currently in a paused state\n   *\n   * If called when there are no pipe destinations or `data` event listeners,\n   * this will place the stream in a \"discarded\" state, where all data will\n   * be thrown away. The discarded state is removed if a pipe destination or\n   * data handler is added, if pause() is called, or if any synchronous or\n   * asynchronous iteration is started.\n   */\n  resume() {\n    return this[RESUME]();\n  }\n  /**\n   * Pause the stream\n   */\n  pause() {\n    this[FLOWING] = false;\n    this[PAUSED] = true;\n    this[DISCARDED] = false;\n  }\n  /**\n   * true if the stream has been forcibly destroyed\n   */\n  get destroyed() {\n    return this[DESTROYED];\n  }\n  /**\n   * true if the stream is currently in a flowing state, meaning that\n   * any writes will be immediately emitted.\n   */\n  get flowing() {\n    return this[FLOWING];\n  }\n  /**\n   * true if the stream is currently in a paused state\n   */\n  get paused() {\n    return this[PAUSED];\n  }\n  [BUFFERPUSH](chunk) {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;else this[BUFFERLENGTH] += chunk.length;\n    this[BUFFER].push(chunk);\n  }\n  [BUFFERSHIFT]() {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;else this[BUFFERLENGTH] -= this[BUFFER][0].length;\n    return this[BUFFER].shift();\n  }\n  [FLUSH](noDrain = false) {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);\n    if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit('drain');\n  }\n  [FLUSHCHUNK](chunk) {\n    this.emit('data', chunk);\n    return this[FLOWING];\n  }\n  /**\n   * Pipe all data emitted by this stream into the destination provided.\n   *\n   * Triggers the flow of data.\n   */\n  pipe(dest, opts) {\n    if (this[DESTROYED]) return dest;\n    this[DISCARDED] = false;\n    const ended = this[EMITTED_END];\n    opts = opts || {};\n    if (dest === proc.stdout || dest === proc.stderr) opts.end = false;else opts.end = opts.end !== false;\n    opts.proxyErrors = !!opts.proxyErrors;\n    // piping an ended stream ends immediately\n    if (ended) {\n      if (opts.end) dest.end();\n    } else {\n      // \"as\" here just ignores the WType, which pipes don't care about,\n      // since they're only consuming from us, and writing to the dest\n      this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));\n      if (this[ASYNC]) defer(() => this[RESUME]());else this[RESUME]();\n    }\n    return dest;\n  }\n  /**\n   * Fully unhook a piped destination stream.\n   *\n   * If the destination stream was the only consumer of this stream (ie,\n   * there are no other piped destinations or `'data'` event listeners)\n   * then the flow of data will stop until there is another consumer or\n   * {@link Minipass#resume} is explicitly called.\n   */\n  unpipe(dest) {\n    const p = this[PIPES].find(p => p.dest === dest);\n    if (p) {\n      if (this[PIPES].length === 1) {\n        if (this[FLOWING] && this[DATALISTENERS] === 0) {\n          this[FLOWING] = false;\n        }\n        this[PIPES] = [];\n      } else this[PIPES].splice(this[PIPES].indexOf(p), 1);\n      p.unpipe();\n    }\n  }\n  /**\n   * Alias for {@link Minipass#on}\n   */\n  addListener(ev, handler) {\n    return this.on(ev, handler);\n  }\n  /**\n   * Mostly identical to `EventEmitter.on`, with the following\n   * behavior differences to prevent data loss and unnecessary hangs:\n   *\n   * - Adding a 'data' event handler will trigger the flow of data\n   *\n   * - Adding a 'readable' event handler when there is data waiting to be read\n   *   will cause 'readable' to be emitted immediately.\n   *\n   * - Adding an 'endish' event handler ('end', 'finish', etc.) which has\n   *   already passed will cause the event to be emitted immediately and all\n   *   handlers removed.\n   *\n   * - Adding an 'error' event handler after an error has been emitted will\n   *   cause the event to be re-emitted immediately with the error previously\n   *   raised.\n   */\n  on(ev, handler) {\n    const ret = super.on(ev, handler);\n    if (ev === 'data') {\n      this[DISCARDED] = false;\n      this[DATALISTENERS]++;\n      if (!this[PIPES].length && !this[FLOWING]) {\n        this[RESUME]();\n      }\n    } else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {\n      super.emit('readable');\n    } else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev);\n      this.removeAllListeners(ev);\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      const h = handler;\n      if (this[ASYNC]) defer(() => h.call(this, this[EMITTED_ERROR]));else h.call(this, this[EMITTED_ERROR]);\n    }\n    return ret;\n  }\n  /**\n   * Alias for {@link Minipass#off}\n   */\n  removeListener(ev, handler) {\n    return this.off(ev, handler);\n  }\n  /**\n   * Mostly identical to `EventEmitter.off`\n   *\n   * If a 'data' event handler is removed, and it was the last consumer\n   * (ie, there are no pipe destinations or other 'data' event listeners),\n   * then the flow of data will stop until there is another consumer or\n   * {@link Minipass#resume} is explicitly called.\n   */\n  off(ev, handler) {\n    const ret = super.off(ev, handler);\n    // if we previously had listeners, and now we don't, and we don't\n    // have any pipes, then stop the flow, unless it's been explicitly\n    // put in a discarded flowing state via stream.resume().\n    if (ev === 'data') {\n      this[DATALISTENERS] = this.listeners('data').length;\n      if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) {\n        this[FLOWING] = false;\n      }\n    }\n    return ret;\n  }\n  /**\n   * Mostly identical to `EventEmitter.removeAllListeners`\n   *\n   * If all 'data' event handlers are removed, and they were the last consumer\n   * (ie, there are no pipe destinations), then the flow of data will stop\n   * until there is another consumer or {@link Minipass#resume} is explicitly\n   * called.\n   */\n  removeAllListeners(ev) {\n    const ret = super.removeAllListeners(ev);\n    if (ev === 'data' || ev === undefined) {\n      this[DATALISTENERS] = 0;\n      if (!this[DISCARDED] && !this[PIPES].length) {\n        this[FLOWING] = false;\n      }\n    }\n    return ret;\n  }\n  /**\n   * true if the 'end' event has been emitted\n   */\n  get emittedEnd() {\n    return this[EMITTED_END];\n  }\n  [MAYBE_EMIT_END]() {\n    if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {\n      this[EMITTING_END] = true;\n      this.emit('end');\n      this.emit('prefinish');\n      this.emit('finish');\n      if (this[CLOSED]) this.emit('close');\n      this[EMITTING_END] = false;\n    }\n  }\n  /**\n   * Mostly identical to `EventEmitter.emit`, with the following\n   * behavior differences to prevent data loss and unnecessary hangs:\n   *\n   * If the stream has been destroyed, and the event is something other\n   * than 'close' or 'error', then `false` is returned and no handlers\n   * are called.\n   *\n   * If the event is 'end', and has already been emitted, then the event\n   * is ignored. If the stream is in a paused or non-flowing state, then\n   * the event will be deferred until data flow resumes. If the stream is\n   * async, then handlers will be called on the next tick rather than\n   * immediately.\n   *\n   * If the event is 'close', and 'end' has not yet been emitted, then\n   * the event will be deferred until after 'end' is emitted.\n   *\n   * If the event is 'error', and an AbortSignal was provided for the stream,\n   * and there are no listeners, then the event is ignored, matching the\n   * behavior of node core streams in the presense of an AbortSignal.\n   *\n   * If the event is 'finish' or 'prefinish', then all listeners will be\n   * removed after emitting the event, to prevent double-firing.\n   */\n  emit(ev, ...args) {\n    const data = args[0];\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED]) {\n      return false;\n    } else if (ev === 'data') {\n      return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer(() => this[EMITDATA](data)), true) : this[EMITDATA](data);\n    } else if (ev === 'end') {\n      return this[EMITEND]();\n    } else if (ev === 'close') {\n      this[CLOSED] = true;\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED]) return false;\n      const ret = super.emit('close');\n      this.removeAllListeners('close');\n      return ret;\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data;\n      super.emit(ERROR, data);\n      const ret = !this[SIGNAL] || this.listeners('error').length ? super.emit('error', data) : false;\n      this[MAYBE_EMIT_END]();\n      return ret;\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume');\n      this[MAYBE_EMIT_END]();\n      return ret;\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev);\n      this.removeAllListeners(ev);\n      return ret;\n    }\n    // Some other unknown event\n    const ret = super.emit(ev, ...args);\n    this[MAYBE_EMIT_END]();\n    return ret;\n  }\n  [EMITDATA](data) {\n    for (const p of this[PIPES]) {\n      if (p.dest.write(data) === false) this.pause();\n    }\n    const ret = this[DISCARDED] ? false : super.emit('data', data);\n    this[MAYBE_EMIT_END]();\n    return ret;\n  }\n  [EMITEND]() {\n    if (this[EMITTED_END]) return false;\n    this[EMITTED_END] = true;\n    this.readable = false;\n    return this[ASYNC] ? (defer(() => this[EMITEND2]()), true) : this[EMITEND2]();\n  }\n  [EMITEND2]() {\n    if (this[DECODER]) {\n      const data = this[DECODER].end();\n      if (data) {\n        for (const p of this[PIPES]) {\n          p.dest.write(data);\n        }\n        if (!this[DISCARDED]) super.emit('data', data);\n      }\n    }\n    for (const p of this[PIPES]) {\n      p.end();\n    }\n    const ret = super.emit('end');\n    this.removeAllListeners('end');\n    return ret;\n  }\n  /**\n   * Return a Promise that resolves to an array of all emitted data once\n   * the stream ends.\n   */\n  collect() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const buf = Object.assign([], {\n        dataLength: 0\n      });\n      if (!_this[OBJECTMODE]) buf.dataLength = 0;\n      // set the promise first, in case an error is raised\n      // by triggering the flow here.\n      const p = _this.promise();\n      _this.on('data', c => {\n        buf.push(c);\n        if (!_this[OBJECTMODE]) buf.dataLength += c.length;\n      });\n      yield p;\n      return buf;\n    })();\n  }\n  /**\n   * Return a Promise that resolves to the concatenation of all emitted data\n   * once the stream ends.\n   *\n   * Not allowed on objectMode streams.\n   */\n  concat() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2[OBJECTMODE]) {\n        throw new Error('cannot concat in objectMode');\n      }\n      const buf = yield _this2.collect();\n      return _this2[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength);\n    })();\n  }\n  /**\n   * Return a void Promise that resolves once the stream ends.\n   */\n  promise() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      return new Promise((resolve, reject) => {\n        _this3.on(DESTROYED, () => reject(new Error('stream destroyed')));\n        _this3.on('error', er => reject(er));\n        _this3.on('end', () => resolve());\n      });\n    })();\n  }\n  /**\n   * Asynchronous `for await of` iteration.\n   *\n   * This will continue emitting all chunks until the stream terminates.\n   */\n  [Symbol.asyncIterator]() {\n    var _this4 = this;\n    // set this up front, in case the consumer doesn't call next()\n    // right away.\n    this[DISCARDED] = false;\n    let stopped = false;\n    const stop = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* () {\n        _this4.pause();\n        stopped = true;\n        return {\n          value: undefined,\n          done: true\n        };\n      });\n      return function stop() {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    const next = () => {\n      if (stopped) return stop();\n      const res = this.read();\n      if (res !== null) return Promise.resolve({\n        done: false,\n        value: res\n      });\n      if (this[EOF]) return stop();\n      let resolve;\n      let reject;\n      const onerr = er => {\n        this.off('data', ondata);\n        this.off('end', onend);\n        this.off(DESTROYED, ondestroy);\n        stop();\n        reject(er);\n      };\n      const ondata = value => {\n        this.off('error', onerr);\n        this.off('end', onend);\n        this.off(DESTROYED, ondestroy);\n        this.pause();\n        resolve({\n          value,\n          done: !!this[EOF]\n        });\n      };\n      const onend = () => {\n        this.off('error', onerr);\n        this.off('data', ondata);\n        this.off(DESTROYED, ondestroy);\n        stop();\n        resolve({\n          done: true,\n          value: undefined\n        });\n      };\n      const ondestroy = () => onerr(new Error('stream destroyed'));\n      return new Promise((res, rej) => {\n        reject = rej;\n        resolve = res;\n        this.once(DESTROYED, ondestroy);\n        this.once('error', onerr);\n        this.once('end', onend);\n        this.once('data', ondata);\n      });\n    };\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [Symbol.asyncIterator]() {\n        return this;\n      }\n    };\n  }\n  /**\n   * Synchronous `for of` iteration.\n   *\n   * The iteration will terminate when the internal buffer runs out, even\n   * if the stream has not yet terminated.\n   */\n  [Symbol.iterator]() {\n    // set this up front, in case the consumer doesn't call next()\n    // right away.\n    this[DISCARDED] = false;\n    let stopped = false;\n    const stop = () => {\n      this.pause();\n      this.off(ERROR, stop);\n      this.off(DESTROYED, stop);\n      this.off('end', stop);\n      stopped = true;\n      return {\n        done: true,\n        value: undefined\n      };\n    };\n    const next = () => {\n      if (stopped) return stop();\n      const value = this.read();\n      return value === null ? stop() : {\n        done: false,\n        value\n      };\n    };\n    this.once('end', stop);\n    this.once(ERROR, stop);\n    this.once(DESTROYED, stop);\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  }\n  /**\n   * Destroy a stream, preventing it from being used for any further purpose.\n   *\n   * If the stream has a `close()` method, then it will be called on\n   * destruction.\n   *\n   * After destruction, any attempt to write data, read data, or emit most\n   * events will be ignored.\n   *\n   * If an error argument is provided, then it will be emitted in an\n   * 'error' event.\n   */\n  destroy(er) {\n    if (this[DESTROYED]) {\n      if (er) this.emit('error', er);else this.emit(DESTROYED);\n      return this;\n    }\n    this[DESTROYED] = true;\n    this[DISCARDED] = true;\n    // throw away all buffered data, it's never coming out\n    this[BUFFER].length = 0;\n    this[BUFFERLENGTH] = 0;\n    const wc = this;\n    if (typeof wc.close === 'function' && !this[CLOSED]) wc.close();\n    if (er) this.emit('error', er);\n    // if no error to emit, still reject pending promises\n    else this.emit(DESTROYED);\n    return this;\n  }\n  /**\n   * Alias for {@link isStream}\n   *\n   * Former export location, maintained for backwards compatibility.\n   *\n   * @deprecated\n   */\n  static get isStream() {\n    return exports.isStream;\n  }\n}\nexports.Minipass = Minipass;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","Minipass","isWritable","isReadable","isStream","proc","process","stdout","stderr","events_1","require","stream_1","string_decoder_1","s","default","EventEmitter","pipe","Writable","prototype","write","end","EOF","Symbol","MAYBE_EMIT_END","EMITTED_END","EMITTING_END","EMITTED_ERROR","CLOSED","READ","FLUSH","FLUSHCHUNK","ENCODING","DECODER","FLOWING","PAUSED","RESUME","BUFFER","PIPES","BUFFERLENGTH","BUFFERPUSH","BUFFERSHIFT","OBJECTMODE","DESTROYED","ERROR","EMITDATA","EMITEND","EMITEND2","ASYNC","ABORT","ABORTED","SIGNAL","DATALISTENERS","DISCARDED","defer","fn","Promise","resolve","then","nodefer","isEndish","ev","isArrayBufferLike","b","ArrayBuffer","constructor","name","byteLength","isArrayBufferView","Buffer","isBuffer","isView","Pipe","src","dest","opts","ondrain","on","unpipe","removeListener","proxyErrors","_er","PipeProxyErrors","er","emit","isObjectModeOptions","o","objectMode","isEncodingOptions","encoding","writable","readable","args","options","TypeError","async","StringDecoder","debugExposeBuffer","get","debugExposePipes","signal","aborted","addEventListener","bufferLength","_enc","Error","setEncoding","_om","a","reason","destroy","_","chunk","cb","assign","code","from","buffer","byteOffset","length","lastNeed","read","n","join","concat","ret","c","slice","subarray","undefined","once","resume","pause","destroyed","flowing","paused","push","shift","noDrain","ended","p","find","splice","indexOf","addListener","handler","removeAllListeners","h","call","off","listeners","emittedEnd","data","collect","buf","dataLength","promise","reject","asyncIterator","stopped","stop","done","next","res","onerr","ondata","onend","ondestroy","rej","throw","return","iterator","wc","close"],"sources":["I:/Angular/angular-blog/node_modules/read-package-json/node_modules/minipass/dist/commonjs/index.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Minipass = exports.isWritable = exports.isReadable = exports.isStream = void 0;\nconst proc = typeof process === 'object' && process\n    ? process\n    : {\n        stdout: null,\n        stderr: null,\n    };\nconst events_1 = require(\"events\");\nconst stream_1 = __importDefault(require(\"stream\"));\nconst string_decoder_1 = require(\"string_decoder\");\n/**\n * Return true if the argument is a Minipass stream, Node stream, or something\n * else that Minipass can interact with.\n */\nconst isStream = (s) => !!s &&\n    typeof s === 'object' &&\n    (s instanceof Minipass ||\n        s instanceof stream_1.default ||\n        (0, exports.isReadable)(s) ||\n        (0, exports.isWritable)(s));\nexports.isStream = isStream;\n/**\n * Return true if the argument is a valid {@link Minipass.Readable}\n */\nconst isReadable = (s) => !!s &&\n    typeof s === 'object' &&\n    s instanceof events_1.EventEmitter &&\n    typeof s.pipe === 'function' &&\n    // node core Writable streams have a pipe() method, but it throws\n    s.pipe !== stream_1.default.Writable.prototype.pipe;\nexports.isReadable = isReadable;\n/**\n * Return true if the argument is a valid {@link Minipass.Writable}\n */\nconst isWritable = (s) => !!s &&\n    typeof s === 'object' &&\n    s instanceof events_1.EventEmitter &&\n    typeof s.write === 'function' &&\n    typeof s.end === 'function';\nexports.isWritable = isWritable;\nconst EOF = Symbol('EOF');\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd');\nconst EMITTED_END = Symbol('emittedEnd');\nconst EMITTING_END = Symbol('emittingEnd');\nconst EMITTED_ERROR = Symbol('emittedError');\nconst CLOSED = Symbol('closed');\nconst READ = Symbol('read');\nconst FLUSH = Symbol('flush');\nconst FLUSHCHUNK = Symbol('flushChunk');\nconst ENCODING = Symbol('encoding');\nconst DECODER = Symbol('decoder');\nconst FLOWING = Symbol('flowing');\nconst PAUSED = Symbol('paused');\nconst RESUME = Symbol('resume');\nconst BUFFER = Symbol('buffer');\nconst PIPES = Symbol('pipes');\nconst BUFFERLENGTH = Symbol('bufferLength');\nconst BUFFERPUSH = Symbol('bufferPush');\nconst BUFFERSHIFT = Symbol('bufferShift');\nconst OBJECTMODE = Symbol('objectMode');\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed');\n// internal event when stream has an error\nconst ERROR = Symbol('error');\nconst EMITDATA = Symbol('emitData');\nconst EMITEND = Symbol('emitEnd');\nconst EMITEND2 = Symbol('emitEnd2');\nconst ASYNC = Symbol('async');\nconst ABORT = Symbol('abort');\nconst ABORTED = Symbol('aborted');\nconst SIGNAL = Symbol('signal');\nconst DATALISTENERS = Symbol('dataListeners');\nconst DISCARDED = Symbol('discarded');\nconst defer = (fn) => Promise.resolve().then(fn);\nconst nodefer = (fn) => fn();\nconst isEndish = (ev) => ev === 'end' || ev === 'finish' || ev === 'prefinish';\nconst isArrayBufferLike = (b) => b instanceof ArrayBuffer ||\n    (!!b &&\n        typeof b === 'object' &&\n        b.constructor &&\n        b.constructor.name === 'ArrayBuffer' &&\n        b.byteLength >= 0);\nconst isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);\n/**\n * Internal class representing a pipe to a destination stream.\n *\n * @internal\n */\nclass Pipe {\n    src;\n    dest;\n    opts;\n    ondrain;\n    constructor(src, dest, opts) {\n        this.src = src;\n        this.dest = dest;\n        this.opts = opts;\n        this.ondrain = () => src[RESUME]();\n        this.dest.on('drain', this.ondrain);\n    }\n    unpipe() {\n        this.dest.removeListener('drain', this.ondrain);\n    }\n    // only here for the prototype\n    /* c8 ignore start */\n    proxyErrors(_er) { }\n    /* c8 ignore stop */\n    end() {\n        this.unpipe();\n        if (this.opts.end)\n            this.dest.end();\n    }\n}\n/**\n * Internal class representing a pipe to a destination stream where\n * errors are proxied.\n *\n * @internal\n */\nclass PipeProxyErrors extends Pipe {\n    unpipe() {\n        this.src.removeListener('error', this.proxyErrors);\n        super.unpipe();\n    }\n    constructor(src, dest, opts) {\n        super(src, dest, opts);\n        this.proxyErrors = er => dest.emit('error', er);\n        src.on('error', this.proxyErrors);\n    }\n}\nconst isObjectModeOptions = (o) => !!o.objectMode;\nconst isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== 'buffer';\n/**\n * Main export, the Minipass class\n *\n * `RType` is the type of data emitted, defaults to Buffer\n *\n * `WType` is the type of data to be written, if RType is buffer or string,\n * then any {@link Minipass.ContiguousData} is allowed.\n *\n * `Events` is the set of event handler signatures that this object\n * will emit, see {@link Minipass.Events}\n */\nclass Minipass extends events_1.EventEmitter {\n    [FLOWING] = false;\n    [PAUSED] = false;\n    [PIPES] = [];\n    [BUFFER] = [];\n    [OBJECTMODE];\n    [ENCODING];\n    [ASYNC];\n    [DECODER];\n    [EOF] = false;\n    [EMITTED_END] = false;\n    [EMITTING_END] = false;\n    [CLOSED] = false;\n    [EMITTED_ERROR] = null;\n    [BUFFERLENGTH] = 0;\n    [DESTROYED] = false;\n    [SIGNAL];\n    [ABORTED] = false;\n    [DATALISTENERS] = 0;\n    [DISCARDED] = false;\n    /**\n     * true if the stream can be written\n     */\n    writable = true;\n    /**\n     * true if the stream can be read\n     */\n    readable = true;\n    /**\n     * If `RType` is Buffer, then options do not need to be provided.\n     * Otherwise, an options object must be provided to specify either\n     * {@link Minipass.SharedOptions.objectMode} or\n     * {@link Minipass.SharedOptions.encoding}, as appropriate.\n     */\n    constructor(...args) {\n        const options = (args[0] ||\n            {});\n        super();\n        if (options.objectMode && typeof options.encoding === 'string') {\n            throw new TypeError('Encoding and objectMode may not be used together');\n        }\n        if (isObjectModeOptions(options)) {\n            this[OBJECTMODE] = true;\n            this[ENCODING] = null;\n        }\n        else if (isEncodingOptions(options)) {\n            this[ENCODING] = options.encoding;\n            this[OBJECTMODE] = false;\n        }\n        else {\n            this[OBJECTMODE] = false;\n            this[ENCODING] = null;\n        }\n        this[ASYNC] = !!options.async;\n        this[DECODER] = this[ENCODING]\n            ? new string_decoder_1.StringDecoder(this[ENCODING])\n            : null;\n        //@ts-ignore - private option for debugging and testing\n        if (options && options.debugExposeBuffer === true) {\n            Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] });\n        }\n        //@ts-ignore - private option for debugging and testing\n        if (options && options.debugExposePipes === true) {\n            Object.defineProperty(this, 'pipes', { get: () => this[PIPES] });\n        }\n        const { signal } = options;\n        if (signal) {\n            this[SIGNAL] = signal;\n            if (signal.aborted) {\n                this[ABORT]();\n            }\n            else {\n                signal.addEventListener('abort', () => this[ABORT]());\n            }\n        }\n    }\n    /**\n     * The amount of data stored in the buffer waiting to be read.\n     *\n     * For Buffer strings, this will be the total byte length.\n     * For string encoding streams, this will be the string character length,\n     * according to JavaScript's `string.length` logic.\n     * For objectMode streams, this is a count of the items waiting to be\n     * emitted.\n     */\n    get bufferLength() {\n        return this[BUFFERLENGTH];\n    }\n    /**\n     * The `BufferEncoding` currently in use, or `null`\n     */\n    get encoding() {\n        return this[ENCODING];\n    }\n    /**\n     * @deprecated - This is a read only property\n     */\n    set encoding(_enc) {\n        throw new Error('Encoding must be set at instantiation time');\n    }\n    /**\n     * @deprecated - Encoding may only be set at instantiation time\n     */\n    setEncoding(_enc) {\n        throw new Error('Encoding must be set at instantiation time');\n    }\n    /**\n     * True if this is an objectMode stream\n     */\n    get objectMode() {\n        return this[OBJECTMODE];\n    }\n    /**\n     * @deprecated - This is a read-only property\n     */\n    set objectMode(_om) {\n        throw new Error('objectMode must be set at instantiation time');\n    }\n    /**\n     * true if this is an async stream\n     */\n    get ['async']() {\n        return this[ASYNC];\n    }\n    /**\n     * Set to true to make this stream async.\n     *\n     * Once set, it cannot be unset, as this would potentially cause incorrect\n     * behavior.  Ie, a sync stream can be made async, but an async stream\n     * cannot be safely made sync.\n     */\n    set ['async'](a) {\n        this[ASYNC] = this[ASYNC] || !!a;\n    }\n    // drop everything and get out of the flow completely\n    [ABORT]() {\n        this[ABORTED] = true;\n        this.emit('abort', this[SIGNAL]?.reason);\n        this.destroy(this[SIGNAL]?.reason);\n    }\n    /**\n     * True if the stream has been aborted.\n     */\n    get aborted() {\n        return this[ABORTED];\n    }\n    /**\n     * No-op setter. Stream aborted status is set via the AbortSignal provided\n     * in the constructor options.\n     */\n    set aborted(_) { }\n    write(chunk, encoding, cb) {\n        if (this[ABORTED])\n            return false;\n        if (this[EOF])\n            throw new Error('write after end');\n        if (this[DESTROYED]) {\n            this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), { code: 'ERR_STREAM_DESTROYED' }));\n            return true;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = 'utf8';\n        }\n        if (!encoding)\n            encoding = 'utf8';\n        const fn = this[ASYNC] ? defer : nodefer;\n        // convert array buffers and typed array views into buffers\n        // at some point in the future, we may want to do the opposite!\n        // leave strings and buffers as-is\n        // anything is only allowed if in object mode, so throw\n        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n            if (isArrayBufferView(chunk)) {\n                //@ts-ignore - sinful unsafe type changing\n                chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n            }\n            else if (isArrayBufferLike(chunk)) {\n                //@ts-ignore - sinful unsafe type changing\n                chunk = Buffer.from(chunk);\n            }\n            else if (typeof chunk !== 'string') {\n                throw new Error('Non-contiguous data written to non-objectMode stream');\n            }\n        }\n        // handle object mode up front, since it's simpler\n        // this yields better performance, fewer checks later.\n        if (this[OBJECTMODE]) {\n            // maybe impossible?\n            /* c8 ignore start */\n            if (this[FLOWING] && this[BUFFERLENGTH] !== 0)\n                this[FLUSH](true);\n            /* c8 ignore stop */\n            if (this[FLOWING])\n                this.emit('data', chunk);\n            else\n                this[BUFFERPUSH](chunk);\n            if (this[BUFFERLENGTH] !== 0)\n                this.emit('readable');\n            if (cb)\n                fn(cb);\n            return this[FLOWING];\n        }\n        // at this point the chunk is a buffer or string\n        // don't buffer it up or send it to the decoder\n        if (!chunk.length) {\n            if (this[BUFFERLENGTH] !== 0)\n                this.emit('readable');\n            if (cb)\n                fn(cb);\n            return this[FLOWING];\n        }\n        // fast-path writing strings of same encoding to a stream with\n        // an empty buffer, skipping the buffer/decoder dance\n        if (typeof chunk === 'string' &&\n            // unless it is a string already ready for us to use\n            !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {\n            //@ts-ignore - sinful unsafe type change\n            chunk = Buffer.from(chunk, encoding);\n        }\n        if (Buffer.isBuffer(chunk) && this[ENCODING]) {\n            //@ts-ignore - sinful unsafe type change\n            chunk = this[DECODER].write(chunk);\n        }\n        // Note: flushing CAN potentially switch us into not-flowing mode\n        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)\n            this[FLUSH](true);\n        if (this[FLOWING])\n            this.emit('data', chunk);\n        else\n            this[BUFFERPUSH](chunk);\n        if (this[BUFFERLENGTH] !== 0)\n            this.emit('readable');\n        if (cb)\n            fn(cb);\n        return this[FLOWING];\n    }\n    /**\n     * Low-level explicit read method.\n     *\n     * In objectMode, the argument is ignored, and one item is returned if\n     * available.\n     *\n     * `n` is the number of bytes (or in the case of encoding streams,\n     * characters) to consume. If `n` is not provided, then the entire buffer\n     * is returned, or `null` is returned if no data is available.\n     *\n     * If `n` is greater that the amount of data in the internal buffer,\n     * then `null` is returned.\n     */\n    read(n) {\n        if (this[DESTROYED])\n            return null;\n        this[DISCARDED] = false;\n        if (this[BUFFERLENGTH] === 0 ||\n            n === 0 ||\n            (n && n > this[BUFFERLENGTH])) {\n            this[MAYBE_EMIT_END]();\n            return null;\n        }\n        if (this[OBJECTMODE])\n            n = null;\n        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n            // not object mode, so if we have an encoding, then RType is string\n            // otherwise, must be Buffer\n            this[BUFFER] = [\n                (this[ENCODING]\n                    ? this[BUFFER].join('')\n                    : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])),\n            ];\n        }\n        const ret = this[READ](n || null, this[BUFFER][0]);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [READ](n, chunk) {\n        if (this[OBJECTMODE])\n            this[BUFFERSHIFT]();\n        else {\n            const c = chunk;\n            if (n === c.length || n === null)\n                this[BUFFERSHIFT]();\n            else if (typeof c === 'string') {\n                this[BUFFER][0] = c.slice(n);\n                chunk = c.slice(0, n);\n                this[BUFFERLENGTH] -= n;\n            }\n            else {\n                this[BUFFER][0] = c.subarray(n);\n                chunk = c.subarray(0, n);\n                this[BUFFERLENGTH] -= n;\n            }\n        }\n        this.emit('data', chunk);\n        if (!this[BUFFER].length && !this[EOF])\n            this.emit('drain');\n        return chunk;\n    }\n    end(chunk, encoding, cb) {\n        if (typeof chunk === 'function') {\n            cb = chunk;\n            chunk = undefined;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = 'utf8';\n        }\n        if (chunk !== undefined)\n            this.write(chunk, encoding);\n        if (cb)\n            this.once('end', cb);\n        this[EOF] = true;\n        this.writable = false;\n        // if we haven't written anything, then go ahead and emit,\n        // even if we're not reading.\n        // we'll re-emit if a new 'end' listener is added anyway.\n        // This makes MP more suitable to write-only use cases.\n        if (this[FLOWING] || !this[PAUSED])\n            this[MAYBE_EMIT_END]();\n        return this;\n    }\n    // don't let the internal resume be overwritten\n    [RESUME]() {\n        if (this[DESTROYED])\n            return;\n        if (!this[DATALISTENERS] && !this[PIPES].length) {\n            this[DISCARDED] = true;\n        }\n        this[PAUSED] = false;\n        this[FLOWING] = true;\n        this.emit('resume');\n        if (this[BUFFER].length)\n            this[FLUSH]();\n        else if (this[EOF])\n            this[MAYBE_EMIT_END]();\n        else\n            this.emit('drain');\n    }\n    /**\n     * Resume the stream if it is currently in a paused state\n     *\n     * If called when there are no pipe destinations or `data` event listeners,\n     * this will place the stream in a \"discarded\" state, where all data will\n     * be thrown away. The discarded state is removed if a pipe destination or\n     * data handler is added, if pause() is called, or if any synchronous or\n     * asynchronous iteration is started.\n     */\n    resume() {\n        return this[RESUME]();\n    }\n    /**\n     * Pause the stream\n     */\n    pause() {\n        this[FLOWING] = false;\n        this[PAUSED] = true;\n        this[DISCARDED] = false;\n    }\n    /**\n     * true if the stream has been forcibly destroyed\n     */\n    get destroyed() {\n        return this[DESTROYED];\n    }\n    /**\n     * true if the stream is currently in a flowing state, meaning that\n     * any writes will be immediately emitted.\n     */\n    get flowing() {\n        return this[FLOWING];\n    }\n    /**\n     * true if the stream is currently in a paused state\n     */\n    get paused() {\n        return this[PAUSED];\n    }\n    [BUFFERPUSH](chunk) {\n        if (this[OBJECTMODE])\n            this[BUFFERLENGTH] += 1;\n        else\n            this[BUFFERLENGTH] += chunk.length;\n        this[BUFFER].push(chunk);\n    }\n    [BUFFERSHIFT]() {\n        if (this[OBJECTMODE])\n            this[BUFFERLENGTH] -= 1;\n        else\n            this[BUFFERLENGTH] -= this[BUFFER][0].length;\n        return this[BUFFER].shift();\n    }\n    [FLUSH](noDrain = false) {\n        do { } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&\n            this[BUFFER].length);\n        if (!noDrain && !this[BUFFER].length && !this[EOF])\n            this.emit('drain');\n    }\n    [FLUSHCHUNK](chunk) {\n        this.emit('data', chunk);\n        return this[FLOWING];\n    }\n    /**\n     * Pipe all data emitted by this stream into the destination provided.\n     *\n     * Triggers the flow of data.\n     */\n    pipe(dest, opts) {\n        if (this[DESTROYED])\n            return dest;\n        this[DISCARDED] = false;\n        const ended = this[EMITTED_END];\n        opts = opts || {};\n        if (dest === proc.stdout || dest === proc.stderr)\n            opts.end = false;\n        else\n            opts.end = opts.end !== false;\n        opts.proxyErrors = !!opts.proxyErrors;\n        // piping an ended stream ends immediately\n        if (ended) {\n            if (opts.end)\n                dest.end();\n        }\n        else {\n            // \"as\" here just ignores the WType, which pipes don't care about,\n            // since they're only consuming from us, and writing to the dest\n            this[PIPES].push(!opts.proxyErrors\n                ? new Pipe(this, dest, opts)\n                : new PipeProxyErrors(this, dest, opts));\n            if (this[ASYNC])\n                defer(() => this[RESUME]());\n            else\n                this[RESUME]();\n        }\n        return dest;\n    }\n    /**\n     * Fully unhook a piped destination stream.\n     *\n     * If the destination stream was the only consumer of this stream (ie,\n     * there are no other piped destinations or `'data'` event listeners)\n     * then the flow of data will stop until there is another consumer or\n     * {@link Minipass#resume} is explicitly called.\n     */\n    unpipe(dest) {\n        const p = this[PIPES].find(p => p.dest === dest);\n        if (p) {\n            if (this[PIPES].length === 1) {\n                if (this[FLOWING] && this[DATALISTENERS] === 0) {\n                    this[FLOWING] = false;\n                }\n                this[PIPES] = [];\n            }\n            else\n                this[PIPES].splice(this[PIPES].indexOf(p), 1);\n            p.unpipe();\n        }\n    }\n    /**\n     * Alias for {@link Minipass#on}\n     */\n    addListener(ev, handler) {\n        return this.on(ev, handler);\n    }\n    /**\n     * Mostly identical to `EventEmitter.on`, with the following\n     * behavior differences to prevent data loss and unnecessary hangs:\n     *\n     * - Adding a 'data' event handler will trigger the flow of data\n     *\n     * - Adding a 'readable' event handler when there is data waiting to be read\n     *   will cause 'readable' to be emitted immediately.\n     *\n     * - Adding an 'endish' event handler ('end', 'finish', etc.) which has\n     *   already passed will cause the event to be emitted immediately and all\n     *   handlers removed.\n     *\n     * - Adding an 'error' event handler after an error has been emitted will\n     *   cause the event to be re-emitted immediately with the error previously\n     *   raised.\n     */\n    on(ev, handler) {\n        const ret = super.on(ev, handler);\n        if (ev === 'data') {\n            this[DISCARDED] = false;\n            this[DATALISTENERS]++;\n            if (!this[PIPES].length && !this[FLOWING]) {\n                this[RESUME]();\n            }\n        }\n        else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {\n            super.emit('readable');\n        }\n        else if (isEndish(ev) && this[EMITTED_END]) {\n            super.emit(ev);\n            this.removeAllListeners(ev);\n        }\n        else if (ev === 'error' && this[EMITTED_ERROR]) {\n            const h = handler;\n            if (this[ASYNC])\n                defer(() => h.call(this, this[EMITTED_ERROR]));\n            else\n                h.call(this, this[EMITTED_ERROR]);\n        }\n        return ret;\n    }\n    /**\n     * Alias for {@link Minipass#off}\n     */\n    removeListener(ev, handler) {\n        return this.off(ev, handler);\n    }\n    /**\n     * Mostly identical to `EventEmitter.off`\n     *\n     * If a 'data' event handler is removed, and it was the last consumer\n     * (ie, there are no pipe destinations or other 'data' event listeners),\n     * then the flow of data will stop until there is another consumer or\n     * {@link Minipass#resume} is explicitly called.\n     */\n    off(ev, handler) {\n        const ret = super.off(ev, handler);\n        // if we previously had listeners, and now we don't, and we don't\n        // have any pipes, then stop the flow, unless it's been explicitly\n        // put in a discarded flowing state via stream.resume().\n        if (ev === 'data') {\n            this[DATALISTENERS] = this.listeners('data').length;\n            if (this[DATALISTENERS] === 0 &&\n                !this[DISCARDED] &&\n                !this[PIPES].length) {\n                this[FLOWING] = false;\n            }\n        }\n        return ret;\n    }\n    /**\n     * Mostly identical to `EventEmitter.removeAllListeners`\n     *\n     * If all 'data' event handlers are removed, and they were the last consumer\n     * (ie, there are no pipe destinations), then the flow of data will stop\n     * until there is another consumer or {@link Minipass#resume} is explicitly\n     * called.\n     */\n    removeAllListeners(ev) {\n        const ret = super.removeAllListeners(ev);\n        if (ev === 'data' || ev === undefined) {\n            this[DATALISTENERS] = 0;\n            if (!this[DISCARDED] && !this[PIPES].length) {\n                this[FLOWING] = false;\n            }\n        }\n        return ret;\n    }\n    /**\n     * true if the 'end' event has been emitted\n     */\n    get emittedEnd() {\n        return this[EMITTED_END];\n    }\n    [MAYBE_EMIT_END]() {\n        if (!this[EMITTING_END] &&\n            !this[EMITTED_END] &&\n            !this[DESTROYED] &&\n            this[BUFFER].length === 0 &&\n            this[EOF]) {\n            this[EMITTING_END] = true;\n            this.emit('end');\n            this.emit('prefinish');\n            this.emit('finish');\n            if (this[CLOSED])\n                this.emit('close');\n            this[EMITTING_END] = false;\n        }\n    }\n    /**\n     * Mostly identical to `EventEmitter.emit`, with the following\n     * behavior differences to prevent data loss and unnecessary hangs:\n     *\n     * If the stream has been destroyed, and the event is something other\n     * than 'close' or 'error', then `false` is returned and no handlers\n     * are called.\n     *\n     * If the event is 'end', and has already been emitted, then the event\n     * is ignored. If the stream is in a paused or non-flowing state, then\n     * the event will be deferred until data flow resumes. If the stream is\n     * async, then handlers will be called on the next tick rather than\n     * immediately.\n     *\n     * If the event is 'close', and 'end' has not yet been emitted, then\n     * the event will be deferred until after 'end' is emitted.\n     *\n     * If the event is 'error', and an AbortSignal was provided for the stream,\n     * and there are no listeners, then the event is ignored, matching the\n     * behavior of node core streams in the presense of an AbortSignal.\n     *\n     * If the event is 'finish' or 'prefinish', then all listeners will be\n     * removed after emitting the event, to prevent double-firing.\n     */\n    emit(ev, ...args) {\n        const data = args[0];\n        // error and close are only events allowed after calling destroy()\n        if (ev !== 'error' &&\n            ev !== 'close' &&\n            ev !== DESTROYED &&\n            this[DESTROYED]) {\n            return false;\n        }\n        else if (ev === 'data') {\n            return !this[OBJECTMODE] && !data\n                ? false\n                : this[ASYNC]\n                    ? (defer(() => this[EMITDATA](data)), true)\n                    : this[EMITDATA](data);\n        }\n        else if (ev === 'end') {\n            return this[EMITEND]();\n        }\n        else if (ev === 'close') {\n            this[CLOSED] = true;\n            // don't emit close before 'end' and 'finish'\n            if (!this[EMITTED_END] && !this[DESTROYED])\n                return false;\n            const ret = super.emit('close');\n            this.removeAllListeners('close');\n            return ret;\n        }\n        else if (ev === 'error') {\n            this[EMITTED_ERROR] = data;\n            super.emit(ERROR, data);\n            const ret = !this[SIGNAL] || this.listeners('error').length\n                ? super.emit('error', data)\n                : false;\n            this[MAYBE_EMIT_END]();\n            return ret;\n        }\n        else if (ev === 'resume') {\n            const ret = super.emit('resume');\n            this[MAYBE_EMIT_END]();\n            return ret;\n        }\n        else if (ev === 'finish' || ev === 'prefinish') {\n            const ret = super.emit(ev);\n            this.removeAllListeners(ev);\n            return ret;\n        }\n        // Some other unknown event\n        const ret = super.emit(ev, ...args);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [EMITDATA](data) {\n        for (const p of this[PIPES]) {\n            if (p.dest.write(data) === false)\n                this.pause();\n        }\n        const ret = this[DISCARDED] ? false : super.emit('data', data);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [EMITEND]() {\n        if (this[EMITTED_END])\n            return false;\n        this[EMITTED_END] = true;\n        this.readable = false;\n        return this[ASYNC]\n            ? (defer(() => this[EMITEND2]()), true)\n            : this[EMITEND2]();\n    }\n    [EMITEND2]() {\n        if (this[DECODER]) {\n            const data = this[DECODER].end();\n            if (data) {\n                for (const p of this[PIPES]) {\n                    p.dest.write(data);\n                }\n                if (!this[DISCARDED])\n                    super.emit('data', data);\n            }\n        }\n        for (const p of this[PIPES]) {\n            p.end();\n        }\n        const ret = super.emit('end');\n        this.removeAllListeners('end');\n        return ret;\n    }\n    /**\n     * Return a Promise that resolves to an array of all emitted data once\n     * the stream ends.\n     */\n    async collect() {\n        const buf = Object.assign([], {\n            dataLength: 0,\n        });\n        if (!this[OBJECTMODE])\n            buf.dataLength = 0;\n        // set the promise first, in case an error is raised\n        // by triggering the flow here.\n        const p = this.promise();\n        this.on('data', c => {\n            buf.push(c);\n            if (!this[OBJECTMODE])\n                buf.dataLength += c.length;\n        });\n        await p;\n        return buf;\n    }\n    /**\n     * Return a Promise that resolves to the concatenation of all emitted data\n     * once the stream ends.\n     *\n     * Not allowed on objectMode streams.\n     */\n    async concat() {\n        if (this[OBJECTMODE]) {\n            throw new Error('cannot concat in objectMode');\n        }\n        const buf = await this.collect();\n        return (this[ENCODING]\n            ? buf.join('')\n            : Buffer.concat(buf, buf.dataLength));\n    }\n    /**\n     * Return a void Promise that resolves once the stream ends.\n     */\n    async promise() {\n        return new Promise((resolve, reject) => {\n            this.on(DESTROYED, () => reject(new Error('stream destroyed')));\n            this.on('error', er => reject(er));\n            this.on('end', () => resolve());\n        });\n    }\n    /**\n     * Asynchronous `for await of` iteration.\n     *\n     * This will continue emitting all chunks until the stream terminates.\n     */\n    [Symbol.asyncIterator]() {\n        // set this up front, in case the consumer doesn't call next()\n        // right away.\n        this[DISCARDED] = false;\n        let stopped = false;\n        const stop = async () => {\n            this.pause();\n            stopped = true;\n            return { value: undefined, done: true };\n        };\n        const next = () => {\n            if (stopped)\n                return stop();\n            const res = this.read();\n            if (res !== null)\n                return Promise.resolve({ done: false, value: res });\n            if (this[EOF])\n                return stop();\n            let resolve;\n            let reject;\n            const onerr = (er) => {\n                this.off('data', ondata);\n                this.off('end', onend);\n                this.off(DESTROYED, ondestroy);\n                stop();\n                reject(er);\n            };\n            const ondata = (value) => {\n                this.off('error', onerr);\n                this.off('end', onend);\n                this.off(DESTROYED, ondestroy);\n                this.pause();\n                resolve({ value, done: !!this[EOF] });\n            };\n            const onend = () => {\n                this.off('error', onerr);\n                this.off('data', ondata);\n                this.off(DESTROYED, ondestroy);\n                stop();\n                resolve({ done: true, value: undefined });\n            };\n            const ondestroy = () => onerr(new Error('stream destroyed'));\n            return new Promise((res, rej) => {\n                reject = rej;\n                resolve = res;\n                this.once(DESTROYED, ondestroy);\n                this.once('error', onerr);\n                this.once('end', onend);\n                this.once('data', ondata);\n            });\n        };\n        return {\n            next,\n            throw: stop,\n            return: stop,\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n        };\n    }\n    /**\n     * Synchronous `for of` iteration.\n     *\n     * The iteration will terminate when the internal buffer runs out, even\n     * if the stream has not yet terminated.\n     */\n    [Symbol.iterator]() {\n        // set this up front, in case the consumer doesn't call next()\n        // right away.\n        this[DISCARDED] = false;\n        let stopped = false;\n        const stop = () => {\n            this.pause();\n            this.off(ERROR, stop);\n            this.off(DESTROYED, stop);\n            this.off('end', stop);\n            stopped = true;\n            return { done: true, value: undefined };\n        };\n        const next = () => {\n            if (stopped)\n                return stop();\n            const value = this.read();\n            return value === null ? stop() : { done: false, value };\n        };\n        this.once('end', stop);\n        this.once(ERROR, stop);\n        this.once(DESTROYED, stop);\n        return {\n            next,\n            throw: stop,\n            return: stop,\n            [Symbol.iterator]() {\n                return this;\n            },\n        };\n    }\n    /**\n     * Destroy a stream, preventing it from being used for any further purpose.\n     *\n     * If the stream has a `close()` method, then it will be called on\n     * destruction.\n     *\n     * After destruction, any attempt to write data, read data, or emit most\n     * events will be ignored.\n     *\n     * If an error argument is provided, then it will be emitted in an\n     * 'error' event.\n     */\n    destroy(er) {\n        if (this[DESTROYED]) {\n            if (er)\n                this.emit('error', er);\n            else\n                this.emit(DESTROYED);\n            return this;\n        }\n        this[DESTROYED] = true;\n        this[DISCARDED] = true;\n        // throw away all buffered data, it's never coming out\n        this[BUFFER].length = 0;\n        this[BUFFERLENGTH] = 0;\n        const wc = this;\n        if (typeof wc.close === 'function' && !this[CLOSED])\n            wc.close();\n        if (er)\n            this.emit('error', er);\n        // if no error to emit, still reject pending promises\n        else\n            this.emit(DESTROYED);\n        return this;\n    }\n    /**\n     * Alias for {@link isStream}\n     *\n     * Former export location, maintained for backwards compatibility.\n     *\n     * @deprecated\n     */\n    static get isStream() {\n        return exports.isStream;\n    }\n}\nexports.Minipass = Minipass;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}