{"ast":null,"code":"\"use strict\";\n\n// give it a pattern, and it'll be able to tell you if\n// a given path should be ignored.\n// Ignoring a path ignores its children if the pattern ends in /**\n// Ignores are always parsed in dot:true mode\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Ignore = void 0;\nconst minimatch_1 = require(\"minimatch\");\nconst pattern_js_1 = require(\"./pattern.js\");\nconst defaultPlatform = typeof process === 'object' && process && typeof process.platform === 'string' ? process.platform : 'linux';\n/**\n * Class used to process ignored patterns\n */\nclass Ignore {\n  relative;\n  relativeChildren;\n  absolute;\n  absoluteChildren;\n  constructor(ignored, {\n    nobrace,\n    nocase,\n    noext,\n    noglobstar,\n    platform = defaultPlatform\n  }) {\n    this.relative = [];\n    this.absolute = [];\n    this.relativeChildren = [];\n    this.absoluteChildren = [];\n    const mmopts = {\n      dot: true,\n      nobrace,\n      nocase,\n      noext,\n      noglobstar,\n      optimizationLevel: 2,\n      platform,\n      nocomment: true,\n      nonegate: true\n    };\n    // this is a little weird, but it gives us a clean set of optimized\n    // minimatch matchers, without getting tripped up if one of them\n    // ends in /** inside a brace section, and it's only inefficient at\n    // the start of the walk, not along it.\n    // It'd be nice if the Pattern class just had a .test() method, but\n    // handling globstars is a bit of a pita, and that code already lives\n    // in minimatch anyway.\n    // Another way would be if maybe Minimatch could take its set/globParts\n    // as an option, and then we could at least just use Pattern to test\n    // for absolute-ness.\n    // Yet another way, Minimatch could take an array of glob strings, and\n    // a cwd option, and do the right thing.\n    for (const ign of ignored) {\n      const mm = new minimatch_1.Minimatch(ign, mmopts);\n      for (let i = 0; i < mm.set.length; i++) {\n        const parsed = mm.set[i];\n        const globParts = mm.globParts[i];\n        /* c8 ignore start */\n        if (!parsed || !globParts) {\n          throw new Error('invalid pattern object');\n        }\n        /* c8 ignore stop */\n        const p = new pattern_js_1.Pattern(parsed, globParts, 0, platform);\n        const m = new minimatch_1.Minimatch(p.globString(), mmopts);\n        const children = globParts[globParts.length - 1] === '**';\n        const absolute = p.isAbsolute();\n        if (absolute) this.absolute.push(m);else this.relative.push(m);\n        if (children) {\n          if (absolute) this.absoluteChildren.push(m);else this.relativeChildren.push(m);\n        }\n      }\n    }\n  }\n  ignored(p) {\n    const fullpath = p.fullpath();\n    const fullpaths = `${fullpath}/`;\n    const relative = p.relative() || '.';\n    const relatives = `${relative}/`;\n    for (const m of this.relative) {\n      if (m.match(relative) || m.match(relatives)) return true;\n    }\n    for (const m of this.absolute) {\n      if (m.match(fullpath) || m.match(fullpaths)) return true;\n    }\n    return false;\n  }\n  childrenIgnored(p) {\n    const fullpath = p.fullpath() + '/';\n    const relative = (p.relative() || '.') + '/';\n    for (const m of this.relativeChildren) {\n      if (m.match(relative)) return true;\n    }\n    for (const m of this.absoluteChildren) {\n      if (m.match(fullpath)) return true;\n    }\n    return false;\n  }\n}\nexports.Ignore = Ignore;","map":{"version":3,"names":["Object","defineProperty","exports","value","Ignore","minimatch_1","require","pattern_js_1","defaultPlatform","process","platform","relative","relativeChildren","absolute","absoluteChildren","constructor","ignored","nobrace","nocase","noext","noglobstar","mmopts","dot","optimizationLevel","nocomment","nonegate","ign","mm","Minimatch","i","set","length","parsed","globParts","Error","p","Pattern","m","globString","children","isAbsolute","push","fullpath","fullpaths","relatives","match","childrenIgnored"],"sources":["I:/Angular/angular-blog/node_modules/read-package-json/node_modules/glob/dist/commonjs/ignore.js"],"sourcesContent":["\"use strict\";\n// give it a pattern, and it'll be able to tell you if\n// a given path should be ignored.\n// Ignoring a path ignores its children if the pattern ends in /**\n// Ignores are always parsed in dot:true mode\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Ignore = void 0;\nconst minimatch_1 = require(\"minimatch\");\nconst pattern_js_1 = require(\"./pattern.js\");\nconst defaultPlatform = typeof process === 'object' &&\n    process &&\n    typeof process.platform === 'string'\n    ? process.platform\n    : 'linux';\n/**\n * Class used to process ignored patterns\n */\nclass Ignore {\n    relative;\n    relativeChildren;\n    absolute;\n    absoluteChildren;\n    constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform, }) {\n        this.relative = [];\n        this.absolute = [];\n        this.relativeChildren = [];\n        this.absoluteChildren = [];\n        const mmopts = {\n            dot: true,\n            nobrace,\n            nocase,\n            noext,\n            noglobstar,\n            optimizationLevel: 2,\n            platform,\n            nocomment: true,\n            nonegate: true,\n        };\n        // this is a little weird, but it gives us a clean set of optimized\n        // minimatch matchers, without getting tripped up if one of them\n        // ends in /** inside a brace section, and it's only inefficient at\n        // the start of the walk, not along it.\n        // It'd be nice if the Pattern class just had a .test() method, but\n        // handling globstars is a bit of a pita, and that code already lives\n        // in minimatch anyway.\n        // Another way would be if maybe Minimatch could take its set/globParts\n        // as an option, and then we could at least just use Pattern to test\n        // for absolute-ness.\n        // Yet another way, Minimatch could take an array of glob strings, and\n        // a cwd option, and do the right thing.\n        for (const ign of ignored) {\n            const mm = new minimatch_1.Minimatch(ign, mmopts);\n            for (let i = 0; i < mm.set.length; i++) {\n                const parsed = mm.set[i];\n                const globParts = mm.globParts[i];\n                /* c8 ignore start */\n                if (!parsed || !globParts) {\n                    throw new Error('invalid pattern object');\n                }\n                /* c8 ignore stop */\n                const p = new pattern_js_1.Pattern(parsed, globParts, 0, platform);\n                const m = new minimatch_1.Minimatch(p.globString(), mmopts);\n                const children = globParts[globParts.length - 1] === '**';\n                const absolute = p.isAbsolute();\n                if (absolute)\n                    this.absolute.push(m);\n                else\n                    this.relative.push(m);\n                if (children) {\n                    if (absolute)\n                        this.absoluteChildren.push(m);\n                    else\n                        this.relativeChildren.push(m);\n                }\n            }\n        }\n    }\n    ignored(p) {\n        const fullpath = p.fullpath();\n        const fullpaths = `${fullpath}/`;\n        const relative = p.relative() || '.';\n        const relatives = `${relative}/`;\n        for (const m of this.relative) {\n            if (m.match(relative) || m.match(relatives))\n                return true;\n        }\n        for (const m of this.absolute) {\n            if (m.match(fullpath) || m.match(fullpaths))\n                return true;\n        }\n        return false;\n    }\n    childrenIgnored(p) {\n        const fullpath = p.fullpath() + '/';\n        const relative = (p.relative() || '.') + '/';\n        for (const m of this.relativeChildren) {\n            if (m.match(relative))\n                return true;\n        }\n        for (const m of this.absoluteChildren) {\n            if (m.match(fullpath))\n                return true;\n        }\n        return false;\n    }\n}\nexports.Ignore = Ignore;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}