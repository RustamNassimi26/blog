{"ast":null,"code":"var _asyncToGenerator = require(\"I:/Angular/angular-blog/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst {\n  dirname,\n  join,\n  resolve,\n  relative,\n  isAbsolute\n} = require('path');\nconst rimraf_ = require('rimraf');\nconst {\n  promisify\n} = require('util');\nconst {\n  access: access_,\n  accessSync,\n  copyFile: copyFile_,\n  copyFileSync,\n  readdir: readdir_,\n  readdirSync,\n  rename: rename_,\n  renameSync,\n  stat: stat_,\n  statSync,\n  lstat: lstat_,\n  lstatSync,\n  symlink: symlink_,\n  symlinkSync,\n  readlink: readlink_,\n  readlinkSync\n} = require('fs');\nconst access = promisify(access_);\nconst copyFile = promisify(copyFile_);\nconst readdir = promisify(readdir_);\nconst rename = promisify(rename_);\nconst stat = promisify(stat_);\nconst lstat = promisify(lstat_);\nconst symlink = promisify(symlink_);\nconst readlink = promisify(readlink_);\nconst rimraf = promisify(rimraf_);\nconst rimrafSync = rimraf_.sync;\nconst mkdirp = require('mkdirp');\nconst pathExists = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (path) {\n    try {\n      yield access(path);\n      return true;\n    } catch (er) {\n      return er.code !== 'ENOENT';\n    }\n  });\n  return function pathExists(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nconst pathExistsSync = path => {\n  try {\n    accessSync(path);\n    return true;\n  } catch (er) {\n    return er.code !== 'ENOENT';\n  }\n};\nconst moveFile = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (source, destination, options = {}, root = true, symlinks = []) {\n    if (!source || !destination) {\n      throw new TypeError('`source` and `destination` file required');\n    }\n    options = {\n      overwrite: true,\n      ...options\n    };\n    if (!options.overwrite && (yield pathExists(destination))) {\n      throw new Error(`The destination file exists: ${destination}`);\n    }\n    yield mkdirp(dirname(destination));\n    try {\n      yield rename(source, destination);\n    } catch (error) {\n      if (error.code === 'EXDEV' || error.code === 'EPERM') {\n        const sourceStat = yield lstat(source);\n        if (sourceStat.isDirectory()) {\n          const files = yield readdir(source);\n          yield Promise.all(files.map(file => moveFile(join(source, file), join(destination, file), options, false, symlinks)));\n        } else if (sourceStat.isSymbolicLink()) {\n          symlinks.push({\n            source,\n            destination\n          });\n        } else {\n          yield copyFile(source, destination);\n        }\n      } else {\n        throw error;\n      }\n    }\n    if (root) {\n      yield Promise.all(symlinks.map( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* ({\n          source: symSource,\n          destination: symDestination\n        }) {\n          let target = yield readlink(symSource);\n          // junction symlinks in windows will be absolute paths, so we need to\n          // make sure they point to the symlink destination\n          if (isAbsolute(target)) {\n            target = resolve(symDestination, relative(symSource, target));\n          }\n          // try to determine what the actual file is so we can create the correct\n          // type of symlink in windows\n          let targetStat = 'file';\n          try {\n            targetStat = yield stat(resolve(dirname(symSource), target));\n            if (targetStat.isDirectory()) {\n              targetStat = 'junction';\n            }\n          } catch {\n            // targetStat remains 'file'\n          }\n          yield symlink(target, symDestination, targetStat);\n        });\n        return function (_x4) {\n          return _ref3.apply(this, arguments);\n        };\n      }()));\n      yield rimraf(source);\n    }\n  });\n  return function moveFile(_x2, _x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nconst moveFileSync = (source, destination, options = {}, root = true, symlinks = []) => {\n  if (!source || !destination) {\n    throw new TypeError('`source` and `destination` file required');\n  }\n  options = {\n    overwrite: true,\n    ...options\n  };\n  if (!options.overwrite && pathExistsSync(destination)) {\n    throw new Error(`The destination file exists: ${destination}`);\n  }\n  mkdirp.sync(dirname(destination));\n  try {\n    renameSync(source, destination);\n  } catch (error) {\n    if (error.code === 'EXDEV' || error.code === 'EPERM') {\n      const sourceStat = lstatSync(source);\n      if (sourceStat.isDirectory()) {\n        const files = readdirSync(source);\n        for (const file of files) {\n          moveFileSync(join(source, file), join(destination, file), options, false, symlinks);\n        }\n      } else if (sourceStat.isSymbolicLink()) {\n        symlinks.push({\n          source,\n          destination\n        });\n      } else {\n        copyFileSync(source, destination);\n      }\n    } else {\n      throw error;\n    }\n  }\n  if (root) {\n    for (const {\n      source: symSource,\n      destination: symDestination\n    } of symlinks) {\n      let target = readlinkSync(symSource);\n      // junction symlinks in windows will be absolute paths, so we need to\n      // make sure they point to the symlink destination\n      if (isAbsolute(target)) {\n        target = resolve(symDestination, relative(symSource, target));\n      }\n      // try to determine what the actual file is so we can create the correct\n      // type of symlink in windows\n      let targetStat = 'file';\n      try {\n        targetStat = statSync(resolve(dirname(symSource), target));\n        if (targetStat.isDirectory()) {\n          targetStat = 'junction';\n        }\n      } catch {\n        // targetStat remains 'file'\n      }\n      symlinkSync(target, symDestination, targetStat);\n    }\n    rimrafSync(source);\n  }\n};\nmodule.exports = moveFile;\nmodule.exports.sync = moveFileSync;","map":{"version":3,"names":["dirname","join","resolve","relative","isAbsolute","require","rimraf_","promisify","access","access_","accessSync","copyFile","copyFile_","copyFileSync","readdir","readdir_","readdirSync","rename","rename_","renameSync","stat","stat_","statSync","lstat","lstat_","lstatSync","symlink","symlink_","symlinkSync","readlink","readlink_","readlinkSync","rimraf","rimrafSync","sync","mkdirp","pathExists","path","er","code","pathExistsSync","moveFile","source","destination","options","root","symlinks","TypeError","overwrite","Error","error","sourceStat","isDirectory","files","Promise","all","map","file","isSymbolicLink","push","symSource","symDestination","target","targetStat","moveFileSync","module","exports"],"sources":["I:/Angular/angular-blog/node_modules/@npmcli/move-file/lib/index.js"],"sourcesContent":["const { dirname, join, resolve, relative, isAbsolute } = require('path')\nconst rimraf_ = require('rimraf')\nconst { promisify } = require('util')\nconst {\n  access: access_,\n  accessSync,\n  copyFile: copyFile_,\n  copyFileSync,\n  readdir: readdir_,\n  readdirSync,\n  rename: rename_,\n  renameSync,\n  stat: stat_,\n  statSync,\n  lstat: lstat_,\n  lstatSync,\n  symlink: symlink_,\n  symlinkSync,\n  readlink: readlink_,\n  readlinkSync,\n} = require('fs')\n\nconst access = promisify(access_)\nconst copyFile = promisify(copyFile_)\nconst readdir = promisify(readdir_)\nconst rename = promisify(rename_)\nconst stat = promisify(stat_)\nconst lstat = promisify(lstat_)\nconst symlink = promisify(symlink_)\nconst readlink = promisify(readlink_)\nconst rimraf = promisify(rimraf_)\nconst rimrafSync = rimraf_.sync\n\nconst mkdirp = require('mkdirp')\n\nconst pathExists = async path => {\n  try {\n    await access(path)\n    return true\n  } catch (er) {\n    return er.code !== 'ENOENT'\n  }\n}\n\nconst pathExistsSync = path => {\n  try {\n    accessSync(path)\n    return true\n  } catch (er) {\n    return er.code !== 'ENOENT'\n  }\n}\n\nconst moveFile = async (source, destination, options = {}, root = true, symlinks = []) => {\n  if (!source || !destination) {\n    throw new TypeError('`source` and `destination` file required')\n  }\n\n  options = {\n    overwrite: true,\n    ...options,\n  }\n\n  if (!options.overwrite && await pathExists(destination)) {\n    throw new Error(`The destination file exists: ${destination}`)\n  }\n\n  await mkdirp(dirname(destination))\n\n  try {\n    await rename(source, destination)\n  } catch (error) {\n    if (error.code === 'EXDEV' || error.code === 'EPERM') {\n      const sourceStat = await lstat(source)\n      if (sourceStat.isDirectory()) {\n        const files = await readdir(source)\n        await Promise.all(files.map((file) =>\n          moveFile(join(source, file), join(destination, file), options, false, symlinks)\n        ))\n      } else if (sourceStat.isSymbolicLink()) {\n        symlinks.push({ source, destination })\n      } else {\n        await copyFile(source, destination)\n      }\n    } else {\n      throw error\n    }\n  }\n\n  if (root) {\n    await Promise.all(symlinks.map(async ({ source: symSource, destination: symDestination }) => {\n      let target = await readlink(symSource)\n      // junction symlinks in windows will be absolute paths, so we need to\n      // make sure they point to the symlink destination\n      if (isAbsolute(target)) {\n        target = resolve(symDestination, relative(symSource, target))\n      }\n      // try to determine what the actual file is so we can create the correct\n      // type of symlink in windows\n      let targetStat = 'file'\n      try {\n        targetStat = await stat(resolve(dirname(symSource), target))\n        if (targetStat.isDirectory()) {\n          targetStat = 'junction'\n        }\n      } catch {\n        // targetStat remains 'file'\n      }\n      await symlink(\n        target,\n        symDestination,\n        targetStat\n      )\n    }))\n    await rimraf(source)\n  }\n}\n\nconst moveFileSync = (source, destination, options = {}, root = true, symlinks = []) => {\n  if (!source || !destination) {\n    throw new TypeError('`source` and `destination` file required')\n  }\n\n  options = {\n    overwrite: true,\n    ...options,\n  }\n\n  if (!options.overwrite && pathExistsSync(destination)) {\n    throw new Error(`The destination file exists: ${destination}`)\n  }\n\n  mkdirp.sync(dirname(destination))\n\n  try {\n    renameSync(source, destination)\n  } catch (error) {\n    if (error.code === 'EXDEV' || error.code === 'EPERM') {\n      const sourceStat = lstatSync(source)\n      if (sourceStat.isDirectory()) {\n        const files = readdirSync(source)\n        for (const file of files) {\n          moveFileSync(join(source, file), join(destination, file), options, false, symlinks)\n        }\n      } else if (sourceStat.isSymbolicLink()) {\n        symlinks.push({ source, destination })\n      } else {\n        copyFileSync(source, destination)\n      }\n    } else {\n      throw error\n    }\n  }\n\n  if (root) {\n    for (const { source: symSource, destination: symDestination } of symlinks) {\n      let target = readlinkSync(symSource)\n      // junction symlinks in windows will be absolute paths, so we need to\n      // make sure they point to the symlink destination\n      if (isAbsolute(target)) {\n        target = resolve(symDestination, relative(symSource, target))\n      }\n      // try to determine what the actual file is so we can create the correct\n      // type of symlink in windows\n      let targetStat = 'file'\n      try {\n        targetStat = statSync(resolve(dirname(symSource), target))\n        if (targetStat.isDirectory()) {\n          targetStat = 'junction'\n        }\n      } catch {\n        // targetStat remains 'file'\n      }\n      symlinkSync(\n        target,\n        symDestination,\n        targetStat\n      )\n    }\n    rimrafSync(source)\n  }\n}\n\nmodule.exports = moveFile\nmodule.exports.sync = moveFileSync\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}