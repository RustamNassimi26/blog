{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _asyncToGenerator = require(\"I:/Angular/angular-blog/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _asyncIterator = require(\"I:/Angular/angular-blog/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\nvar _awaitAsyncGenerator = require(\"I:/Angular/angular-blog/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\nvar _wrapAsyncGenerator = require(\"I:/Angular/angular-blog/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GenerateCommandModule = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst command_module_1 = require(\"../../command-builder/command-module\");\nconst schematics_command_module_1 = require(\"../../command-builder/schematics-command-module\");\nconst command_1 = require(\"../../command-builder/utilities/command\");\nclass GenerateCommandModule extends schematics_command_module_1.SchematicsCommandModule {\n  constructor() {\n    super(...arguments);\n    this.command = 'generate';\n    this.aliases = 'g';\n    this.describe = 'Generates and/or modifies files based on a schematic.';\n  }\n  builder(argv) {\n    var _superprop_getBuilder = () => super.builder,\n      _this2 = this;\n    return _asyncToGenerator(function* () {\n      let localYargs = (yield _superprop_getBuilder().call(_this2, argv)).command({\n        command: '$0 <schematic>',\n        describe: 'Run the provided schematic.',\n        builder: localYargs => localYargs.positional('schematic', {\n          describe: 'The [collection:schematic] to run.',\n          type: 'string',\n          demandOption: true\n        }).strict(),\n        handler: options => _this2.handler(options)\n      });\n      for (const [schematicName, collectionName] of yield _this2.getSchematicsToRegister()) {\n        const workflow = _this2.getOrCreateWorkflowForBuilder(collectionName);\n        const collection = workflow.engine.createCollection(collectionName);\n        const {\n          description: {\n            schemaJson,\n            aliases: schematicAliases,\n            hidden: schematicHidden,\n            description: schematicDescription\n          }\n        } = collection.createSchematic(schematicName, true);\n        if (!schemaJson) {\n          continue;\n        }\n        const {\n          'x-deprecated': xDeprecated,\n          description = schematicDescription,\n          aliases = schematicAliases,\n          hidden = schematicHidden\n        } = schemaJson;\n        const options = yield _this2.getSchematicOptions(collection, schematicName, workflow);\n        localYargs = localYargs.command({\n          command: yield _this2.generateCommandString(collectionName, schematicName, options),\n          // When 'describe' is set to false, it results in a hidden command.\n          describe: hidden === true ? false : typeof description === 'string' ? description : '',\n          deprecated: xDeprecated === true || typeof xDeprecated === 'string' ? xDeprecated : false,\n          aliases: Array.isArray(aliases) ? aliases : undefined,\n          builder: localYargs => _this2.addSchemaOptionsToCommand(localYargs, options).strict(),\n          handler: options => _this2.handler({\n            ...options,\n            schematic: `${collectionName}:${schematicName}`\n          })\n        });\n      }\n      return localYargs.demandCommand(1, command_1.demandCommandFailureMessage);\n    })();\n  }\n  run(options) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        dryRun,\n        schematic,\n        defaults,\n        force,\n        interactive,\n        ...schematicOptions\n      } = options;\n      const [collectionName, schematicName] = _this3.parseSchematicInfo(schematic);\n      if (!collectionName || !schematicName) {\n        throw new command_module_1.CommandModuleError('A collection and schematic is required during execution.');\n      }\n      return _this3.runSchematic({\n        collectionName,\n        schematicName,\n        schematicOptions,\n        executionOptions: {\n          dryRun,\n          defaults,\n          force,\n          interactive\n        }\n      });\n    })();\n  }\n  getCollectionNames() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const [collectionName] = _this4.parseSchematicInfo(\n      // positional = [generate, component] or [generate]\n      _this4.context.args.positional[1]);\n      return collectionName ? [collectionName] : [...(yield _this4.getSchematicCollections())];\n    })();\n  }\n  /**\n   * Generate a command string to be passed to the command builder.\n   *\n   * @example `component [name]` or `@schematics/angular:component [name]`.\n   */\n  generateCommandString(collectionName, schematicName, options) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const [collectionNameFromArgs] = _this5.parseSchematicInfo(\n      // positional = [generate, component] or [generate]\n      _this5.context.args.positional[1]);\n      const dasherizedSchematicName = core_1.strings.dasherize(schematicName);\n      const schematicCollectionsFromConfig = yield _this5.getSchematicCollections();\n      const collectionNames = yield _this5.getCollectionNames();\n      // Only add the collection name as part of the command when it's not a known\n      // schematics collection or when it has been provided via the CLI.\n      // Ex:`ng generate @schematics/angular:component`\n      const commandName = !!collectionNameFromArgs || !collectionNames.some(c => schematicCollectionsFromConfig.has(c)) ? collectionName + ':' + dasherizedSchematicName : dasherizedSchematicName;\n      const positionalArgs = options.filter(o => o.positional !== undefined).map(o => {\n        const label = `${core_1.strings.dasherize(o.name)}${o.type === 'array' ? ' ..' : ''}`;\n        return o.required ? `<${label}>` : `[${label}]`;\n      }).join(' ');\n      return `${commandName}${positionalArgs ? ' ' + positionalArgs : ''}`;\n    })();\n  }\n  /**\n   * Get schematics that can to be registered as subcommands.\n   */\n  getSchematics() {\n    var _this = this;\n    return _wrapAsyncGenerator(function* () {\n      const seenNames = new Set();\n      for (const collectionName of yield _awaitAsyncGenerator(_this.getCollectionNames())) {\n        const workflow = _this.getOrCreateWorkflowForBuilder(collectionName);\n        const collection = workflow.engine.createCollection(collectionName);\n        for (const schematicName of collection.listSchematicNames(true /** includeHidden */)) {\n          // If a schematic with this same name is already registered skip.\n          if (!seenNames.has(schematicName)) {\n            seenNames.add(schematicName);\n            yield {\n              schematicName,\n              collectionName\n            };\n          }\n        }\n      }\n    })();\n  }\n  /**\n   * Get schematics that should to be registered as subcommands.\n   *\n   * @returns a sorted list of schematic that needs to be registered as subcommands.\n   */\n  getSchematicsToRegister() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const schematicsToRegister = [];\n      const [, schematicNameFromArgs] = _this6.parseSchematicInfo(\n      // positional = [generate, component] or [generate]\n      _this6.context.args.positional[1]);\n      var _iteratorAbruptCompletion = false;\n      var _didIteratorError = false;\n      var _iteratorError;\n      try {\n        for (var _iterator = _asyncIterator(_this6.getSchematics()), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {\n          const {\n            schematicName,\n            collectionName\n          } = _step.value;\n          {\n            if (schematicName === schematicNameFromArgs) {\n              return [[schematicName, collectionName]];\n            }\n            schematicsToRegister.push([schematicName, collectionName]);\n          }\n        }\n        // Didn't find the schematic or no schematic name was provided Ex: `ng generate --help`.\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion && _iterator.return != null) {\n            yield _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n      return schematicsToRegister.sort(([nameA], [nameB]) => nameA.localeCompare(nameB, undefined, {\n        sensitivity: 'accent'\n      }));\n    })();\n  }\n}\nexports.GenerateCommandModule = GenerateCommandModule;","map":{"version":3,"names":["Object","defineProperty","exports","value","GenerateCommandModule","core_1","require","command_module_1","schematics_command_module_1","command_1","SchematicsCommandModule","constructor","arguments","command","aliases","describe","builder","argv","localYargs","positional","type","demandOption","strict","handler","options","schematicName","collectionName","getSchematicsToRegister","workflow","getOrCreateWorkflowForBuilder","collection","engine","createCollection","description","schemaJson","schematicAliases","hidden","schematicHidden","schematicDescription","createSchematic","xDeprecated","getSchematicOptions","generateCommandString","deprecated","Array","isArray","undefined","addSchemaOptionsToCommand","schematic","demandCommand","demandCommandFailureMessage","run","dryRun","defaults","force","interactive","schematicOptions","parseSchematicInfo","CommandModuleError","runSchematic","executionOptions","getCollectionNames","context","args","getSchematicCollections","collectionNameFromArgs","dasherizedSchematicName","strings","dasherize","schematicCollectionsFromConfig","collectionNames","commandName","some","c","has","positionalArgs","filter","o","map","label","name","required","join","getSchematics","seenNames","Set","listSchematicNames","add","schematicsToRegister","schematicNameFromArgs","push","sort","nameA","nameB","localeCompare","sensitivity"],"sources":["I:/Angular/angular-blog/node_modules/@angular/cli/src/commands/generate/cli.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GenerateCommandModule = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst command_module_1 = require(\"../../command-builder/command-module\");\nconst schematics_command_module_1 = require(\"../../command-builder/schematics-command-module\");\nconst command_1 = require(\"../../command-builder/utilities/command\");\nclass GenerateCommandModule extends schematics_command_module_1.SchematicsCommandModule {\n    constructor() {\n        super(...arguments);\n        this.command = 'generate';\n        this.aliases = 'g';\n        this.describe = 'Generates and/or modifies files based on a schematic.';\n    }\n    async builder(argv) {\n        let localYargs = (await super.builder(argv)).command({\n            command: '$0 <schematic>',\n            describe: 'Run the provided schematic.',\n            builder: (localYargs) => localYargs\n                .positional('schematic', {\n                describe: 'The [collection:schematic] to run.',\n                type: 'string',\n                demandOption: true,\n            })\n                .strict(),\n            handler: (options) => this.handler(options),\n        });\n        for (const [schematicName, collectionName] of await this.getSchematicsToRegister()) {\n            const workflow = this.getOrCreateWorkflowForBuilder(collectionName);\n            const collection = workflow.engine.createCollection(collectionName);\n            const { description: { schemaJson, aliases: schematicAliases, hidden: schematicHidden, description: schematicDescription, }, } = collection.createSchematic(schematicName, true);\n            if (!schemaJson) {\n                continue;\n            }\n            const { 'x-deprecated': xDeprecated, description = schematicDescription, aliases = schematicAliases, hidden = schematicHidden, } = schemaJson;\n            const options = await this.getSchematicOptions(collection, schematicName, workflow);\n            localYargs = localYargs.command({\n                command: await this.generateCommandString(collectionName, schematicName, options),\n                // When 'describe' is set to false, it results in a hidden command.\n                describe: hidden === true ? false : typeof description === 'string' ? description : '',\n                deprecated: xDeprecated === true || typeof xDeprecated === 'string' ? xDeprecated : false,\n                aliases: Array.isArray(aliases) ? aliases : undefined,\n                builder: (localYargs) => this.addSchemaOptionsToCommand(localYargs, options).strict(),\n                handler: (options) => this.handler({ ...options, schematic: `${collectionName}:${schematicName}` }),\n            });\n        }\n        return localYargs.demandCommand(1, command_1.demandCommandFailureMessage);\n    }\n    async run(options) {\n        const { dryRun, schematic, defaults, force, interactive, ...schematicOptions } = options;\n        const [collectionName, schematicName] = this.parseSchematicInfo(schematic);\n        if (!collectionName || !schematicName) {\n            throw new command_module_1.CommandModuleError('A collection and schematic is required during execution.');\n        }\n        return this.runSchematic({\n            collectionName,\n            schematicName,\n            schematicOptions,\n            executionOptions: {\n                dryRun,\n                defaults,\n                force,\n                interactive,\n            },\n        });\n    }\n    async getCollectionNames() {\n        const [collectionName] = this.parseSchematicInfo(\n        // positional = [generate, component] or [generate]\n        this.context.args.positional[1]);\n        return collectionName ? [collectionName] : [...(await this.getSchematicCollections())];\n    }\n    /**\n     * Generate a command string to be passed to the command builder.\n     *\n     * @example `component [name]` or `@schematics/angular:component [name]`.\n     */\n    async generateCommandString(collectionName, schematicName, options) {\n        const [collectionNameFromArgs] = this.parseSchematicInfo(\n        // positional = [generate, component] or [generate]\n        this.context.args.positional[1]);\n        const dasherizedSchematicName = core_1.strings.dasherize(schematicName);\n        const schematicCollectionsFromConfig = await this.getSchematicCollections();\n        const collectionNames = await this.getCollectionNames();\n        // Only add the collection name as part of the command when it's not a known\n        // schematics collection or when it has been provided via the CLI.\n        // Ex:`ng generate @schematics/angular:component`\n        const commandName = !!collectionNameFromArgs ||\n            !collectionNames.some((c) => schematicCollectionsFromConfig.has(c))\n            ? collectionName + ':' + dasherizedSchematicName\n            : dasherizedSchematicName;\n        const positionalArgs = options\n            .filter((o) => o.positional !== undefined)\n            .map((o) => {\n            const label = `${core_1.strings.dasherize(o.name)}${o.type === 'array' ? ' ..' : ''}`;\n            return o.required ? `<${label}>` : `[${label}]`;\n        })\n            .join(' ');\n        return `${commandName}${positionalArgs ? ' ' + positionalArgs : ''}`;\n    }\n    /**\n     * Get schematics that can to be registered as subcommands.\n     */\n    async *getSchematics() {\n        const seenNames = new Set();\n        for (const collectionName of await this.getCollectionNames()) {\n            const workflow = this.getOrCreateWorkflowForBuilder(collectionName);\n            const collection = workflow.engine.createCollection(collectionName);\n            for (const schematicName of collection.listSchematicNames(true /** includeHidden */)) {\n                // If a schematic with this same name is already registered skip.\n                if (!seenNames.has(schematicName)) {\n                    seenNames.add(schematicName);\n                    yield { schematicName, collectionName };\n                }\n            }\n        }\n    }\n    /**\n     * Get schematics that should to be registered as subcommands.\n     *\n     * @returns a sorted list of schematic that needs to be registered as subcommands.\n     */\n    async getSchematicsToRegister() {\n        const schematicsToRegister = [];\n        const [, schematicNameFromArgs] = this.parseSchematicInfo(\n        // positional = [generate, component] or [generate]\n        this.context.args.positional[1]);\n        for await (const { schematicName, collectionName } of this.getSchematics()) {\n            if (schematicName === schematicNameFromArgs) {\n                return [[schematicName, collectionName]];\n            }\n            schematicsToRegister.push([schematicName, collectionName]);\n        }\n        // Didn't find the schematic or no schematic name was provided Ex: `ng generate --help`.\n        return schematicsToRegister.sort(([nameA], [nameB]) => nameA.localeCompare(nameB, undefined, { sensitivity: 'accent' }));\n    }\n}\nexports.GenerateCommandModule = GenerateCommandModule;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}