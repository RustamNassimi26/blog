{"ast":null,"code":"'use strict';\n\nmodule.exports = npa;\nmodule.exports.resolve = resolve;\nmodule.exports.Result = Result;\nconst url = require('url');\nconst HostedGit = require('hosted-git-info');\nconst semver = require('semver');\nconst path = global.FAKE_WINDOWS ? require('path').win32 : require('path');\nconst validatePackageName = require('validate-npm-package-name');\nconst {\n  homedir\n} = require('os');\nconst log = require('proc-log');\nconst isWindows = process.platform === 'win32' || global.FAKE_WINDOWS;\nconst hasSlashes = isWindows ? /\\\\|[/]/ : /[/]/;\nconst isURL = /^(?:git[+])?[a-z]+:/i;\nconst isGit = /^[^@]+@[^:.]+\\.[^:]+:.+$/i;\nconst isFilename = /[.](?:tgz|tar.gz|tar)$/i;\nfunction npa(arg, where) {\n  let name;\n  let spec;\n  if (typeof arg === 'object') {\n    if (arg instanceof Result && (!where || where === arg.where)) {\n      return arg;\n    } else if (arg.name && arg.rawSpec) {\n      return npa.resolve(arg.name, arg.rawSpec, where || arg.where);\n    } else {\n      return npa(arg.raw, where || arg.where);\n    }\n  }\n  const nameEndsAt = arg[0] === '@' ? arg.slice(1).indexOf('@') + 1 : arg.indexOf('@');\n  const namePart = nameEndsAt > 0 ? arg.slice(0, nameEndsAt) : arg;\n  if (isURL.test(arg)) {\n    spec = arg;\n  } else if (isGit.test(arg)) {\n    spec = `git+ssh://${arg}`;\n  } else if (namePart[0] !== '@' && (hasSlashes.test(namePart) || isFilename.test(namePart))) {\n    spec = arg;\n  } else if (nameEndsAt > 0) {\n    name = namePart;\n    spec = arg.slice(nameEndsAt + 1);\n  } else {\n    const valid = validatePackageName(arg);\n    if (valid.validForOldPackages) {\n      name = arg;\n    } else {\n      spec = arg;\n    }\n  }\n  return resolve(name, spec, where, arg);\n}\nconst isFilespec = isWindows ? /^(?:[.]|~[/]|[/\\\\]|[a-zA-Z]:)/ : /^(?:[.]|~[/]|[/]|[a-zA-Z]:)/;\nfunction resolve(name, spec, where, arg) {\n  const res = new Result({\n    raw: arg,\n    name: name,\n    rawSpec: spec,\n    fromArgument: arg != null\n  });\n  if (name) {\n    res.setName(name);\n  }\n  if (spec && (isFilespec.test(spec) || /^file:/i.test(spec))) {\n    return fromFile(res, where);\n  } else if (spec && /^npm:/i.test(spec)) {\n    return fromAlias(res, where);\n  }\n  const hosted = HostedGit.fromUrl(spec, {\n    noGitPlus: true,\n    noCommittish: true\n  });\n  if (hosted) {\n    return fromHostedGit(res, hosted);\n  } else if (spec && isURL.test(spec)) {\n    return fromURL(res);\n  } else if (spec && (hasSlashes.test(spec) || isFilename.test(spec))) {\n    return fromFile(res, where);\n  } else {\n    return fromRegistry(res);\n  }\n}\nfunction invalidPackageName(name, valid, raw) {\n  // eslint-disable-next-line max-len\n  const err = new Error(`Invalid package name \"${name}\" of package \"${raw}\": ${valid.errors.join('; ')}.`);\n  err.code = 'EINVALIDPACKAGENAME';\n  return err;\n}\nfunction invalidTagName(name, raw) {\n  // eslint-disable-next-line max-len\n  const err = new Error(`Invalid tag name \"${name}\" of package \"${raw}\": Tags may not have any characters that encodeURIComponent encodes.`);\n  err.code = 'EINVALIDTAGNAME';\n  return err;\n}\nfunction Result(opts) {\n  this.type = opts.type;\n  this.registry = opts.registry;\n  this.where = opts.where;\n  if (opts.raw == null) {\n    this.raw = opts.name ? opts.name + '@' + opts.rawSpec : opts.rawSpec;\n  } else {\n    this.raw = opts.raw;\n  }\n  this.name = undefined;\n  this.escapedName = undefined;\n  this.scope = undefined;\n  this.rawSpec = opts.rawSpec == null ? '' : opts.rawSpec;\n  this.saveSpec = opts.saveSpec;\n  this.fetchSpec = opts.fetchSpec;\n  if (opts.name) {\n    this.setName(opts.name);\n  }\n  this.gitRange = opts.gitRange;\n  this.gitCommittish = opts.gitCommittish;\n  this.gitSubdir = opts.gitSubdir;\n  this.hosted = opts.hosted;\n}\nResult.prototype.setName = function (name) {\n  const valid = validatePackageName(name);\n  if (!valid.validForOldPackages) {\n    throw invalidPackageName(name, valid, this.raw);\n  }\n  this.name = name;\n  this.scope = name[0] === '@' ? name.slice(0, name.indexOf('/')) : undefined;\n  // scoped packages in couch must have slash url-encoded, e.g. @foo%2Fbar\n  this.escapedName = name.replace('/', '%2f');\n  return this;\n};\nResult.prototype.toString = function () {\n  const full = [];\n  if (this.name != null && this.name !== '') {\n    full.push(this.name);\n  }\n  const spec = this.saveSpec || this.fetchSpec || this.rawSpec;\n  if (spec != null && spec !== '') {\n    full.push(spec);\n  }\n  return full.length ? full.join('@') : this.raw;\n};\nResult.prototype.toJSON = function () {\n  const result = Object.assign({}, this);\n  delete result.hosted;\n  return result;\n};\nfunction setGitCommittish(res, committish) {\n  if (!committish) {\n    res.gitCommittish = null;\n    return res;\n  }\n\n  // for each :: separated item:\n  for (const part of committish.split('::')) {\n    // if the item has no : the n it is a commit-ish\n    if (!part.includes(':')) {\n      if (res.gitRange) {\n        throw new Error('cannot override existing semver range with a committish');\n      }\n      if (res.gitCommittish) {\n        throw new Error('cannot override existing committish with a second committish');\n      }\n      res.gitCommittish = part;\n      continue;\n    }\n    // split on name:value\n    const [name, value] = part.split(':');\n    // if name is semver do semver lookup of ref or tag\n    if (name === 'semver') {\n      if (res.gitCommittish) {\n        throw new Error('cannot override existing committish with a semver range');\n      }\n      if (res.gitRange) {\n        throw new Error('cannot override existing semver range with a second semver range');\n      }\n      res.gitRange = decodeURIComponent(value);\n      continue;\n    }\n    if (name === 'path') {\n      if (res.gitSubdir) {\n        throw new Error('cannot override existing path with a second path');\n      }\n      res.gitSubdir = `/${value}`;\n      continue;\n    }\n    log.warn('npm-package-arg', `ignoring unknown key \"${name}\"`);\n  }\n  return res;\n}\nfunction fromFile(res, where) {\n  if (!where) {\n    where = process.cwd();\n  }\n  res.type = isFilename.test(res.rawSpec) ? 'file' : 'directory';\n  res.where = where;\n\n  // always put the '/' on where when resolving urls, or else\n  // file:foo from /path/to/bar goes to /path/to/foo, when we want\n  // it to be /path/to/bar/foo\n\n  let specUrl;\n  let resolvedUrl;\n  const prefix = !/^file:/.test(res.rawSpec) ? 'file:' : '';\n  const rawWithPrefix = prefix + res.rawSpec;\n  let rawNoPrefix = rawWithPrefix.replace(/^file:/, '');\n  try {\n    resolvedUrl = new url.URL(rawWithPrefix, `file://${path.resolve(where)}/`);\n    specUrl = new url.URL(rawWithPrefix);\n  } catch (originalError) {\n    const er = new Error('Invalid file: URL, must comply with RFC 8909');\n    throw Object.assign(er, {\n      raw: res.rawSpec,\n      spec: res,\n      where,\n      originalError\n    });\n  }\n\n  // environment switch for testing\n  if (process.env.NPM_PACKAGE_ARG_8909_STRICT !== '1') {\n    // XXX backwards compatibility lack of compliance with 8909\n    // Remove when we want a breaking change to come into RFC compliance.\n    if (resolvedUrl.host && resolvedUrl.host !== 'localhost') {\n      const rawSpec = res.rawSpec.replace(/^file:\\/\\//, 'file:///');\n      resolvedUrl = new url.URL(rawSpec, `file://${path.resolve(where)}/`);\n      specUrl = new url.URL(rawSpec);\n      rawNoPrefix = rawSpec.replace(/^file:/, '');\n    }\n    // turn file:/../foo into file:../foo\n    // for 1, 2 or 3 leading slashes since we attempted\n    // in the previous step to make it a file protocol url with a leading slash\n    if (/^\\/{1,3}\\.\\.?(\\/|$)/.test(rawNoPrefix)) {\n      const rawSpec = res.rawSpec.replace(/^file:\\/{1,3}/, 'file:');\n      resolvedUrl = new url.URL(rawSpec, `file://${path.resolve(where)}/`);\n      specUrl = new url.URL(rawSpec);\n      rawNoPrefix = rawSpec.replace(/^file:/, '');\n    }\n    // XXX end 8909 violation backwards compatibility section\n  }\n\n  // file:foo - relative url to ./foo\n  // file:/foo - absolute path /foo\n  // file:///foo - absolute path to /foo, no authority host\n  // file://localhost/foo - absolute path to /foo, on localhost\n  // file://foo - absolute path to / on foo host (error!)\n  if (resolvedUrl.host && resolvedUrl.host !== 'localhost') {\n    const msg = `Invalid file: URL, must be absolute if // present`;\n    throw Object.assign(new Error(msg), {\n      raw: res.rawSpec,\n      parsed: resolvedUrl\n    });\n  }\n\n  // turn /C:/blah into just C:/blah on windows\n  let specPath = decodeURIComponent(specUrl.pathname);\n  let resolvedPath = decodeURIComponent(resolvedUrl.pathname);\n  if (isWindows) {\n    specPath = specPath.replace(/^\\/+([a-z]:\\/)/i, '$1');\n    resolvedPath = resolvedPath.replace(/^\\/+([a-z]:\\/)/i, '$1');\n  }\n\n  // replace ~ with homedir, but keep the ~ in the saveSpec\n  // otherwise, make it relative to where param\n  if (/^\\/~(\\/|$)/.test(specPath)) {\n    res.saveSpec = `file:${specPath.substr(1)}`;\n    resolvedPath = path.resolve(homedir(), specPath.substr(3));\n  } else if (!path.isAbsolute(rawNoPrefix)) {\n    res.saveSpec = `file:${path.relative(where, resolvedPath)}`;\n  } else {\n    res.saveSpec = `file:${path.resolve(resolvedPath)}`;\n  }\n  res.fetchSpec = path.resolve(where, resolvedPath);\n  return res;\n}\nfunction fromHostedGit(res, hosted) {\n  res.type = 'git';\n  res.hosted = hosted;\n  res.saveSpec = hosted.toString({\n    noGitPlus: false,\n    noCommittish: false\n  });\n  res.fetchSpec = hosted.getDefaultRepresentation() === 'shortcut' ? null : hosted.toString();\n  return setGitCommittish(res, hosted.committish);\n}\nfunction unsupportedURLType(protocol, spec) {\n  const err = new Error(`Unsupported URL Type \"${protocol}\": ${spec}`);\n  err.code = 'EUNSUPPORTEDPROTOCOL';\n  return err;\n}\nfunction matchGitScp(spec) {\n  // git ssh specifiers are overloaded to also use scp-style git\n  // specifiers, so we have to parse those out and treat them special.\n  // They are NOT true URIs, so we can't hand them to `url.parse`.\n  //\n  // This regex looks for things that look like:\n  // git+ssh://git@my.custom.git.com:username/project.git#deadbeef\n  //\n  // ...and various combinations. The username in the beginning is *required*.\n  const matched = spec.match(/^git\\+ssh:\\/\\/([^:#]+:[^#]+(?:\\.git)?)(?:#(.*))?$/i);\n  return matched && !matched[1].match(/:[0-9]+\\/?.*$/i) && {\n    fetchSpec: matched[1],\n    gitCommittish: matched[2] == null ? null : matched[2]\n  };\n}\nfunction fromURL(res) {\n  // eslint-disable-next-line node/no-deprecated-api\n  const urlparse = url.parse(res.rawSpec);\n  res.saveSpec = res.rawSpec;\n  // check the protocol, and then see if it's git or not\n  switch (urlparse.protocol) {\n    case 'git:':\n    case 'git+http:':\n    case 'git+https:':\n    case 'git+rsync:':\n    case 'git+ftp:':\n    case 'git+file:':\n    case 'git+ssh:':\n      {\n        res.type = 'git';\n        const match = urlparse.protocol === 'git+ssh:' ? matchGitScp(res.rawSpec) : null;\n        if (match) {\n          setGitCommittish(res, match.gitCommittish);\n          res.fetchSpec = match.fetchSpec;\n        } else {\n          setGitCommittish(res, urlparse.hash != null ? urlparse.hash.slice(1) : '');\n          urlparse.protocol = urlparse.protocol.replace(/^git[+]/, '');\n          if (urlparse.protocol === 'file:' && /^git\\+file:\\/\\/[a-z]:/i.test(res.rawSpec)) {\n            // keep the drive letter : on windows file paths\n            urlparse.host += ':';\n            urlparse.hostname += ':';\n          }\n          delete urlparse.hash;\n          res.fetchSpec = url.format(urlparse);\n        }\n        break;\n      }\n    case 'http:':\n    case 'https:':\n      res.type = 'remote';\n      res.fetchSpec = res.saveSpec;\n      break;\n    default:\n      throw unsupportedURLType(urlparse.protocol, res.rawSpec);\n  }\n  return res;\n}\nfunction fromAlias(res, where) {\n  const subSpec = npa(res.rawSpec.substr(4), where);\n  if (subSpec.type === 'alias') {\n    throw new Error('nested aliases not supported');\n  }\n  if (!subSpec.registry) {\n    throw new Error('aliases only work for registry deps');\n  }\n  res.subSpec = subSpec;\n  res.registry = true;\n  res.type = 'alias';\n  res.saveSpec = null;\n  res.fetchSpec = null;\n  return res;\n}\nfunction fromRegistry(res) {\n  res.registry = true;\n  const spec = res.rawSpec === '' ? 'latest' : res.rawSpec.trim();\n  // no save spec for registry components as we save based on the fetched\n  // version, not on the argument so this can't compute that.\n  res.saveSpec = null;\n  res.fetchSpec = spec;\n  const version = semver.valid(spec, true);\n  const range = semver.validRange(spec, true);\n  if (version) {\n    res.type = 'version';\n  } else if (range) {\n    res.type = 'range';\n  } else {\n    if (encodeURIComponent(spec) !== spec) {\n      throw invalidTagName(spec, res.raw);\n    }\n    res.type = 'tag';\n  }\n  return res;\n}","map":{"version":3,"names":["module","exports","npa","resolve","Result","url","require","HostedGit","semver","path","global","FAKE_WINDOWS","win32","validatePackageName","homedir","log","isWindows","process","platform","hasSlashes","isURL","isGit","isFilename","arg","where","name","spec","rawSpec","raw","nameEndsAt","slice","indexOf","namePart","test","valid","validForOldPackages","isFilespec","res","fromArgument","setName","fromFile","fromAlias","hosted","fromUrl","noGitPlus","noCommittish","fromHostedGit","fromURL","fromRegistry","invalidPackageName","err","Error","errors","join","code","invalidTagName","opts","type","registry","undefined","escapedName","scope","saveSpec","fetchSpec","gitRange","gitCommittish","gitSubdir","prototype","replace","toString","full","push","length","toJSON","result","Object","assign","setGitCommittish","committish","part","split","includes","value","decodeURIComponent","warn","cwd","specUrl","resolvedUrl","prefix","rawWithPrefix","rawNoPrefix","URL","originalError","er","env","NPM_PACKAGE_ARG_8909_STRICT","host","msg","parsed","specPath","pathname","resolvedPath","substr","isAbsolute","relative","getDefaultRepresentation","unsupportedURLType","protocol","matchGitScp","matched","match","urlparse","parse","hash","hostname","format","subSpec","trim","version","range","validRange","encodeURIComponent"],"sources":["I:/Angular/angular-blog/node_modules/npm-package-arg/lib/npa.js"],"sourcesContent":["'use strict'\nmodule.exports = npa\nmodule.exports.resolve = resolve\nmodule.exports.Result = Result\n\nconst url = require('url')\nconst HostedGit = require('hosted-git-info')\nconst semver = require('semver')\nconst path = global.FAKE_WINDOWS ? require('path').win32 : require('path')\nconst validatePackageName = require('validate-npm-package-name')\nconst { homedir } = require('os')\nconst log = require('proc-log')\n\nconst isWindows = process.platform === 'win32' || global.FAKE_WINDOWS\nconst hasSlashes = isWindows ? /\\\\|[/]/ : /[/]/\nconst isURL = /^(?:git[+])?[a-z]+:/i\nconst isGit = /^[^@]+@[^:.]+\\.[^:]+:.+$/i\nconst isFilename = /[.](?:tgz|tar.gz|tar)$/i\n\nfunction npa (arg, where) {\n  let name\n  let spec\n  if (typeof arg === 'object') {\n    if (arg instanceof Result && (!where || where === arg.where)) {\n      return arg\n    } else if (arg.name && arg.rawSpec) {\n      return npa.resolve(arg.name, arg.rawSpec, where || arg.where)\n    } else {\n      return npa(arg.raw, where || arg.where)\n    }\n  }\n  const nameEndsAt = arg[0] === '@' ? arg.slice(1).indexOf('@') + 1 : arg.indexOf('@')\n  const namePart = nameEndsAt > 0 ? arg.slice(0, nameEndsAt) : arg\n  if (isURL.test(arg)) {\n    spec = arg\n  } else if (isGit.test(arg)) {\n    spec = `git+ssh://${arg}`\n  } else if (namePart[0] !== '@' && (hasSlashes.test(namePart) || isFilename.test(namePart))) {\n    spec = arg\n  } else if (nameEndsAt > 0) {\n    name = namePart\n    spec = arg.slice(nameEndsAt + 1)\n  } else {\n    const valid = validatePackageName(arg)\n    if (valid.validForOldPackages) {\n      name = arg\n    } else {\n      spec = arg\n    }\n  }\n  return resolve(name, spec, where, arg)\n}\n\nconst isFilespec = isWindows ? /^(?:[.]|~[/]|[/\\\\]|[a-zA-Z]:)/ : /^(?:[.]|~[/]|[/]|[a-zA-Z]:)/\n\nfunction resolve (name, spec, where, arg) {\n  const res = new Result({\n    raw: arg,\n    name: name,\n    rawSpec: spec,\n    fromArgument: arg != null,\n  })\n\n  if (name) {\n    res.setName(name)\n  }\n\n  if (spec && (isFilespec.test(spec) || /^file:/i.test(spec))) {\n    return fromFile(res, where)\n  } else if (spec && /^npm:/i.test(spec)) {\n    return fromAlias(res, where)\n  }\n\n  const hosted = HostedGit.fromUrl(spec, {\n    noGitPlus: true,\n    noCommittish: true,\n  })\n  if (hosted) {\n    return fromHostedGit(res, hosted)\n  } else if (spec && isURL.test(spec)) {\n    return fromURL(res)\n  } else if (spec && (hasSlashes.test(spec) || isFilename.test(spec))) {\n    return fromFile(res, where)\n  } else {\n    return fromRegistry(res)\n  }\n}\n\nfunction invalidPackageName (name, valid, raw) {\n  // eslint-disable-next-line max-len\n  const err = new Error(`Invalid package name \"${name}\" of package \"${raw}\": ${valid.errors.join('; ')}.`)\n  err.code = 'EINVALIDPACKAGENAME'\n  return err\n}\n\nfunction invalidTagName (name, raw) {\n  // eslint-disable-next-line max-len\n  const err = new Error(`Invalid tag name \"${name}\" of package \"${raw}\": Tags may not have any characters that encodeURIComponent encodes.`)\n  err.code = 'EINVALIDTAGNAME'\n  return err\n}\n\nfunction Result (opts) {\n  this.type = opts.type\n  this.registry = opts.registry\n  this.where = opts.where\n  if (opts.raw == null) {\n    this.raw = opts.name ? opts.name + '@' + opts.rawSpec : opts.rawSpec\n  } else {\n    this.raw = opts.raw\n  }\n\n  this.name = undefined\n  this.escapedName = undefined\n  this.scope = undefined\n  this.rawSpec = opts.rawSpec == null ? '' : opts.rawSpec\n  this.saveSpec = opts.saveSpec\n  this.fetchSpec = opts.fetchSpec\n  if (opts.name) {\n    this.setName(opts.name)\n  }\n  this.gitRange = opts.gitRange\n  this.gitCommittish = opts.gitCommittish\n  this.gitSubdir = opts.gitSubdir\n  this.hosted = opts.hosted\n}\n\nResult.prototype.setName = function (name) {\n  const valid = validatePackageName(name)\n  if (!valid.validForOldPackages) {\n    throw invalidPackageName(name, valid, this.raw)\n  }\n\n  this.name = name\n  this.scope = name[0] === '@' ? name.slice(0, name.indexOf('/')) : undefined\n  // scoped packages in couch must have slash url-encoded, e.g. @foo%2Fbar\n  this.escapedName = name.replace('/', '%2f')\n  return this\n}\n\nResult.prototype.toString = function () {\n  const full = []\n  if (this.name != null && this.name !== '') {\n    full.push(this.name)\n  }\n  const spec = this.saveSpec || this.fetchSpec || this.rawSpec\n  if (spec != null && spec !== '') {\n    full.push(spec)\n  }\n  return full.length ? full.join('@') : this.raw\n}\n\nResult.prototype.toJSON = function () {\n  const result = Object.assign({}, this)\n  delete result.hosted\n  return result\n}\n\nfunction setGitCommittish (res, committish) {\n  if (!committish) {\n    res.gitCommittish = null\n    return res\n  }\n\n  // for each :: separated item:\n  for (const part of committish.split('::')) {\n    // if the item has no : the n it is a commit-ish\n    if (!part.includes(':')) {\n      if (res.gitRange) {\n        throw new Error('cannot override existing semver range with a committish')\n      }\n      if (res.gitCommittish) {\n        throw new Error('cannot override existing committish with a second committish')\n      }\n      res.gitCommittish = part\n      continue\n    }\n    // split on name:value\n    const [name, value] = part.split(':')\n    // if name is semver do semver lookup of ref or tag\n    if (name === 'semver') {\n      if (res.gitCommittish) {\n        throw new Error('cannot override existing committish with a semver range')\n      }\n      if (res.gitRange) {\n        throw new Error('cannot override existing semver range with a second semver range')\n      }\n      res.gitRange = decodeURIComponent(value)\n      continue\n    }\n    if (name === 'path') {\n      if (res.gitSubdir) {\n        throw new Error('cannot override existing path with a second path')\n      }\n      res.gitSubdir = `/${value}`\n      continue\n    }\n    log.warn('npm-package-arg', `ignoring unknown key \"${name}\"`)\n  }\n\n  return res\n}\n\nfunction fromFile (res, where) {\n  if (!where) {\n    where = process.cwd()\n  }\n  res.type = isFilename.test(res.rawSpec) ? 'file' : 'directory'\n  res.where = where\n\n  // always put the '/' on where when resolving urls, or else\n  // file:foo from /path/to/bar goes to /path/to/foo, when we want\n  // it to be /path/to/bar/foo\n\n  let specUrl\n  let resolvedUrl\n  const prefix = (!/^file:/.test(res.rawSpec) ? 'file:' : '')\n  const rawWithPrefix = prefix + res.rawSpec\n  let rawNoPrefix = rawWithPrefix.replace(/^file:/, '')\n  try {\n    resolvedUrl = new url.URL(rawWithPrefix, `file://${path.resolve(where)}/`)\n    specUrl = new url.URL(rawWithPrefix)\n  } catch (originalError) {\n    const er = new Error('Invalid file: URL, must comply with RFC 8909')\n    throw Object.assign(er, {\n      raw: res.rawSpec,\n      spec: res,\n      where,\n      originalError,\n    })\n  }\n\n  // environment switch for testing\n  if (process.env.NPM_PACKAGE_ARG_8909_STRICT !== '1') {\n    // XXX backwards compatibility lack of compliance with 8909\n    // Remove when we want a breaking change to come into RFC compliance.\n    if (resolvedUrl.host && resolvedUrl.host !== 'localhost') {\n      const rawSpec = res.rawSpec.replace(/^file:\\/\\//, 'file:///')\n      resolvedUrl = new url.URL(rawSpec, `file://${path.resolve(where)}/`)\n      specUrl = new url.URL(rawSpec)\n      rawNoPrefix = rawSpec.replace(/^file:/, '')\n    }\n    // turn file:/../foo into file:../foo\n    // for 1, 2 or 3 leading slashes since we attempted\n    // in the previous step to make it a file protocol url with a leading slash\n    if (/^\\/{1,3}\\.\\.?(\\/|$)/.test(rawNoPrefix)) {\n      const rawSpec = res.rawSpec.replace(/^file:\\/{1,3}/, 'file:')\n      resolvedUrl = new url.URL(rawSpec, `file://${path.resolve(where)}/`)\n      specUrl = new url.URL(rawSpec)\n      rawNoPrefix = rawSpec.replace(/^file:/, '')\n    }\n    // XXX end 8909 violation backwards compatibility section\n  }\n\n  // file:foo - relative url to ./foo\n  // file:/foo - absolute path /foo\n  // file:///foo - absolute path to /foo, no authority host\n  // file://localhost/foo - absolute path to /foo, on localhost\n  // file://foo - absolute path to / on foo host (error!)\n  if (resolvedUrl.host && resolvedUrl.host !== 'localhost') {\n    const msg = `Invalid file: URL, must be absolute if // present`\n    throw Object.assign(new Error(msg), {\n      raw: res.rawSpec,\n      parsed: resolvedUrl,\n    })\n  }\n\n  // turn /C:/blah into just C:/blah on windows\n  let specPath = decodeURIComponent(specUrl.pathname)\n  let resolvedPath = decodeURIComponent(resolvedUrl.pathname)\n  if (isWindows) {\n    specPath = specPath.replace(/^\\/+([a-z]:\\/)/i, '$1')\n    resolvedPath = resolvedPath.replace(/^\\/+([a-z]:\\/)/i, '$1')\n  }\n\n  // replace ~ with homedir, but keep the ~ in the saveSpec\n  // otherwise, make it relative to where param\n  if (/^\\/~(\\/|$)/.test(specPath)) {\n    res.saveSpec = `file:${specPath.substr(1)}`\n    resolvedPath = path.resolve(homedir(), specPath.substr(3))\n  } else if (!path.isAbsolute(rawNoPrefix)) {\n    res.saveSpec = `file:${path.relative(where, resolvedPath)}`\n  } else {\n    res.saveSpec = `file:${path.resolve(resolvedPath)}`\n  }\n\n  res.fetchSpec = path.resolve(where, resolvedPath)\n  return res\n}\n\nfunction fromHostedGit (res, hosted) {\n  res.type = 'git'\n  res.hosted = hosted\n  res.saveSpec = hosted.toString({ noGitPlus: false, noCommittish: false })\n  res.fetchSpec = hosted.getDefaultRepresentation() === 'shortcut' ? null : hosted.toString()\n  return setGitCommittish(res, hosted.committish)\n}\n\nfunction unsupportedURLType (protocol, spec) {\n  const err = new Error(`Unsupported URL Type \"${protocol}\": ${spec}`)\n  err.code = 'EUNSUPPORTEDPROTOCOL'\n  return err\n}\n\nfunction matchGitScp (spec) {\n  // git ssh specifiers are overloaded to also use scp-style git\n  // specifiers, so we have to parse those out and treat them special.\n  // They are NOT true URIs, so we can't hand them to `url.parse`.\n  //\n  // This regex looks for things that look like:\n  // git+ssh://git@my.custom.git.com:username/project.git#deadbeef\n  //\n  // ...and various combinations. The username in the beginning is *required*.\n  const matched = spec.match(/^git\\+ssh:\\/\\/([^:#]+:[^#]+(?:\\.git)?)(?:#(.*))?$/i)\n  return matched && !matched[1].match(/:[0-9]+\\/?.*$/i) && {\n    fetchSpec: matched[1],\n    gitCommittish: matched[2] == null ? null : matched[2],\n  }\n}\n\nfunction fromURL (res) {\n  // eslint-disable-next-line node/no-deprecated-api\n  const urlparse = url.parse(res.rawSpec)\n  res.saveSpec = res.rawSpec\n  // check the protocol, and then see if it's git or not\n  switch (urlparse.protocol) {\n    case 'git:':\n    case 'git+http:':\n    case 'git+https:':\n    case 'git+rsync:':\n    case 'git+ftp:':\n    case 'git+file:':\n    case 'git+ssh:': {\n      res.type = 'git'\n      const match = urlparse.protocol === 'git+ssh:' ? matchGitScp(res.rawSpec)\n        : null\n      if (match) {\n        setGitCommittish(res, match.gitCommittish)\n        res.fetchSpec = match.fetchSpec\n      } else {\n        setGitCommittish(res, urlparse.hash != null ? urlparse.hash.slice(1) : '')\n        urlparse.protocol = urlparse.protocol.replace(/^git[+]/, '')\n        if (urlparse.protocol === 'file:' && /^git\\+file:\\/\\/[a-z]:/i.test(res.rawSpec)) {\n          // keep the drive letter : on windows file paths\n          urlparse.host += ':'\n          urlparse.hostname += ':'\n        }\n        delete urlparse.hash\n        res.fetchSpec = url.format(urlparse)\n      }\n      break\n    }\n    case 'http:':\n    case 'https:':\n      res.type = 'remote'\n      res.fetchSpec = res.saveSpec\n      break\n\n    default:\n      throw unsupportedURLType(urlparse.protocol, res.rawSpec)\n  }\n\n  return res\n}\n\nfunction fromAlias (res, where) {\n  const subSpec = npa(res.rawSpec.substr(4), where)\n  if (subSpec.type === 'alias') {\n    throw new Error('nested aliases not supported')\n  }\n\n  if (!subSpec.registry) {\n    throw new Error('aliases only work for registry deps')\n  }\n\n  res.subSpec = subSpec\n  res.registry = true\n  res.type = 'alias'\n  res.saveSpec = null\n  res.fetchSpec = null\n  return res\n}\n\nfunction fromRegistry (res) {\n  res.registry = true\n  const spec = res.rawSpec === '' ? 'latest' : res.rawSpec.trim()\n  // no save spec for registry components as we save based on the fetched\n  // version, not on the argument so this can't compute that.\n  res.saveSpec = null\n  res.fetchSpec = spec\n  const version = semver.valid(spec, true)\n  const range = semver.validRange(spec, true)\n  if (version) {\n    res.type = 'version'\n  } else if (range) {\n    res.type = 'range'\n  } else {\n    if (encodeURIComponent(spec) !== spec) {\n      throw invalidTagName(spec, res.raw)\n    }\n    res.type = 'tag'\n  }\n  return res\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}