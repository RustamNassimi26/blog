{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _asyncToGenerator = require(\"I:/Angular/angular-blog/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FileSystemEngineHostBase = exports.SchematicNameCollisionException = exports.SchematicMissingDescriptionException = exports.SchematicMissingFieldsException = exports.CollectionMissingFieldsException = exports.CollectionMissingSchematicsMapException = exports.FactoryCannotBeResolvedException = exports.SchematicMissingFactoryException = exports.InvalidCollectionJsonException = exports.CollectionCannotBeResolvedException = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst node_1 = require(\"@angular-devkit/core/node\");\nconst fs_1 = require(\"fs\");\nconst path_1 = require(\"path\");\nconst rxjs_1 = require(\"rxjs\");\nconst src_1 = require(\"../src\");\nconst file_system_utility_1 = require(\"./file-system-utility\");\nclass CollectionCannotBeResolvedException extends core_1.BaseException {\n  constructor(name) {\n    super(`Collection ${JSON.stringify(name)} cannot be resolved.`);\n  }\n}\nexports.CollectionCannotBeResolvedException = CollectionCannotBeResolvedException;\nclass InvalidCollectionJsonException extends core_1.BaseException {\n  constructor(_name, path, jsonException) {\n    let msg = `Collection JSON at path ${JSON.stringify(path)} is invalid.`;\n    if (jsonException) {\n      msg = `${msg} ${jsonException.message}`;\n    }\n    super(msg);\n  }\n}\nexports.InvalidCollectionJsonException = InvalidCollectionJsonException;\nclass SchematicMissingFactoryException extends core_1.BaseException {\n  constructor(name) {\n    super(`Schematic ${JSON.stringify(name)} is missing a factory.`);\n  }\n}\nexports.SchematicMissingFactoryException = SchematicMissingFactoryException;\nclass FactoryCannotBeResolvedException extends core_1.BaseException {\n  constructor(name) {\n    super(`Schematic ${JSON.stringify(name)} cannot resolve the factory.`);\n  }\n}\nexports.FactoryCannotBeResolvedException = FactoryCannotBeResolvedException;\nclass CollectionMissingSchematicsMapException extends core_1.BaseException {\n  constructor(name) {\n    super(`Collection \"${name}\" does not have a schematics map.`);\n  }\n}\nexports.CollectionMissingSchematicsMapException = CollectionMissingSchematicsMapException;\nclass CollectionMissingFieldsException extends core_1.BaseException {\n  constructor(name) {\n    super(`Collection \"${name}\" is missing fields.`);\n  }\n}\nexports.CollectionMissingFieldsException = CollectionMissingFieldsException;\nclass SchematicMissingFieldsException extends core_1.BaseException {\n  constructor(name) {\n    super(`Schematic \"${name}\" is missing fields.`);\n  }\n}\nexports.SchematicMissingFieldsException = SchematicMissingFieldsException;\nclass SchematicMissingDescriptionException extends core_1.BaseException {\n  constructor(name) {\n    super(`Schematics \"${name}\" does not have a description.`);\n  }\n}\nexports.SchematicMissingDescriptionException = SchematicMissingDescriptionException;\nclass SchematicNameCollisionException extends core_1.BaseException {\n  constructor(name) {\n    super(`Schematics/alias ${JSON.stringify(name)} collides with another alias or schematic` + ' name.');\n  }\n}\nexports.SchematicNameCollisionException = SchematicNameCollisionException;\n/**\n * A EngineHost base class that uses the file system to resolve collections. This is the base of\n * all other EngineHost provided by the tooling part of the Schematics library.\n */\nclass FileSystemEngineHostBase {\n  constructor() {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this._transforms = [];\n    this._contextTransforms = [];\n    this._taskFactories = new Map();\n  }\n  listSchematicNames(collection, includeHidden) {\n    const schematics = [];\n    for (const key of Object.keys(collection.schematics)) {\n      const schematic = collection.schematics[key];\n      if (schematic.hidden && !includeHidden || schematic.private) {\n        continue;\n      }\n      // If extends is present without a factory it is an alias, do not return it\n      //   unless it is from another collection.\n      if (!schematic.extends || schematic.factory) {\n        schematics.push(key);\n      } else if (schematic.extends && schematic.extends.indexOf(':') !== -1) {\n        schematics.push(key);\n      }\n    }\n    return schematics;\n  }\n  registerOptionsTransform(t) {\n    this._transforms.push(t);\n  }\n  registerContextTransform(t) {\n    this._contextTransforms.push(t);\n  }\n  /**\n   *\n   * @param name\n   * @return {{path: string}}\n   */\n  createCollectionDescription(name, requester) {\n    const path = this._resolveCollectionPath(name, requester === null || requester === void 0 ? void 0 : requester.path);\n    const jsonValue = (0, file_system_utility_1.readJsonFile)(path);\n    if (!jsonValue || typeof jsonValue != 'object' || Array.isArray(jsonValue)) {\n      throw new InvalidCollectionJsonException(name, path);\n    }\n    // normalize extends property to an array\n    if (typeof jsonValue['extends'] === 'string') {\n      jsonValue['extends'] = [jsonValue['extends']];\n    }\n    const description = this._transformCollectionDescription(name, {\n      ...jsonValue,\n      path\n    });\n    if (!description || !description.name) {\n      throw new InvalidCollectionJsonException(name, path);\n    }\n    // Validate aliases.\n    const allNames = Object.keys(description.schematics);\n    for (const schematicName of Object.keys(description.schematics)) {\n      const aliases = description.schematics[schematicName].aliases || [];\n      for (const alias of aliases) {\n        if (allNames.indexOf(alias) != -1) {\n          throw new SchematicNameCollisionException(alias);\n        }\n      }\n      allNames.push(...aliases);\n    }\n    return description;\n  }\n  createSchematicDescription(name, collection) {\n    // Resolve aliases first.\n    for (const schematicName of Object.keys(collection.schematics)) {\n      const schematicDescription = collection.schematics[schematicName];\n      if (schematicDescription.aliases && schematicDescription.aliases.indexOf(name) != -1) {\n        name = schematicName;\n        break;\n      }\n    }\n    if (!(name in collection.schematics)) {\n      return null;\n    }\n    const collectionPath = (0, path_1.dirname)(collection.path);\n    const partialDesc = collection.schematics[name];\n    if (!partialDesc) {\n      return null;\n    }\n    if (partialDesc.extends) {\n      const index = partialDesc.extends.indexOf(':');\n      const collectionName = index !== -1 ? partialDesc.extends.slice(0, index) : null;\n      const schematicName = index === -1 ? partialDesc.extends : partialDesc.extends.slice(index + 1);\n      if (collectionName !== null) {\n        const extendCollection = this.createCollectionDescription(collectionName);\n        return this.createSchematicDescription(schematicName, extendCollection);\n      } else {\n        return this.createSchematicDescription(schematicName, collection);\n      }\n    }\n    // Use any on this ref as we don't have the OptionT here, but we don't need it (we only need\n    // the path).\n    if (!partialDesc.factory) {\n      throw new SchematicMissingFactoryException(name);\n    }\n    const resolvedRef = this._resolveReferenceString(partialDesc.factory, collectionPath, collection);\n    if (!resolvedRef) {\n      throw new FactoryCannotBeResolvedException(name);\n    }\n    let schema = partialDesc.schema;\n    let schemaJson = undefined;\n    if (schema) {\n      if (!(0, path_1.isAbsolute)(schema)) {\n        schema = (0, path_1.join)(collectionPath, schema);\n      }\n      schemaJson = (0, file_system_utility_1.readJsonFile)(schema);\n    }\n    // The schematic path is used to resolve URLs.\n    // We should be able to just do `dirname(resolvedRef.path)` but for compatibility with\n    // Bazel under Windows this directory needs to be resolved from the collection instead.\n    // This is needed because on Bazel under Windows the data files (such as the collection or\n    // url files) are not in the same place as the compiled JS.\n    const maybePath = (0, path_1.join)(collectionPath, partialDesc.factory);\n    const path = (0, fs_1.existsSync)(maybePath) && (0, fs_1.statSync)(maybePath).isDirectory() ? maybePath : (0, path_1.dirname)(maybePath);\n    return this._transformSchematicDescription(name, collection, {\n      ...partialDesc,\n      schema,\n      schemaJson,\n      name,\n      path,\n      factoryFn: resolvedRef.ref,\n      collection\n    });\n  }\n  createSourceFromUrl(url) {\n    switch (url.protocol) {\n      case null:\n      case 'file:':\n        return context => {\n          // Check if context has necessary FileSystemSchematicContext path property\n          const fileDescription = context.schematic.description;\n          if (fileDescription.path === undefined) {\n            throw new Error('Unsupported schematic context. Expected a FileSystemSchematicContext.');\n          }\n          // Resolve all file:///a/b/c/d from the schematic's own path, and not the current\n          // path.\n          const root = (0, core_1.normalize)((0, path_1.resolve)(fileDescription.path, url.path || ''));\n          return new src_1.HostCreateTree(new core_1.virtualFs.ScopedHost(new node_1.NodeJsSyncHost(), root));\n        };\n    }\n    return null;\n  }\n  transformOptions(schematic, options, context) {\n    var _this = this;\n    const transform = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* () {\n        let transformedOptions = options;\n        for (const transformer of _this._transforms) {\n          const transformerResult = transformer(schematic, transformedOptions, context);\n          transformedOptions = yield (0, rxjs_1.isObservable)(transformerResult) ? transformerResult.toPromise() : transformerResult;\n        }\n        return transformedOptions;\n      });\n      return function transform() {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    return (0, rxjs_1.from)(transform());\n  }\n  transformContext(context) {\n    return this._contextTransforms.reduce((acc, curr) => curr(acc), context);\n  }\n  getSchematicRuleFactory(schematic, _collection) {\n    return schematic.factoryFn;\n  }\n  registerTaskExecutor(factory, options) {\n    this._taskFactories.set(factory.name, () => (0, rxjs_1.from)(factory.create(options)));\n  }\n  createTaskExecutor(name) {\n    const factory = this._taskFactories.get(name);\n    if (factory) {\n      return factory();\n    }\n    return (0, rxjs_1.throwError)(new src_1.UnregisteredTaskException(name));\n  }\n  hasTaskExecutor(name) {\n    return this._taskFactories.has(name);\n  }\n}\nexports.FileSystemEngineHostBase = FileSystemEngineHostBase;","map":{"version":3,"names":["Object","defineProperty","exports","value","FileSystemEngineHostBase","SchematicNameCollisionException","SchematicMissingDescriptionException","SchematicMissingFieldsException","CollectionMissingFieldsException","CollectionMissingSchematicsMapException","FactoryCannotBeResolvedException","SchematicMissingFactoryException","InvalidCollectionJsonException","CollectionCannotBeResolvedException","core_1","require","node_1","fs_1","path_1","rxjs_1","src_1","file_system_utility_1","BaseException","constructor","name","JSON","stringify","_name","path","jsonException","msg","message","_transforms","_contextTransforms","_taskFactories","Map","listSchematicNames","collection","includeHidden","schematics","key","keys","schematic","hidden","private","extends","factory","push","indexOf","registerOptionsTransform","t","registerContextTransform","createCollectionDescription","requester","_resolveCollectionPath","jsonValue","readJsonFile","Array","isArray","description","_transformCollectionDescription","allNames","schematicName","aliases","alias","createSchematicDescription","schematicDescription","collectionPath","dirname","partialDesc","index","collectionName","slice","extendCollection","resolvedRef","_resolveReferenceString","schema","schemaJson","undefined","isAbsolute","join","maybePath","existsSync","statSync","isDirectory","_transformSchematicDescription","factoryFn","ref","createSourceFromUrl","url","protocol","context","fileDescription","Error","root","normalize","resolve","HostCreateTree","virtualFs","ScopedHost","NodeJsSyncHost","transformOptions","options","transform","transformedOptions","transformer","transformerResult","isObservable","toPromise","from","transformContext","reduce","acc","curr","getSchematicRuleFactory","_collection","registerTaskExecutor","set","create","createTaskExecutor","get","throwError","UnregisteredTaskException","hasTaskExecutor","has"],"sources":["I:/Angular/angular-blog/node_modules/@angular-devkit/schematics/tools/file-system-engine-host-base.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FileSystemEngineHostBase = exports.SchematicNameCollisionException = exports.SchematicMissingDescriptionException = exports.SchematicMissingFieldsException = exports.CollectionMissingFieldsException = exports.CollectionMissingSchematicsMapException = exports.FactoryCannotBeResolvedException = exports.SchematicMissingFactoryException = exports.InvalidCollectionJsonException = exports.CollectionCannotBeResolvedException = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst node_1 = require(\"@angular-devkit/core/node\");\nconst fs_1 = require(\"fs\");\nconst path_1 = require(\"path\");\nconst rxjs_1 = require(\"rxjs\");\nconst src_1 = require(\"../src\");\nconst file_system_utility_1 = require(\"./file-system-utility\");\nclass CollectionCannotBeResolvedException extends core_1.BaseException {\n    constructor(name) {\n        super(`Collection ${JSON.stringify(name)} cannot be resolved.`);\n    }\n}\nexports.CollectionCannotBeResolvedException = CollectionCannotBeResolvedException;\nclass InvalidCollectionJsonException extends core_1.BaseException {\n    constructor(_name, path, jsonException) {\n        let msg = `Collection JSON at path ${JSON.stringify(path)} is invalid.`;\n        if (jsonException) {\n            msg = `${msg} ${jsonException.message}`;\n        }\n        super(msg);\n    }\n}\nexports.InvalidCollectionJsonException = InvalidCollectionJsonException;\nclass SchematicMissingFactoryException extends core_1.BaseException {\n    constructor(name) {\n        super(`Schematic ${JSON.stringify(name)} is missing a factory.`);\n    }\n}\nexports.SchematicMissingFactoryException = SchematicMissingFactoryException;\nclass FactoryCannotBeResolvedException extends core_1.BaseException {\n    constructor(name) {\n        super(`Schematic ${JSON.stringify(name)} cannot resolve the factory.`);\n    }\n}\nexports.FactoryCannotBeResolvedException = FactoryCannotBeResolvedException;\nclass CollectionMissingSchematicsMapException extends core_1.BaseException {\n    constructor(name) {\n        super(`Collection \"${name}\" does not have a schematics map.`);\n    }\n}\nexports.CollectionMissingSchematicsMapException = CollectionMissingSchematicsMapException;\nclass CollectionMissingFieldsException extends core_1.BaseException {\n    constructor(name) {\n        super(`Collection \"${name}\" is missing fields.`);\n    }\n}\nexports.CollectionMissingFieldsException = CollectionMissingFieldsException;\nclass SchematicMissingFieldsException extends core_1.BaseException {\n    constructor(name) {\n        super(`Schematic \"${name}\" is missing fields.`);\n    }\n}\nexports.SchematicMissingFieldsException = SchematicMissingFieldsException;\nclass SchematicMissingDescriptionException extends core_1.BaseException {\n    constructor(name) {\n        super(`Schematics \"${name}\" does not have a description.`);\n    }\n}\nexports.SchematicMissingDescriptionException = SchematicMissingDescriptionException;\nclass SchematicNameCollisionException extends core_1.BaseException {\n    constructor(name) {\n        super(`Schematics/alias ${JSON.stringify(name)} collides with another alias or schematic` +\n            ' name.');\n    }\n}\nexports.SchematicNameCollisionException = SchematicNameCollisionException;\n/**\n * A EngineHost base class that uses the file system to resolve collections. This is the base of\n * all other EngineHost provided by the tooling part of the Schematics library.\n */\nclass FileSystemEngineHostBase {\n    constructor() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this._transforms = [];\n        this._contextTransforms = [];\n        this._taskFactories = new Map();\n    }\n    listSchematicNames(collection, includeHidden) {\n        const schematics = [];\n        for (const key of Object.keys(collection.schematics)) {\n            const schematic = collection.schematics[key];\n            if ((schematic.hidden && !includeHidden) || schematic.private) {\n                continue;\n            }\n            // If extends is present without a factory it is an alias, do not return it\n            //   unless it is from another collection.\n            if (!schematic.extends || schematic.factory) {\n                schematics.push(key);\n            }\n            else if (schematic.extends && schematic.extends.indexOf(':') !== -1) {\n                schematics.push(key);\n            }\n        }\n        return schematics;\n    }\n    registerOptionsTransform(t) {\n        this._transforms.push(t);\n    }\n    registerContextTransform(t) {\n        this._contextTransforms.push(t);\n    }\n    /**\n     *\n     * @param name\n     * @return {{path: string}}\n     */\n    createCollectionDescription(name, requester) {\n        const path = this._resolveCollectionPath(name, requester === null || requester === void 0 ? void 0 : requester.path);\n        const jsonValue = (0, file_system_utility_1.readJsonFile)(path);\n        if (!jsonValue || typeof jsonValue != 'object' || Array.isArray(jsonValue)) {\n            throw new InvalidCollectionJsonException(name, path);\n        }\n        // normalize extends property to an array\n        if (typeof jsonValue['extends'] === 'string') {\n            jsonValue['extends'] = [jsonValue['extends']];\n        }\n        const description = this._transformCollectionDescription(name, {\n            ...jsonValue,\n            path,\n        });\n        if (!description || !description.name) {\n            throw new InvalidCollectionJsonException(name, path);\n        }\n        // Validate aliases.\n        const allNames = Object.keys(description.schematics);\n        for (const schematicName of Object.keys(description.schematics)) {\n            const aliases = description.schematics[schematicName].aliases || [];\n            for (const alias of aliases) {\n                if (allNames.indexOf(alias) != -1) {\n                    throw new SchematicNameCollisionException(alias);\n                }\n            }\n            allNames.push(...aliases);\n        }\n        return description;\n    }\n    createSchematicDescription(name, collection) {\n        // Resolve aliases first.\n        for (const schematicName of Object.keys(collection.schematics)) {\n            const schematicDescription = collection.schematics[schematicName];\n            if (schematicDescription.aliases && schematicDescription.aliases.indexOf(name) != -1) {\n                name = schematicName;\n                break;\n            }\n        }\n        if (!(name in collection.schematics)) {\n            return null;\n        }\n        const collectionPath = (0, path_1.dirname)(collection.path);\n        const partialDesc = collection.schematics[name];\n        if (!partialDesc) {\n            return null;\n        }\n        if (partialDesc.extends) {\n            const index = partialDesc.extends.indexOf(':');\n            const collectionName = index !== -1 ? partialDesc.extends.slice(0, index) : null;\n            const schematicName = index === -1 ? partialDesc.extends : partialDesc.extends.slice(index + 1);\n            if (collectionName !== null) {\n                const extendCollection = this.createCollectionDescription(collectionName);\n                return this.createSchematicDescription(schematicName, extendCollection);\n            }\n            else {\n                return this.createSchematicDescription(schematicName, collection);\n            }\n        }\n        // Use any on this ref as we don't have the OptionT here, but we don't need it (we only need\n        // the path).\n        if (!partialDesc.factory) {\n            throw new SchematicMissingFactoryException(name);\n        }\n        const resolvedRef = this._resolveReferenceString(partialDesc.factory, collectionPath, collection);\n        if (!resolvedRef) {\n            throw new FactoryCannotBeResolvedException(name);\n        }\n        let schema = partialDesc.schema;\n        let schemaJson = undefined;\n        if (schema) {\n            if (!(0, path_1.isAbsolute)(schema)) {\n                schema = (0, path_1.join)(collectionPath, schema);\n            }\n            schemaJson = (0, file_system_utility_1.readJsonFile)(schema);\n        }\n        // The schematic path is used to resolve URLs.\n        // We should be able to just do `dirname(resolvedRef.path)` but for compatibility with\n        // Bazel under Windows this directory needs to be resolved from the collection instead.\n        // This is needed because on Bazel under Windows the data files (such as the collection or\n        // url files) are not in the same place as the compiled JS.\n        const maybePath = (0, path_1.join)(collectionPath, partialDesc.factory);\n        const path = (0, fs_1.existsSync)(maybePath) && (0, fs_1.statSync)(maybePath).isDirectory() ? maybePath : (0, path_1.dirname)(maybePath);\n        return this._transformSchematicDescription(name, collection, {\n            ...partialDesc,\n            schema,\n            schemaJson,\n            name,\n            path,\n            factoryFn: resolvedRef.ref,\n            collection,\n        });\n    }\n    createSourceFromUrl(url) {\n        switch (url.protocol) {\n            case null:\n            case 'file:':\n                return (context) => {\n                    // Check if context has necessary FileSystemSchematicContext path property\n                    const fileDescription = context.schematic.description;\n                    if (fileDescription.path === undefined) {\n                        throw new Error('Unsupported schematic context. Expected a FileSystemSchematicContext.');\n                    }\n                    // Resolve all file:///a/b/c/d from the schematic's own path, and not the current\n                    // path.\n                    const root = (0, core_1.normalize)((0, path_1.resolve)(fileDescription.path, url.path || ''));\n                    return new src_1.HostCreateTree(new core_1.virtualFs.ScopedHost(new node_1.NodeJsSyncHost(), root));\n                };\n        }\n        return null;\n    }\n    transformOptions(schematic, options, context) {\n        const transform = async () => {\n            let transformedOptions = options;\n            for (const transformer of this._transforms) {\n                const transformerResult = transformer(schematic, transformedOptions, context);\n                transformedOptions = await ((0, rxjs_1.isObservable)(transformerResult)\n                    ? transformerResult.toPromise()\n                    : transformerResult);\n            }\n            return transformedOptions;\n        };\n        return (0, rxjs_1.from)(transform());\n    }\n    transformContext(context) {\n        return this._contextTransforms.reduce((acc, curr) => curr(acc), context);\n    }\n    getSchematicRuleFactory(schematic, _collection) {\n        return schematic.factoryFn;\n    }\n    registerTaskExecutor(factory, options) {\n        this._taskFactories.set(factory.name, () => (0, rxjs_1.from)(factory.create(options)));\n    }\n    createTaskExecutor(name) {\n        const factory = this._taskFactories.get(name);\n        if (factory) {\n            return factory();\n        }\n        return (0, rxjs_1.throwError)(new src_1.UnregisteredTaskException(name));\n    }\n    hasTaskExecutor(name) {\n        return this._taskFactories.has(name);\n    }\n}\nexports.FileSystemEngineHostBase = FileSystemEngineHostBase;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}