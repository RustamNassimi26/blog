{"ast":null,"code":"const Fetcher = require('./fetcher.js');\nconst FileFetcher = require('./file.js');\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved');\nconst pacoteVersion = require('../package.json').version;\nconst fetch = require('npm-registry-fetch');\nconst Minipass = require('minipass');\nconst _cacheFetches = Symbol.for('pacote.Fetcher._cacheFetches');\nconst _headers = Symbol('_headers');\nclass RemoteFetcher extends Fetcher {\n  constructor(spec, opts) {\n    super(spec, opts);\n    this.resolved = this.spec.fetchSpec;\n    const resolvedURL = new URL(this.resolved);\n    if (this.replaceRegistryHost !== 'never' && (this.replaceRegistryHost === 'always' || this.replaceRegistryHost === resolvedURL.host)) {\n      this.resolved = new URL(resolvedURL.pathname, this.registry).href;\n    }\n\n    // nam is a fermented pork sausage that is good to eat\n    const nameat = this.spec.name ? `${this.spec.name}@` : '';\n    this.pkgid = opts.pkgid ? opts.pkgid : `remote:${nameat}${this.resolved}`;\n  }\n\n  // Don't need to cache tarball fetches in pacote, because make-fetch-happen\n  // will write into cacache anyway.\n  get [_cacheFetches]() {\n    return false;\n  }\n  [_tarballFromResolved]() {\n    const stream = new Minipass();\n    stream.hasIntegrityEmitter = true;\n    const fetchOpts = {\n      ...this.opts,\n      headers: this[_headers](),\n      spec: this.spec,\n      integrity: this.integrity,\n      algorithms: [this.pickIntegrityAlgorithm()]\n    };\n\n    // eslint-disable-next-line promise/always-return\n    fetch(this.resolved, fetchOpts).then(res => {\n      res.body.on('error', /* istanbul ignore next - exceedingly rare and hard to simulate */\n      er => stream.emit('error', er));\n      res.body.on('integrity', i => {\n        this.integrity = i;\n        stream.emit('integrity', i);\n      });\n      res.body.pipe(stream);\n    }).catch(er => stream.emit('error', er));\n    return stream;\n  }\n  [_headers]() {\n    return {\n      // npm will override this, but ensure that we always send *something*\n      'user-agent': this.opts.userAgent || `pacote/${pacoteVersion} node/${process.version}`,\n      ...(this.opts.headers || {}),\n      'pacote-version': pacoteVersion,\n      'pacote-req-type': 'tarball',\n      'pacote-pkg-id': this.pkgid,\n      ...(this.integrity ? {\n        'pacote-integrity': String(this.integrity)\n      } : {}),\n      ...(this.opts.headers || {})\n    };\n  }\n  get types() {\n    return ['remote'];\n  }\n\n  // getting a packument and/or manifest is the same as with a file: spec.\n  // unpack the tarball stream, and then read from the package.json file.\n  packument() {\n    return FileFetcher.prototype.packument.apply(this);\n  }\n  manifest() {\n    return FileFetcher.prototype.manifest.apply(this);\n  }\n}\nmodule.exports = RemoteFetcher;","map":{"version":3,"names":["Fetcher","require","FileFetcher","_tarballFromResolved","Symbol","for","pacoteVersion","version","fetch","Minipass","_cacheFetches","_headers","RemoteFetcher","constructor","spec","opts","resolved","fetchSpec","resolvedURL","URL","replaceRegistryHost","host","pathname","registry","href","nameat","name","pkgid","stream","hasIntegrityEmitter","fetchOpts","headers","integrity","algorithms","pickIntegrityAlgorithm","then","res","body","on","er","emit","i","pipe","catch","userAgent","process","String","types","packument","prototype","apply","manifest","module","exports"],"sources":["I:/Angular/angular-blog/node_modules/pacote/lib/remote.js"],"sourcesContent":["const Fetcher = require('./fetcher.js')\nconst FileFetcher = require('./file.js')\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved')\nconst pacoteVersion = require('../package.json').version\nconst fetch = require('npm-registry-fetch')\nconst Minipass = require('minipass')\n\nconst _cacheFetches = Symbol.for('pacote.Fetcher._cacheFetches')\nconst _headers = Symbol('_headers')\nclass RemoteFetcher extends Fetcher {\n  constructor (spec, opts) {\n    super(spec, opts)\n    this.resolved = this.spec.fetchSpec\n    const resolvedURL = new URL(this.resolved)\n    if (this.replaceRegistryHost !== 'never'\n      && (this.replaceRegistryHost === 'always'\n      || this.replaceRegistryHost === resolvedURL.host)) {\n      this.resolved = new URL(resolvedURL.pathname, this.registry).href\n    }\n\n    // nam is a fermented pork sausage that is good to eat\n    const nameat = this.spec.name ? `${this.spec.name}@` : ''\n    this.pkgid = opts.pkgid ? opts.pkgid : `remote:${nameat}${this.resolved}`\n  }\n\n  // Don't need to cache tarball fetches in pacote, because make-fetch-happen\n  // will write into cacache anyway.\n  get [_cacheFetches] () {\n    return false\n  }\n\n  [_tarballFromResolved] () {\n    const stream = new Minipass()\n    stream.hasIntegrityEmitter = true\n\n    const fetchOpts = {\n      ...this.opts,\n      headers: this[_headers](),\n      spec: this.spec,\n      integrity: this.integrity,\n      algorithms: [this.pickIntegrityAlgorithm()],\n    }\n\n    // eslint-disable-next-line promise/always-return\n    fetch(this.resolved, fetchOpts).then(res => {\n      res.body.on('error',\n        /* istanbul ignore next - exceedingly rare and hard to simulate */\n        er => stream.emit('error', er)\n      )\n\n      res.body.on('integrity', i => {\n        this.integrity = i\n        stream.emit('integrity', i)\n      })\n\n      res.body.pipe(stream)\n    }).catch(er => stream.emit('error', er))\n\n    return stream\n  }\n\n  [_headers] () {\n    return {\n      // npm will override this, but ensure that we always send *something*\n      'user-agent': this.opts.userAgent ||\n        `pacote/${pacoteVersion} node/${process.version}`,\n      ...(this.opts.headers || {}),\n      'pacote-version': pacoteVersion,\n      'pacote-req-type': 'tarball',\n      'pacote-pkg-id': this.pkgid,\n      ...(this.integrity ? { 'pacote-integrity': String(this.integrity) }\n      : {}),\n      ...(this.opts.headers || {}),\n    }\n  }\n\n  get types () {\n    return ['remote']\n  }\n\n  // getting a packument and/or manifest is the same as with a file: spec.\n  // unpack the tarball stream, and then read from the package.json file.\n  packument () {\n    return FileFetcher.prototype.packument.apply(this)\n  }\n\n  manifest () {\n    return FileFetcher.prototype.manifest.apply(this)\n  }\n}\nmodule.exports = RemoteFetcher\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}