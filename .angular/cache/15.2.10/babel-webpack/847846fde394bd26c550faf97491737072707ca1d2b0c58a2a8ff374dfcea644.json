{"ast":null,"code":"var _asyncToGenerator = require(\"I:/Angular/angular-blog/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n// This is the base class that the other fetcher types in lib\n// all descend from.\n// It handles the unpacking and retry logic that is shared among\n// all of the other Fetcher types.\n\nconst npa = require('npm-package-arg');\nconst ssri = require('ssri');\nconst {\n  promisify\n} = require('util');\nconst {\n  basename,\n  dirname\n} = require('path');\nconst tar = require('tar');\nconst log = require('proc-log');\nconst retry = require('promise-retry');\nconst fs = require('fs/promises');\nconst fsm = require('fs-minipass');\nconst cacache = require('cacache');\nconst isPackageBin = require('./util/is-package-bin.js');\nconst removeTrailingSlashes = require('./util/trailing-slashes.js');\nconst getContents = require('@npmcli/installed-package-contents');\nconst readPackageJsonFast = require('read-package-json-fast');\nconst readPackageJson = promisify(require('read-package-json'));\nconst Minipass = require('minipass');\nconst cacheDir = require('./util/cache-dir.js');\n\n// Private methods.\n// Child classes should not have to override these.\n// Users should never call them.\nconst _extract = Symbol('_extract');\nconst _mkdir = Symbol('_mkdir');\nconst _empty = Symbol('_empty');\nconst _toFile = Symbol('_toFile');\nconst _tarxOptions = Symbol('_tarxOptions');\nconst _entryMode = Symbol('_entryMode');\nconst _istream = Symbol('_istream');\nconst _assertType = Symbol('_assertType');\nconst _tarballFromCache = Symbol('_tarballFromCache');\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved');\nconst _cacheFetches = Symbol.for('pacote.Fetcher._cacheFetches');\nconst _readPackageJson = Symbol.for('package.Fetcher._readPackageJson');\nclass FetcherBase {\n  constructor(spec, opts) {\n    if (!opts || typeof opts !== 'object') {\n      throw new TypeError('options object is required');\n    }\n    this.spec = npa(spec, opts.where);\n    this.allowGitIgnore = !!opts.allowGitIgnore;\n\n    // a bit redundant because presumably the caller already knows this,\n    // but it makes it easier to not have to keep track of the requested\n    // spec when we're dispatching thousands of these at once, and normalizing\n    // is nice.  saveSpec is preferred if set, because it turns stuff like\n    // x/y#committish into github:x/y#committish.  use name@rawSpec for\n    // registry deps so that we turn xyz and xyz@ -> xyz@\n    this.from = this.spec.registry ? `${this.spec.name}@${this.spec.rawSpec}` : this.spec.saveSpec;\n    this[_assertType]();\n    // clone the opts object so that others aren't upset when we mutate it\n    // by adding/modifying the integrity value.\n    this.opts = {\n      ...opts\n    };\n    this.cache = opts.cache || cacheDir();\n    this.resolved = opts.resolved || null;\n\n    // default to caching/verifying with sha512, that's what we usually have\n    // need to change this default, or start overriding it, when sha512\n    // is no longer strong enough.\n    this.defaultIntegrityAlgorithm = opts.defaultIntegrityAlgorithm || 'sha512';\n    if (typeof opts.integrity === 'string') {\n      this.opts.integrity = ssri.parse(opts.integrity);\n    }\n    this.package = null;\n    this.type = this.constructor.name;\n    this.fmode = opts.fmode || 0o666;\n    this.dmode = opts.dmode || 0o777;\n    // we don't need a default umask, because we don't chmod files coming\n    // out of package tarballs.  they're forced to have a mode that is\n    // valid, regardless of what's in the tarball entry, and then we let\n    // the process's umask setting do its job.  but if configured, we do\n    // respect it.\n    this.umask = opts.umask || 0;\n    this.preferOnline = !!opts.preferOnline;\n    this.preferOffline = !!opts.preferOffline;\n    this.offline = !!opts.offline;\n    this.before = opts.before;\n    this.fullMetadata = this.before ? true : !!opts.fullMetadata;\n    this.fullReadJson = !!opts.fullReadJson;\n    if (this.fullReadJson) {\n      this[_readPackageJson] = readPackageJson;\n    } else {\n      this[_readPackageJson] = readPackageJsonFast;\n    }\n\n    // rrh is a registry hostname or 'never' or 'always'\n    // defaults to registry.npmjs.org\n    this.replaceRegistryHost = !opts.replaceRegistryHost || opts.replaceRegistryHost === 'npmjs' ? 'registry.npmjs.org' : opts.replaceRegistryHost;\n    this.defaultTag = opts.defaultTag || 'latest';\n    this.registry = removeTrailingSlashes(opts.registry || 'https://registry.npmjs.org');\n\n    // command to run 'prepare' scripts on directories and git dirs\n    // To use pacote with yarn, for example, set npmBin to 'yarn'\n    // and npmCliConfig with yarn's equivalents.\n    this.npmBin = opts.npmBin || 'npm';\n\n    // command to install deps for preparing\n    this.npmInstallCmd = opts.npmInstallCmd || ['install', '--force'];\n\n    // XXX fill more of this in based on what we know from this.opts\n    // we explicitly DO NOT fill in --tag, though, since we are often\n    // going to be packing in the context of a publish, which may set\n    // a dist-tag, but certainly wants to keep defaulting to latest.\n    this.npmCliConfig = opts.npmCliConfig || [`--cache=${dirname(this.cache)}`, `--prefer-offline=${!!this.preferOffline}`, `--prefer-online=${!!this.preferOnline}`, `--offline=${!!this.offline}`, ...(this.before ? [`--before=${this.before.toISOString()}`] : []), '--no-progress', '--no-save', '--no-audit',\n    // override any omit settings from the environment\n    '--include=dev', '--include=peer', '--include=optional',\n    // we need the actual things, not just the lockfile\n    '--no-package-lock-only', '--no-dry-run'];\n  }\n  get integrity() {\n    return this.opts.integrity || null;\n  }\n  set integrity(i) {\n    if (!i) {\n      return;\n    }\n    i = ssri.parse(i);\n    const current = this.opts.integrity;\n\n    // do not ever update an existing hash value, but do\n    // merge in NEW algos and hashes that we don't already have.\n    if (current) {\n      current.merge(i);\n    } else {\n      this.opts.integrity = i;\n    }\n  }\n  get notImplementedError() {\n    return new Error('not implemented in this fetcher type: ' + this.type);\n  }\n\n  // override in child classes\n  // Returns a Promise that resolves to this.resolved string value\n  resolve() {\n    return this.resolved ? Promise.resolve(this.resolved) : Promise.reject(this.notImplementedError);\n  }\n  packument() {\n    return Promise.reject(this.notImplementedError);\n  }\n\n  // override in child class\n  // returns a manifest containing:\n  // - name\n  // - version\n  // - _resolved\n  // - _integrity\n  // - plus whatever else was in there (corgi, full metadata, or pj file)\n  manifest() {\n    return Promise.reject(this.notImplementedError);\n  }\n\n  // private, should be overridden.\n  // Note that they should *not* calculate or check integrity or cache,\n  // but *just*  return the raw tarball data stream.\n  [_tarballFromResolved]() {\n    throw this.notImplementedError;\n  }\n\n  // public, should not be overridden\n  tarball() {\n    return this.tarballStream(stream => stream.concat().then(data => {\n      data.integrity = this.integrity && String(this.integrity);\n      data.resolved = this.resolved;\n      data.from = this.from;\n      return data;\n    }));\n  }\n\n  // private\n  // Note: cacache will raise a EINTEGRITY error if the integrity doesn't match\n  [_tarballFromCache]() {\n    return cacache.get.stream.byDigest(this.cache, this.integrity, this.opts);\n  }\n  get [_cacheFetches]() {\n    return true;\n  }\n  [_istream](stream) {\n    // if not caching this, just return it\n    if (!this.opts.cache || !this[_cacheFetches]) {\n      // instead of creating a new integrity stream, we only piggyback on the\n      // provided stream's events\n      if (stream.hasIntegrityEmitter) {\n        stream.on('integrity', i => this.integrity = i);\n        return stream;\n      }\n      const istream = ssri.integrityStream(this.opts);\n      istream.on('integrity', i => this.integrity = i);\n      stream.on('error', err => istream.emit('error', err));\n      return stream.pipe(istream);\n    }\n\n    // we have to return a stream that gets ALL the data, and proxies errors,\n    // but then pipe from the original tarball stream into the cache as well.\n    // To do this without losing any data, and since the cacache put stream\n    // is not a passthrough, we have to pipe from the original stream into\n    // the cache AFTER we pipe into the middleStream.  Since the cache stream\n    // has an asynchronous flush to write its contents to disk, we need to\n    // defer the middleStream end until the cache stream ends.\n    const middleStream = new Minipass();\n    stream.on('error', err => middleStream.emit('error', err));\n    stream.pipe(middleStream, {\n      end: false\n    });\n    const cstream = cacache.put.stream(this.opts.cache, `pacote:tarball:${this.from}`, this.opts);\n    cstream.on('integrity', i => this.integrity = i);\n    cstream.on('error', err => stream.emit('error', err));\n    stream.pipe(cstream);\n\n    // eslint-disable-next-line promise/catch-or-return\n    cstream.promise().catch(() => {}).then(() => middleStream.end());\n    return middleStream;\n  }\n  pickIntegrityAlgorithm() {\n    return this.integrity ? this.integrity.pickAlgorithm(this.opts) : this.defaultIntegrityAlgorithm;\n  }\n\n  // TODO: check error class, once those are rolled out to our deps\n  isDataCorruptionError(er) {\n    return er.code === 'EINTEGRITY' || er.code === 'Z_DATA_ERROR';\n  }\n\n  // override the types getter\n  get types() {\n    return false;\n  }\n  [_assertType]() {\n    if (this.types && !this.types.includes(this.spec.type)) {\n      throw new TypeError(`Wrong spec type (${this.spec.type}) for ${this.constructor.name}. Supported types: ${this.types.join(', ')}`);\n    }\n  }\n\n  // We allow ENOENTs from cacache, but not anywhere else.\n  // An ENOENT trying to read a tgz file, for example, is Right Out.\n  isRetriableError(er) {\n    // TODO: check error class, once those are rolled out to our deps\n    return this.isDataCorruptionError(er) || er.code === 'ENOENT' || er.code === 'EISDIR';\n  }\n\n  // Mostly internal, but has some uses\n  // Pass in a function which returns a promise\n  // Function will be called 1 or more times with streams that may fail.\n  // Retries:\n  // Function MUST handle errors on the stream by rejecting the promise,\n  // so that retry logic can pick it up and either retry or fail whatever\n  // promise it was making (ie, failing extraction, etc.)\n  //\n  // The return value of this method is a Promise that resolves the same\n  // as whatever the streamHandler resolves to.\n  //\n  // This should never be overridden by child classes, but it is public.\n  tarballStream(streamHandler) {\n    // Only short-circuit via cache if we have everything else we'll need,\n    // and the user has not expressed a preference for checking online.\n\n    const fromCache = !this.preferOnline && this.integrity && this.resolved ? streamHandler(this[_tarballFromCache]()).catch(er => {\n      if (this.isDataCorruptionError(er)) {\n        log.warn('tarball', `cached data for ${this.spec} (${this.integrity}) seems to be corrupted. Refreshing cache.`);\n        return this.cleanupCached().then(() => {\n          throw er;\n        });\n      } else {\n        throw er;\n      }\n    }) : null;\n    const fromResolved = er => {\n      if (er) {\n        if (!this.isRetriableError(er)) {\n          throw er;\n        }\n        log.silly('tarball', `no local data for ${this.spec}. Extracting by manifest.`);\n      }\n      return this.resolve().then(() => retry(tryAgain => streamHandler(this[_istream](this[_tarballFromResolved]())).catch(streamErr => {\n        // Most likely data integrity.  A cache ENOENT error is unlikely\n        // here, since we're definitely not reading from the cache, but it\n        // IS possible that the fetch subsystem accessed the cache, and the\n        // entry got blown away or something.  Try one more time to be sure.\n        if (this.isRetriableError(streamErr)) {\n          log.warn('tarball', `tarball data for ${this.spec} (${this.integrity}) seems to be corrupted. Trying again.`);\n          return this.cleanupCached().then(() => tryAgain(streamErr));\n        }\n        throw streamErr;\n      }), {\n        retries: 1,\n        minTimeout: 0,\n        maxTimeout: 0\n      }));\n    };\n    return fromCache ? fromCache.catch(fromResolved) : fromResolved();\n  }\n  cleanupCached() {\n    return cacache.rm.content(this.cache, this.integrity, this.opts);\n  }\n  [_empty](path) {\n    return getContents({\n      path,\n      depth: 1\n    }).then(contents => Promise.all(contents.map(entry => fs.rm(entry, {\n      recursive: true,\n      force: true\n    }))));\n  }\n  [_mkdir](dest) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      yield _this[_empty](dest);\n      return yield fs.mkdir(dest, {\n        recursive: true\n      });\n    })();\n  }\n\n  // extraction is always the same.  the only difference is where\n  // the tarball comes from.\n  extract(dest) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      yield _this2[_mkdir](dest);\n      return _this2.tarballStream(tarball => _this2[_extract](dest, tarball));\n    })();\n  }\n  [_toFile](dest) {\n    return this.tarballStream(str => new Promise((res, rej) => {\n      const writer = new fsm.WriteStream(dest);\n      str.on('error', er => writer.emit('error', er));\n      writer.on('error', er => rej(er));\n      writer.on('close', () => res({\n        integrity: this.integrity && String(this.integrity),\n        resolved: this.resolved,\n        from: this.from\n      }));\n      str.pipe(writer);\n    }));\n  }\n\n  // don't use this[_mkdir] because we don't want to rimraf anything\n  tarballFile(dest) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const dir = dirname(dest);\n      yield fs.mkdir(dir, {\n        recursive: true\n      });\n      return _this3[_toFile](dest);\n    })();\n  }\n  [_extract](dest, tarball) {\n    const extractor = tar.x(this[_tarxOptions]({\n      cwd: dest\n    }));\n    const p = new Promise((resolve, reject) => {\n      extractor.on('end', () => {\n        resolve({\n          resolved: this.resolved,\n          integrity: this.integrity && String(this.integrity),\n          from: this.from\n        });\n      });\n      extractor.on('error', er => {\n        log.warn('tar', er.message);\n        log.silly('tar', er);\n        reject(er);\n      });\n      tarball.on('error', er => reject(er));\n    });\n    tarball.pipe(extractor);\n    return p;\n  }\n\n  // always ensure that entries are at least as permissive as our configured\n  // dmode/fmode, but never more permissive than the umask allows.\n  [_entryMode](path, mode, type) {\n    const m = /Directory|GNUDumpDir/.test(type) ? this.dmode : /File$/.test(type) ? this.fmode : /* istanbul ignore next - should never happen in a pkg */0;\n\n    // make sure package bins are executable\n    const exe = isPackageBin(this.package, path) ? 0o111 : 0;\n    // always ensure that files are read/writable by the owner\n    return (mode | m) & ~this.umask | exe | 0o600;\n  }\n  [_tarxOptions]({\n    cwd,\n    uid,\n    gid\n  }) {\n    const sawIgnores = new Set();\n    return {\n      cwd,\n      noChmod: true,\n      noMtime: true,\n      filter: (name, entry) => {\n        if (/Link$/.test(entry.type)) {\n          return false;\n        }\n        entry.mode = this[_entryMode](entry.path, entry.mode, entry.type);\n        // this replicates the npm pack behavior where .gitignore files\n        // are treated like .npmignore files, but only if a .npmignore\n        // file is not present.\n        if (/File$/.test(entry.type)) {\n          const base = basename(entry.path);\n          if (base === '.npmignore') {\n            sawIgnores.add(entry.path);\n          } else if (base === '.gitignore' && !this.allowGitIgnore) {\n            // rename, but only if there's not already a .npmignore\n            const ni = entry.path.replace(/\\.gitignore$/, '.npmignore');\n            if (sawIgnores.has(ni)) {\n              return false;\n            }\n            entry.path = ni;\n          }\n          return true;\n        }\n      },\n      strip: 1,\n      onwarn: /* istanbul ignore next - we can trust that tar logs */\n      (code, msg, data) => {\n        log.warn('tar', code, msg);\n        log.silly('tar', code, msg, data);\n      },\n      uid,\n      gid,\n      umask: this.umask\n    };\n  }\n}\nmodule.exports = FetcherBase;\n\n// Child classes\nconst GitFetcher = require('./git.js');\nconst RegistryFetcher = require('./registry.js');\nconst FileFetcher = require('./file.js');\nconst DirFetcher = require('./dir.js');\nconst RemoteFetcher = require('./remote.js');\n\n// Get an appropriate fetcher object from a spec and options\nFetcherBase.get = (rawSpec, opts = {}) => {\n  const spec = npa(rawSpec, opts.where);\n  switch (spec.type) {\n    case 'git':\n      return new GitFetcher(spec, opts);\n    case 'remote':\n      return new RemoteFetcher(spec, opts);\n    case 'version':\n    case 'range':\n    case 'tag':\n    case 'alias':\n      return new RegistryFetcher(spec.subSpec || spec, opts);\n    case 'file':\n      return new FileFetcher(spec, opts);\n    case 'directory':\n      return new DirFetcher(spec, opts);\n    default:\n      throw new TypeError('Unknown spec type: ' + spec.type);\n  }\n};","map":{"version":3,"names":["npa","require","ssri","promisify","basename","dirname","tar","log","retry","fs","fsm","cacache","isPackageBin","removeTrailingSlashes","getContents","readPackageJsonFast","readPackageJson","Minipass","cacheDir","_extract","Symbol","_mkdir","_empty","_toFile","_tarxOptions","_entryMode","_istream","_assertType","_tarballFromCache","_tarballFromResolved","for","_cacheFetches","_readPackageJson","FetcherBase","constructor","spec","opts","TypeError","where","allowGitIgnore","from","registry","name","rawSpec","saveSpec","cache","resolved","defaultIntegrityAlgorithm","integrity","parse","package","type","fmode","dmode","umask","preferOnline","preferOffline","offline","before","fullMetadata","fullReadJson","replaceRegistryHost","defaultTag","npmBin","npmInstallCmd","npmCliConfig","toISOString","i","current","merge","notImplementedError","Error","resolve","Promise","reject","packument","manifest","tarball","tarballStream","stream","concat","then","data","String","get","byDigest","hasIntegrityEmitter","on","istream","integrityStream","err","emit","pipe","middleStream","end","cstream","put","promise","catch","pickIntegrityAlgorithm","pickAlgorithm","isDataCorruptionError","er","code","types","includes","join","isRetriableError","streamHandler","fromCache","warn","cleanupCached","fromResolved","silly","tryAgain","streamErr","retries","minTimeout","maxTimeout","rm","content","path","depth","contents","all","map","entry","recursive","force","dest","mkdir","extract","str","res","rej","writer","WriteStream","tarballFile","dir","extractor","x","cwd","p","message","mode","m","test","exe","uid","gid","sawIgnores","Set","noChmod","noMtime","filter","base","add","ni","replace","has","strip","onwarn","msg","module","exports","GitFetcher","RegistryFetcher","FileFetcher","DirFetcher","RemoteFetcher","subSpec"],"sources":["I:/Angular/angular-blog/node_modules/pacote/lib/fetcher.js"],"sourcesContent":["// This is the base class that the other fetcher types in lib\n// all descend from.\n// It handles the unpacking and retry logic that is shared among\n// all of the other Fetcher types.\n\nconst npa = require('npm-package-arg')\nconst ssri = require('ssri')\nconst { promisify } = require('util')\nconst { basename, dirname } = require('path')\nconst tar = require('tar')\nconst log = require('proc-log')\nconst retry = require('promise-retry')\nconst fs = require('fs/promises')\nconst fsm = require('fs-minipass')\nconst cacache = require('cacache')\nconst isPackageBin = require('./util/is-package-bin.js')\nconst removeTrailingSlashes = require('./util/trailing-slashes.js')\nconst getContents = require('@npmcli/installed-package-contents')\nconst readPackageJsonFast = require('read-package-json-fast')\nconst readPackageJson = promisify(require('read-package-json'))\nconst Minipass = require('minipass')\n\nconst cacheDir = require('./util/cache-dir.js')\n\n// Private methods.\n// Child classes should not have to override these.\n// Users should never call them.\nconst _extract = Symbol('_extract')\nconst _mkdir = Symbol('_mkdir')\nconst _empty = Symbol('_empty')\nconst _toFile = Symbol('_toFile')\nconst _tarxOptions = Symbol('_tarxOptions')\nconst _entryMode = Symbol('_entryMode')\nconst _istream = Symbol('_istream')\nconst _assertType = Symbol('_assertType')\nconst _tarballFromCache = Symbol('_tarballFromCache')\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved')\nconst _cacheFetches = Symbol.for('pacote.Fetcher._cacheFetches')\nconst _readPackageJson = Symbol.for('package.Fetcher._readPackageJson')\n\nclass FetcherBase {\n  constructor (spec, opts) {\n    if (!opts || typeof opts !== 'object') {\n      throw new TypeError('options object is required')\n    }\n    this.spec = npa(spec, opts.where)\n\n    this.allowGitIgnore = !!opts.allowGitIgnore\n\n    // a bit redundant because presumably the caller already knows this,\n    // but it makes it easier to not have to keep track of the requested\n    // spec when we're dispatching thousands of these at once, and normalizing\n    // is nice.  saveSpec is preferred if set, because it turns stuff like\n    // x/y#committish into github:x/y#committish.  use name@rawSpec for\n    // registry deps so that we turn xyz and xyz@ -> xyz@\n    this.from = this.spec.registry\n      ? `${this.spec.name}@${this.spec.rawSpec}` : this.spec.saveSpec\n\n    this[_assertType]()\n    // clone the opts object so that others aren't upset when we mutate it\n    // by adding/modifying the integrity value.\n    this.opts = { ...opts }\n\n    this.cache = opts.cache || cacheDir()\n    this.resolved = opts.resolved || null\n\n    // default to caching/verifying with sha512, that's what we usually have\n    // need to change this default, or start overriding it, when sha512\n    // is no longer strong enough.\n    this.defaultIntegrityAlgorithm = opts.defaultIntegrityAlgorithm || 'sha512'\n\n    if (typeof opts.integrity === 'string') {\n      this.opts.integrity = ssri.parse(opts.integrity)\n    }\n\n    this.package = null\n    this.type = this.constructor.name\n    this.fmode = opts.fmode || 0o666\n    this.dmode = opts.dmode || 0o777\n    // we don't need a default umask, because we don't chmod files coming\n    // out of package tarballs.  they're forced to have a mode that is\n    // valid, regardless of what's in the tarball entry, and then we let\n    // the process's umask setting do its job.  but if configured, we do\n    // respect it.\n    this.umask = opts.umask || 0\n\n    this.preferOnline = !!opts.preferOnline\n    this.preferOffline = !!opts.preferOffline\n    this.offline = !!opts.offline\n\n    this.before = opts.before\n    this.fullMetadata = this.before ? true : !!opts.fullMetadata\n    this.fullReadJson = !!opts.fullReadJson\n    if (this.fullReadJson) {\n      this[_readPackageJson] = readPackageJson\n    } else {\n      this[_readPackageJson] = readPackageJsonFast\n    }\n\n    // rrh is a registry hostname or 'never' or 'always'\n    // defaults to registry.npmjs.org\n    this.replaceRegistryHost = (!opts.replaceRegistryHost || opts.replaceRegistryHost === 'npmjs') ?\n      'registry.npmjs.org' : opts.replaceRegistryHost\n\n    this.defaultTag = opts.defaultTag || 'latest'\n    this.registry = removeTrailingSlashes(opts.registry || 'https://registry.npmjs.org')\n\n    // command to run 'prepare' scripts on directories and git dirs\n    // To use pacote with yarn, for example, set npmBin to 'yarn'\n    // and npmCliConfig with yarn's equivalents.\n    this.npmBin = opts.npmBin || 'npm'\n\n    // command to install deps for preparing\n    this.npmInstallCmd = opts.npmInstallCmd || ['install', '--force']\n\n    // XXX fill more of this in based on what we know from this.opts\n    // we explicitly DO NOT fill in --tag, though, since we are often\n    // going to be packing in the context of a publish, which may set\n    // a dist-tag, but certainly wants to keep defaulting to latest.\n    this.npmCliConfig = opts.npmCliConfig || [\n      `--cache=${dirname(this.cache)}`,\n      `--prefer-offline=${!!this.preferOffline}`,\n      `--prefer-online=${!!this.preferOnline}`,\n      `--offline=${!!this.offline}`,\n      ...(this.before ? [`--before=${this.before.toISOString()}`] : []),\n      '--no-progress',\n      '--no-save',\n      '--no-audit',\n      // override any omit settings from the environment\n      '--include=dev',\n      '--include=peer',\n      '--include=optional',\n      // we need the actual things, not just the lockfile\n      '--no-package-lock-only',\n      '--no-dry-run',\n    ]\n  }\n\n  get integrity () {\n    return this.opts.integrity || null\n  }\n\n  set integrity (i) {\n    if (!i) {\n      return\n    }\n\n    i = ssri.parse(i)\n    const current = this.opts.integrity\n\n    // do not ever update an existing hash value, but do\n    // merge in NEW algos and hashes that we don't already have.\n    if (current) {\n      current.merge(i)\n    } else {\n      this.opts.integrity = i\n    }\n  }\n\n  get notImplementedError () {\n    return new Error('not implemented in this fetcher type: ' + this.type)\n  }\n\n  // override in child classes\n  // Returns a Promise that resolves to this.resolved string value\n  resolve () {\n    return this.resolved ? Promise.resolve(this.resolved)\n      : Promise.reject(this.notImplementedError)\n  }\n\n  packument () {\n    return Promise.reject(this.notImplementedError)\n  }\n\n  // override in child class\n  // returns a manifest containing:\n  // - name\n  // - version\n  // - _resolved\n  // - _integrity\n  // - plus whatever else was in there (corgi, full metadata, or pj file)\n  manifest () {\n    return Promise.reject(this.notImplementedError)\n  }\n\n  // private, should be overridden.\n  // Note that they should *not* calculate or check integrity or cache,\n  // but *just*  return the raw tarball data stream.\n  [_tarballFromResolved] () {\n    throw this.notImplementedError\n  }\n\n  // public, should not be overridden\n  tarball () {\n    return this.tarballStream(stream => stream.concat().then(data => {\n      data.integrity = this.integrity && String(this.integrity)\n      data.resolved = this.resolved\n      data.from = this.from\n      return data\n    }))\n  }\n\n  // private\n  // Note: cacache will raise a EINTEGRITY error if the integrity doesn't match\n  [_tarballFromCache] () {\n    return cacache.get.stream.byDigest(this.cache, this.integrity, this.opts)\n  }\n\n  get [_cacheFetches] () {\n    return true\n  }\n\n  [_istream] (stream) {\n    // if not caching this, just return it\n    if (!this.opts.cache || !this[_cacheFetches]) {\n      // instead of creating a new integrity stream, we only piggyback on the\n      // provided stream's events\n      if (stream.hasIntegrityEmitter) {\n        stream.on('integrity', i => this.integrity = i)\n        return stream\n      }\n\n      const istream = ssri.integrityStream(this.opts)\n      istream.on('integrity', i => this.integrity = i)\n      stream.on('error', err => istream.emit('error', err))\n      return stream.pipe(istream)\n    }\n\n    // we have to return a stream that gets ALL the data, and proxies errors,\n    // but then pipe from the original tarball stream into the cache as well.\n    // To do this without losing any data, and since the cacache put stream\n    // is not a passthrough, we have to pipe from the original stream into\n    // the cache AFTER we pipe into the middleStream.  Since the cache stream\n    // has an asynchronous flush to write its contents to disk, we need to\n    // defer the middleStream end until the cache stream ends.\n    const middleStream = new Minipass()\n    stream.on('error', err => middleStream.emit('error', err))\n    stream.pipe(middleStream, { end: false })\n    const cstream = cacache.put.stream(\n      this.opts.cache,\n      `pacote:tarball:${this.from}`,\n      this.opts\n    )\n    cstream.on('integrity', i => this.integrity = i)\n    cstream.on('error', err => stream.emit('error', err))\n    stream.pipe(cstream)\n\n    // eslint-disable-next-line promise/catch-or-return\n    cstream.promise().catch(() => {}).then(() => middleStream.end())\n    return middleStream\n  }\n\n  pickIntegrityAlgorithm () {\n    return this.integrity ? this.integrity.pickAlgorithm(this.opts)\n      : this.defaultIntegrityAlgorithm\n  }\n\n  // TODO: check error class, once those are rolled out to our deps\n  isDataCorruptionError (er) {\n    return er.code === 'EINTEGRITY' || er.code === 'Z_DATA_ERROR'\n  }\n\n  // override the types getter\n  get types () {\n    return false\n  }\n\n  [_assertType] () {\n    if (this.types && !this.types.includes(this.spec.type)) {\n      throw new TypeError(`Wrong spec type (${\n        this.spec.type\n      }) for ${\n        this.constructor.name\n      }. Supported types: ${this.types.join(', ')}`)\n    }\n  }\n\n  // We allow ENOENTs from cacache, but not anywhere else.\n  // An ENOENT trying to read a tgz file, for example, is Right Out.\n  isRetriableError (er) {\n    // TODO: check error class, once those are rolled out to our deps\n    return this.isDataCorruptionError(er) ||\n      er.code === 'ENOENT' ||\n      er.code === 'EISDIR'\n  }\n\n  // Mostly internal, but has some uses\n  // Pass in a function which returns a promise\n  // Function will be called 1 or more times with streams that may fail.\n  // Retries:\n  // Function MUST handle errors on the stream by rejecting the promise,\n  // so that retry logic can pick it up and either retry or fail whatever\n  // promise it was making (ie, failing extraction, etc.)\n  //\n  // The return value of this method is a Promise that resolves the same\n  // as whatever the streamHandler resolves to.\n  //\n  // This should never be overridden by child classes, but it is public.\n  tarballStream (streamHandler) {\n    // Only short-circuit via cache if we have everything else we'll need,\n    // and the user has not expressed a preference for checking online.\n\n    const fromCache = (\n      !this.preferOnline &&\n      this.integrity &&\n      this.resolved\n    ) ? streamHandler(this[_tarballFromCache]()).catch(er => {\n        if (this.isDataCorruptionError(er)) {\n          log.warn('tarball', `cached data for ${\n          this.spec\n        } (${this.integrity}) seems to be corrupted. Refreshing cache.`)\n          return this.cleanupCached().then(() => {\n            throw er\n          })\n        } else {\n          throw er\n        }\n      }) : null\n\n    const fromResolved = er => {\n      if (er) {\n        if (!this.isRetriableError(er)) {\n          throw er\n        }\n        log.silly('tarball', `no local data for ${\n          this.spec\n        }. Extracting by manifest.`)\n      }\n      return this.resolve().then(() => retry(tryAgain =>\n        streamHandler(this[_istream](this[_tarballFromResolved]()))\n          .catch(streamErr => {\n          // Most likely data integrity.  A cache ENOENT error is unlikely\n          // here, since we're definitely not reading from the cache, but it\n          // IS possible that the fetch subsystem accessed the cache, and the\n          // entry got blown away or something.  Try one more time to be sure.\n            if (this.isRetriableError(streamErr)) {\n              log.warn('tarball', `tarball data for ${\n              this.spec\n            } (${this.integrity}) seems to be corrupted. Trying again.`)\n              return this.cleanupCached().then(() => tryAgain(streamErr))\n            }\n            throw streamErr\n          }), { retries: 1, minTimeout: 0, maxTimeout: 0 }))\n    }\n\n    return fromCache ? fromCache.catch(fromResolved) : fromResolved()\n  }\n\n  cleanupCached () {\n    return cacache.rm.content(this.cache, this.integrity, this.opts)\n  }\n\n  [_empty] (path) {\n    return getContents({ path, depth: 1 }).then(contents => Promise.all(\n      contents.map(entry => fs.rm(entry, { recursive: true, force: true }))))\n  }\n\n  async [_mkdir] (dest) {\n    await this[_empty](dest)\n    return await fs.mkdir(dest, { recursive: true })\n  }\n\n  // extraction is always the same.  the only difference is where\n  // the tarball comes from.\n  async extract (dest) {\n    await this[_mkdir](dest)\n    return this.tarballStream((tarball) => this[_extract](dest, tarball))\n  }\n\n  [_toFile] (dest) {\n    return this.tarballStream(str => new Promise((res, rej) => {\n      const writer = new fsm.WriteStream(dest)\n      str.on('error', er => writer.emit('error', er))\n      writer.on('error', er => rej(er))\n      writer.on('close', () => res({\n        integrity: this.integrity && String(this.integrity),\n        resolved: this.resolved,\n        from: this.from,\n      }))\n      str.pipe(writer)\n    }))\n  }\n\n  // don't use this[_mkdir] because we don't want to rimraf anything\n  async tarballFile (dest) {\n    const dir = dirname(dest)\n    await fs.mkdir(dir, { recursive: true })\n    return this[_toFile](dest)\n  }\n\n  [_extract] (dest, tarball) {\n    const extractor = tar.x(this[_tarxOptions]({ cwd: dest }))\n    const p = new Promise((resolve, reject) => {\n      extractor.on('end', () => {\n        resolve({\n          resolved: this.resolved,\n          integrity: this.integrity && String(this.integrity),\n          from: this.from,\n        })\n      })\n\n      extractor.on('error', er => {\n        log.warn('tar', er.message)\n        log.silly('tar', er)\n        reject(er)\n      })\n\n      tarball.on('error', er => reject(er))\n    })\n\n    tarball.pipe(extractor)\n    return p\n  }\n\n  // always ensure that entries are at least as permissive as our configured\n  // dmode/fmode, but never more permissive than the umask allows.\n  [_entryMode] (path, mode, type) {\n    const m = /Directory|GNUDumpDir/.test(type) ? this.dmode\n      : /File$/.test(type) ? this.fmode\n      : /* istanbul ignore next - should never happen in a pkg */ 0\n\n    // make sure package bins are executable\n    const exe = isPackageBin(this.package, path) ? 0o111 : 0\n    // always ensure that files are read/writable by the owner\n    return ((mode | m) & ~this.umask) | exe | 0o600\n  }\n\n  [_tarxOptions] ({ cwd, uid, gid }) {\n    const sawIgnores = new Set()\n    return {\n      cwd,\n      noChmod: true,\n      noMtime: true,\n      filter: (name, entry) => {\n        if (/Link$/.test(entry.type)) {\n          return false\n        }\n        entry.mode = this[_entryMode](entry.path, entry.mode, entry.type)\n        // this replicates the npm pack behavior where .gitignore files\n        // are treated like .npmignore files, but only if a .npmignore\n        // file is not present.\n        if (/File$/.test(entry.type)) {\n          const base = basename(entry.path)\n          if (base === '.npmignore') {\n            sawIgnores.add(entry.path)\n          } else if (base === '.gitignore' && !this.allowGitIgnore) {\n            // rename, but only if there's not already a .npmignore\n            const ni = entry.path.replace(/\\.gitignore$/, '.npmignore')\n            if (sawIgnores.has(ni)) {\n              return false\n            }\n            entry.path = ni\n          }\n          return true\n        }\n      },\n      strip: 1,\n      onwarn: /* istanbul ignore next - we can trust that tar logs */\n      (code, msg, data) => {\n        log.warn('tar', code, msg)\n        log.silly('tar', code, msg, data)\n      },\n      uid,\n      gid,\n      umask: this.umask,\n    }\n  }\n}\n\nmodule.exports = FetcherBase\n\n// Child classes\nconst GitFetcher = require('./git.js')\nconst RegistryFetcher = require('./registry.js')\nconst FileFetcher = require('./file.js')\nconst DirFetcher = require('./dir.js')\nconst RemoteFetcher = require('./remote.js')\n\n// Get an appropriate fetcher object from a spec and options\nFetcherBase.get = (rawSpec, opts = {}) => {\n  const spec = npa(rawSpec, opts.where)\n  switch (spec.type) {\n    case 'git':\n      return new GitFetcher(spec, opts)\n\n    case 'remote':\n      return new RemoteFetcher(spec, opts)\n\n    case 'version':\n    case 'range':\n    case 'tag':\n    case 'alias':\n      return new RegistryFetcher(spec.subSpec || spec, opts)\n\n    case 'file':\n      return new FileFetcher(spec, opts)\n\n    case 'directory':\n      return new DirFetcher(spec, opts)\n\n    default:\n      throw new TypeError('Unknown spec type: ' + spec.type)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}