{"ast":null,"code":"const Fetcher = require('./fetcher.js');\nconst fsm = require('fs-minipass');\nconst cacache = require('cacache');\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved');\nconst _exeBins = Symbol('_exeBins');\nconst {\n  resolve\n} = require('path');\nconst fs = require('fs');\nconst _readPackageJson = Symbol.for('package.Fetcher._readPackageJson');\nclass FileFetcher extends Fetcher {\n  constructor(spec, opts) {\n    super(spec, opts);\n    // just the fully resolved filename\n    this.resolved = this.spec.fetchSpec;\n  }\n  get types() {\n    return ['file'];\n  }\n  manifest() {\n    if (this.package) {\n      return Promise.resolve(this.package);\n    }\n\n    // have to unpack the tarball for this.\n    return cacache.tmp.withTmp(this.cache, this.opts, dir => this.extract(dir).then(() => this[_readPackageJson](dir + '/package.json')).then(mani => this.package = {\n      ...mani,\n      _integrity: this.integrity && String(this.integrity),\n      _resolved: this.resolved,\n      _from: this.from\n    }));\n  }\n  [_exeBins](pkg, dest) {\n    if (!pkg.bin) {\n      return Promise.resolve();\n    }\n    return Promise.all(Object.keys(pkg.bin).map(k => new Promise(res => {\n      const script = resolve(dest, pkg.bin[k]);\n      // Best effort.  Ignore errors here, the only result is that\n      // a bin script is not executable.  But if it's missing or\n      // something, we just leave it for a later stage to trip over\n      // when we can provide a more useful contextual error.\n      fs.stat(script, (er, st) => {\n        if (er) {\n          return res();\n        }\n        const mode = st.mode | 0o111;\n        if (mode === st.mode) {\n          return res();\n        }\n        fs.chmod(script, mode, res);\n      });\n    })));\n  }\n  extract(dest) {\n    // if we've already loaded the manifest, then the super got it.\n    // but if not, read the unpacked manifest and chmod properly.\n    return super.extract(dest).then(result => this.package ? result : this[_readPackageJson](dest + '/package.json').then(pkg => this[_exeBins](pkg, dest)).then(() => result));\n  }\n  [_tarballFromResolved]() {\n    // create a read stream and return it\n    return new fsm.ReadStream(this.resolved);\n  }\n  packument() {\n    // simulate based on manifest\n    return this.manifest().then(mani => ({\n      name: mani.name,\n      'dist-tags': {\n        [this.defaultTag]: mani.version\n      },\n      versions: {\n        [mani.version]: {\n          ...mani,\n          dist: {\n            tarball: `file:${this.resolved}`,\n            integrity: this.integrity && String(this.integrity)\n          }\n        }\n      }\n    }));\n  }\n}\nmodule.exports = FileFetcher;","map":{"version":3,"names":["Fetcher","require","fsm","cacache","_tarballFromResolved","Symbol","for","_exeBins","resolve","fs","_readPackageJson","FileFetcher","constructor","spec","opts","resolved","fetchSpec","types","manifest","package","Promise","tmp","withTmp","cache","dir","extract","then","mani","_integrity","integrity","String","_resolved","_from","from","pkg","dest","bin","all","Object","keys","map","k","res","script","stat","er","st","mode","chmod","result","ReadStream","packument","name","defaultTag","version","versions","dist","tarball","module","exports"],"sources":["I:/Angular/angular-blog/node_modules/pacote/lib/file.js"],"sourcesContent":["const Fetcher = require('./fetcher.js')\nconst fsm = require('fs-minipass')\nconst cacache = require('cacache')\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved')\nconst _exeBins = Symbol('_exeBins')\nconst { resolve } = require('path')\nconst fs = require('fs')\nconst _readPackageJson = Symbol.for('package.Fetcher._readPackageJson')\n\nclass FileFetcher extends Fetcher {\n  constructor (spec, opts) {\n    super(spec, opts)\n    // just the fully resolved filename\n    this.resolved = this.spec.fetchSpec\n  }\n\n  get types () {\n    return ['file']\n  }\n\n  manifest () {\n    if (this.package) {\n      return Promise.resolve(this.package)\n    }\n\n    // have to unpack the tarball for this.\n    return cacache.tmp.withTmp(this.cache, this.opts, dir =>\n      this.extract(dir)\n        .then(() => this[_readPackageJson](dir + '/package.json'))\n        .then(mani => this.package = {\n          ...mani,\n          _integrity: this.integrity && String(this.integrity),\n          _resolved: this.resolved,\n          _from: this.from,\n        }))\n  }\n\n  [_exeBins] (pkg, dest) {\n    if (!pkg.bin) {\n      return Promise.resolve()\n    }\n\n    return Promise.all(Object.keys(pkg.bin).map(k => new Promise(res => {\n      const script = resolve(dest, pkg.bin[k])\n      // Best effort.  Ignore errors here, the only result is that\n      // a bin script is not executable.  But if it's missing or\n      // something, we just leave it for a later stage to trip over\n      // when we can provide a more useful contextual error.\n      fs.stat(script, (er, st) => {\n        if (er) {\n          return res()\n        }\n        const mode = st.mode | 0o111\n        if (mode === st.mode) {\n          return res()\n        }\n        fs.chmod(script, mode, res)\n      })\n    })))\n  }\n\n  extract (dest) {\n    // if we've already loaded the manifest, then the super got it.\n    // but if not, read the unpacked manifest and chmod properly.\n    return super.extract(dest)\n      .then(result => this.package ? result\n      : this[_readPackageJson](dest + '/package.json').then(pkg =>\n        this[_exeBins](pkg, dest)).then(() => result))\n  }\n\n  [_tarballFromResolved] () {\n    // create a read stream and return it\n    return new fsm.ReadStream(this.resolved)\n  }\n\n  packument () {\n    // simulate based on manifest\n    return this.manifest().then(mani => ({\n      name: mani.name,\n      'dist-tags': {\n        [this.defaultTag]: mani.version,\n      },\n      versions: {\n        [mani.version]: {\n          ...mani,\n          dist: {\n            tarball: `file:${this.resolved}`,\n            integrity: this.integrity && String(this.integrity),\n          },\n        },\n      },\n    }))\n  }\n}\n\nmodule.exports = FileFetcher\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}