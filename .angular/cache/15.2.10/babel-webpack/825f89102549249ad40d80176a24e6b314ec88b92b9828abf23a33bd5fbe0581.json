{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _asyncToGenerator = require(\"I:/Angular/angular-blog/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UpdateCommandModule = void 0;\nconst schematics_1 = require(\"@angular-devkit/schematics\");\nconst tools_1 = require(\"@angular-devkit/schematics/tools\");\nconst child_process_1 = require(\"child_process\");\nconst fs_1 = require(\"fs\");\nconst module_1 = require(\"module\");\nconst npm_package_arg_1 = __importDefault(require(\"npm-package-arg\"));\nconst npm_pick_manifest_1 = __importDefault(require(\"npm-pick-manifest\"));\nconst path = __importStar(require(\"path\"));\nconst path_1 = require(\"path\");\nconst semver = __importStar(require(\"semver\"));\nconst workspace_schema_1 = require(\"../../../lib/config/workspace-schema\");\nconst command_module_1 = require(\"../../command-builder/command-module\");\nconst schematic_engine_host_1 = require(\"../../command-builder/utilities/schematic-engine-host\");\nconst schematic_workflow_1 = require(\"../../command-builder/utilities/schematic-workflow\");\nconst color_1 = require(\"../../utilities/color\");\nconst environment_options_1 = require(\"../../utilities/environment-options\");\nconst error_1 = require(\"../../utilities/error\");\nconst log_file_1 = require(\"../../utilities/log-file\");\nconst package_metadata_1 = require(\"../../utilities/package-metadata\");\nconst package_tree_1 = require(\"../../utilities/package-tree\");\nconst version_1 = require(\"../../utilities/version\");\nconst ANGULAR_PACKAGES_REGEXP = /^@(?:angular|nguniversal)\\//;\nconst UPDATE_SCHEMATIC_COLLECTION = path.join(__dirname, 'schematic/collection.json');\nclass UpdateCommandModule extends command_module_1.CommandModule {\n  constructor() {\n    super(...arguments);\n    this.scope = command_module_1.CommandScope.In;\n    this.shouldReportAnalytics = false;\n    this.command = 'update [packages..]';\n    this.describe = 'Updates your workspace and its dependencies. See https://update.angular.io/.';\n    this.longDescriptionPath = (0, path_1.join)(__dirname, 'long-description.md');\n  }\n  builder(localYargs) {\n    return localYargs.positional('packages', {\n      description: 'The names of package(s) to update.',\n      type: 'string',\n      array: true\n    }).option('force', {\n      description: 'Ignore peer dependency version mismatches.',\n      type: 'boolean',\n      default: false\n    }).option('next', {\n      description: 'Use the prerelease version, including beta and RCs.',\n      type: 'boolean',\n      default: false\n    }).option('migrate-only', {\n      description: 'Only perform a migration, do not update the installed version.',\n      type: 'boolean'\n    }).option('name', {\n      description: 'The name of the migration to run. ' + `Only available with a single package being updated, and only with 'migrate-only' option.`,\n      type: 'string',\n      implies: ['migrate-only'],\n      conflicts: ['to', 'from']\n    }).option('from', {\n      description: 'Version from which to migrate from. ' + `Only available with a single package being updated, and only with 'migrate-only'.`,\n      type: 'string',\n      implies: ['to', 'migrate-only'],\n      conflicts: ['name']\n    }).option('to', {\n      describe: 'Version up to which to apply migrations. Only available with a single package being updated, ' + `and only with 'migrate-only' option. Requires 'from' to be specified. Default to the installed version detected.`,\n      type: 'string',\n      implies: ['from', 'migrate-only'],\n      conflicts: ['name']\n    }).option('allow-dirty', {\n      describe: 'Whether to allow updating when the repository contains modified or untracked files.',\n      type: 'boolean',\n      default: false\n    }).option('verbose', {\n      describe: 'Display additional details about internal operations during execution.',\n      type: 'boolean',\n      default: false\n    }).option('create-commits', {\n      describe: 'Create source control commits for updates and migrations.',\n      type: 'boolean',\n      alias: ['C'],\n      default: false\n    }).check(({\n      packages,\n      'allow-dirty': allowDirty,\n      'migrate-only': migrateOnly\n    }) => {\n      const {\n        logger\n      } = this.context;\n      // This allows the user to easily reset any changes from the update.\n      if ((packages === null || packages === void 0 ? void 0 : packages.length) && !this.checkCleanGit()) {\n        if (allowDirty) {\n          logger.warn('Repository is not clean. Update changes will be mixed with pre-existing changes.');\n        } else {\n          throw new command_module_1.CommandModuleError('Repository is not clean. Please commit or stash any changes before updating.');\n        }\n      }\n      if (migrateOnly) {\n        if ((packages === null || packages === void 0 ? void 0 : packages.length) !== 1) {\n          throw new command_module_1.CommandModuleError(`A single package must be specified when using the 'migrate-only' option.`);\n        }\n      }\n      return true;\n    }).strict();\n  }\n  run(options) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c;\n      const {\n        logger,\n        packageManager\n      } = _this.context;\n      packageManager.ensureCompatibility();\n      // Check if the current installed CLI version is older than the latest compatible version.\n      // Skip when running `ng update` without a package name as this will not trigger an actual update.\n      if (!environment_options_1.disableVersionCheck && ((_a = options.packages) === null || _a === void 0 ? void 0 : _a.length)) {\n        const cliVersionToInstall = yield _this.checkCLIVersion(options.packages, options.verbose, options.next);\n        if (cliVersionToInstall) {\n          logger.warn('The installed Angular CLI version is outdated.\\n' + `Installing a temporary Angular CLI versioned ${cliVersionToInstall} to perform the update.`);\n          return _this.runTempBinary(`@angular/cli@${cliVersionToInstall}`, process.argv.slice(2));\n        }\n      }\n      const packages = [];\n      for (const request of (_b = options.packages) !== null && _b !== void 0 ? _b : []) {\n        try {\n          const packageIdentifier = (0, npm_package_arg_1.default)(request);\n          // only registry identifiers are supported\n          if (!packageIdentifier.registry) {\n            logger.error(`Package '${request}' is not a registry package identifer.`);\n            return 1;\n          }\n          if (packages.some(v => v.name === packageIdentifier.name)) {\n            logger.error(`Duplicate package '${packageIdentifier.name}' specified.`);\n            return 1;\n          }\n          if (options.migrateOnly && packageIdentifier.rawSpec) {\n            logger.warn('Package specifier has no effect when using \"migrate-only\" option.');\n          }\n          // If next option is used and no specifier supplied, use next tag\n          if (options.next && !packageIdentifier.rawSpec) {\n            packageIdentifier.fetchSpec = 'next';\n          }\n          packages.push(packageIdentifier);\n        } catch (e) {\n          (0, error_1.assertIsError)(e);\n          logger.error(e.message);\n          return 1;\n        }\n      }\n      logger.info(`Using package manager: ${color_1.colors.grey(packageManager.name)}`);\n      logger.info('Collecting installed dependencies...');\n      const rootDependencies = yield (0, package_tree_1.getProjectDependencies)(_this.context.root);\n      logger.info(`Found ${rootDependencies.size} dependencies.`);\n      const workflow = new tools_1.NodeWorkflow(_this.context.root, {\n        packageManager: packageManager.name,\n        packageManagerForce: _this.packageManagerForce(options.verbose),\n        // __dirname -> favor @schematics/update from this package\n        // Otherwise, use packages from the active workspace (migrations)\n        resolvePaths: [__dirname, _this.context.root],\n        schemaValidation: true,\n        engineHostCreator: options => new schematic_engine_host_1.SchematicEngineHost(options.resolvePaths)\n      });\n      if (packages.length === 0) {\n        // Show status\n        const {\n          success\n        } = yield _this.executeSchematic(workflow, UPDATE_SCHEMATIC_COLLECTION, 'update', {\n          force: options.force,\n          next: options.next,\n          verbose: options.verbose,\n          packageManager: packageManager.name,\n          packages: []\n        });\n        return success ? 0 : 1;\n      }\n      return options.migrateOnly ? _this.migrateOnly(workflow, ((_c = options.packages) !== null && _c !== void 0 ? _c : [])[0], rootDependencies, options) : _this.updatePackagesAndMigrate(workflow, rootDependencies, options, packages);\n    })();\n  }\n  executeSchematic(workflow, collection, schematic, options = {}) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        logger\n      } = _this2.context;\n      const workflowSubscription = (0, schematic_workflow_1.subscribeToWorkflow)(workflow, logger);\n      // TODO: Allow passing a schematic instance directly\n      try {\n        yield workflow.execute({\n          collection,\n          schematic,\n          options,\n          logger\n        }).toPromise();\n        return {\n          success: !workflowSubscription.error,\n          files: workflowSubscription.files\n        };\n      } catch (e) {\n        if (e instanceof schematics_1.UnsuccessfulWorkflowExecution) {\n          logger.error(`${color_1.colors.symbols.cross} Migration failed. See above for further details.\\n`);\n        } else {\n          (0, error_1.assertIsError)(e);\n          const logPath = (0, log_file_1.writeErrorToLogFile)(e);\n          logger.fatal(`${color_1.colors.symbols.cross} Migration failed: ${e.message}\\n` + `  See \"${logPath}\" for further details.\\n`);\n        }\n        return {\n          success: false,\n          files: workflowSubscription.files\n        };\n      } finally {\n        workflowSubscription.unsubscribe();\n      }\n    })();\n  }\n  /**\n   * @return Whether or not the migration was performed successfully.\n   */\n  executeMigration(workflow, packageName, collectionPath, migrationName, commit) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        logger\n      } = _this3.context;\n      const collection = workflow.engine.createCollection(collectionPath);\n      const name = collection.listSchematicNames().find(name => name === migrationName);\n      if (!name) {\n        logger.error(`Cannot find migration '${migrationName}' in '${packageName}'.`);\n        return 1;\n      }\n      logger.info(color_1.colors.cyan(`** Executing '${migrationName}' of package '${packageName}' **\\n`));\n      const schematic = workflow.engine.createSchematic(name, collection);\n      return _this3.executePackageMigrations(workflow, [schematic.description], packageName, commit);\n    })();\n  }\n  /**\n   * @return Whether or not the migrations were performed successfully.\n   */\n  executeMigrations(workflow, packageName, collectionPath, from, to, commit) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const collection = workflow.engine.createCollection(collectionPath);\n      const migrationRange = new semver.Range('>' + (semver.prerelease(from) ? from.split('-')[0] + '-0' : from) + ' <=' + to.split('-')[0]);\n      const migrations = [];\n      for (const name of collection.listSchematicNames()) {\n        const schematic = workflow.engine.createSchematic(name, collection);\n        const description = schematic.description;\n        description.version = coerceVersionNumber(description.version);\n        if (!description.version) {\n          continue;\n        }\n        if (semver.satisfies(description.version, migrationRange, {\n          includePrerelease: true\n        })) {\n          migrations.push(description);\n        }\n      }\n      if (migrations.length === 0) {\n        return 0;\n      }\n      migrations.sort((a, b) => semver.compare(a.version, b.version) || a.name.localeCompare(b.name));\n      _this4.context.logger.info(color_1.colors.cyan(`** Executing migrations of package '${packageName}' **\\n`));\n      return _this4.executePackageMigrations(workflow, migrations, packageName, commit);\n    })();\n  }\n  executePackageMigrations(workflow, migrations, packageName, commit = false) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        logger\n      } = _this5.context;\n      for (const migration of migrations) {\n        const [title, ...description] = migration.description.split('. ');\n        logger.info(color_1.colors.cyan(color_1.colors.symbols.pointer) + ' ' + color_1.colors.bold(title.endsWith('.') ? title : title + '.'));\n        if (description.length) {\n          logger.info('  ' + description.join('.\\n  '));\n        }\n        const result = yield _this5.executeSchematic(workflow, migration.collection.name, migration.name);\n        if (!result.success) {\n          return 1;\n        }\n        logger.info('  Migration completed.');\n        // Commit migration\n        if (commit) {\n          const commitPrefix = `${packageName} migration - ${migration.name}`;\n          const commitMessage = migration.description ? `${commitPrefix}\\n\\n${migration.description}` : commitPrefix;\n          const committed = _this5.commit(commitMessage);\n          if (!committed) {\n            // Failed to commit, something went wrong. Abort the update.\n            return 1;\n          }\n        }\n        logger.info(''); // Extra trailing newline.\n      }\n\n      return 0;\n    })();\n  }\n  migrateOnly(workflow, packageName, rootDependencies, options) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        logger\n      } = _this6.context;\n      const packageDependency = rootDependencies.get(packageName);\n      let packagePath = packageDependency === null || packageDependency === void 0 ? void 0 : packageDependency.path;\n      let packageNode = packageDependency === null || packageDependency === void 0 ? void 0 : packageDependency.package;\n      if (packageDependency && !packageNode) {\n        logger.error('Package found in package.json but is not installed.');\n        return 1;\n      } else if (!packageDependency) {\n        // Allow running migrations on transitively installed dependencies\n        // There can technically be nested multiple versions\n        // TODO: If multiple, this should find all versions and ask which one to use\n        const packageJson = (0, package_tree_1.findPackageJson)(_this6.context.root, packageName);\n        if (packageJson) {\n          packagePath = path.dirname(packageJson);\n          packageNode = yield (0, package_tree_1.readPackageJson)(packageJson);\n        }\n      }\n      if (!packageNode || !packagePath) {\n        logger.error('Package is not installed.');\n        return 1;\n      }\n      const updateMetadata = packageNode['ng-update'];\n      let migrations = updateMetadata === null || updateMetadata === void 0 ? void 0 : updateMetadata.migrations;\n      if (migrations === undefined) {\n        logger.error('Package does not provide migrations.');\n        return 1;\n      } else if (typeof migrations !== 'string') {\n        logger.error('Package contains a malformed migrations field.');\n        return 1;\n      } else if (path.posix.isAbsolute(migrations) || path.win32.isAbsolute(migrations)) {\n        logger.error('Package contains an invalid migrations field. Absolute paths are not permitted.');\n        return 1;\n      }\n      // Normalize slashes\n      migrations = migrations.replace(/\\\\/g, '/');\n      if (migrations.startsWith('../')) {\n        logger.error('Package contains an invalid migrations field. Paths outside the package root are not permitted.');\n        return 1;\n      }\n      // Check if it is a package-local location\n      const localMigrations = path.join(packagePath, migrations);\n      if ((0, fs_1.existsSync)(localMigrations)) {\n        migrations = localMigrations;\n      } else {\n        // Try to resolve from package location.\n        // This avoids issues with package hoisting.\n        try {\n          const packageRequire = (0, module_1.createRequire)(packagePath + '/');\n          migrations = packageRequire.resolve(migrations);\n        } catch (e) {\n          (0, error_1.assertIsError)(e);\n          if (e.code === 'MODULE_NOT_FOUND') {\n            logger.error('Migrations for package were not found.');\n          } else {\n            logger.error(`Unable to resolve migrations for package.  [${e.message}]`);\n          }\n          return 1;\n        }\n      }\n      if (options.name) {\n        return _this6.executeMigration(workflow, packageName, migrations, options.name, options.createCommits);\n      }\n      const from = coerceVersionNumber(options.from);\n      if (!from) {\n        logger.error(`\"from\" value [${options.from}] is not a valid version.`);\n        return 1;\n      }\n      return _this6.executeMigrations(workflow, packageName, migrations, from, options.to || packageNode.version, options.createCommits);\n    })();\n  }\n  // eslint-disable-next-line max-lines-per-function\n  updatePackagesAndMigrate(workflow, rootDependencies, options, packages) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      const {\n        logger\n      } = _this7.context;\n      const logVerbose = message => {\n        if (options.verbose) {\n          logger.info(message);\n        }\n      };\n      const requests = [];\n      // Validate packages actually are part of the workspace\n      for (const pkg of packages) {\n        const node = rootDependencies.get(pkg.name);\n        if (!(node === null || node === void 0 ? void 0 : node.package)) {\n          logger.error(`Package '${pkg.name}' is not a dependency.`);\n          return 1;\n        }\n        // If a specific version is requested and matches the installed version, skip.\n        if (pkg.type === 'version' && node.package.version === pkg.fetchSpec) {\n          logger.info(`Package '${pkg.name}' is already at '${pkg.fetchSpec}'.`);\n          continue;\n        }\n        requests.push({\n          identifier: pkg,\n          node\n        });\n      }\n      if (requests.length === 0) {\n        return 0;\n      }\n      logger.info('Fetching dependency metadata from registry...');\n      const packagesToUpdate = [];\n      for (const {\n        identifier: requestIdentifier,\n        node\n      } of requests) {\n        const packageName = requestIdentifier.name;\n        let metadata;\n        try {\n          // Metadata requests are internally cached; multiple requests for same name\n          // does not result in additional network traffic\n          metadata = yield (0, package_metadata_1.fetchPackageMetadata)(packageName, logger, {\n            verbose: options.verbose\n          });\n        } catch (e) {\n          (0, error_1.assertIsError)(e);\n          logger.error(`Error fetching metadata for '${packageName}': ` + e.message);\n          return 1;\n        }\n        // Try to find a package version based on the user requested package specifier\n        // registry specifier types are either version, range, or tag\n        let manifest;\n        if (requestIdentifier.type === 'version' || requestIdentifier.type === 'range' || requestIdentifier.type === 'tag') {\n          try {\n            manifest = (0, npm_pick_manifest_1.default)(metadata, requestIdentifier.fetchSpec);\n          } catch (e) {\n            (0, error_1.assertIsError)(e);\n            if (e.code === 'ETARGET') {\n              // If not found and next was used and user did not provide a specifier, try latest.\n              // Package may not have a next tag.\n              if (requestIdentifier.type === 'tag' && requestIdentifier.fetchSpec === 'next' && !requestIdentifier.rawSpec) {\n                try {\n                  manifest = (0, npm_pick_manifest_1.default)(metadata, 'latest');\n                } catch (e) {\n                  (0, error_1.assertIsError)(e);\n                  if (e.code !== 'ETARGET' && e.code !== 'ENOVERSIONS') {\n                    throw e;\n                  }\n                }\n              }\n            } else if (e.code !== 'ENOVERSIONS') {\n              throw e;\n            }\n          }\n        }\n        if (!manifest) {\n          logger.error(`Package specified by '${requestIdentifier.raw}' does not exist within the registry.`);\n          return 1;\n        }\n        if (manifest.version === ((_a = node.package) === null || _a === void 0 ? void 0 : _a.version)) {\n          logger.info(`Package '${packageName}' is already up to date.`);\n          continue;\n        }\n        if (node.package && ANGULAR_PACKAGES_REGEXP.test(node.package.name)) {\n          const {\n            name,\n            version\n          } = node.package;\n          const toBeInstalledMajorVersion = +manifest.version.split('.')[0];\n          const currentMajorVersion = +version.split('.')[0];\n          if (toBeInstalledMajorVersion - currentMajorVersion > 1) {\n            // Only allow updating a single version at a time.\n            if (currentMajorVersion < 6) {\n              // Before version 6, the major versions were not always sequential.\n              // Example @angular/core skipped version 3, @angular/cli skipped versions 2-5.\n              logger.error(`Updating multiple major versions of '${name}' at once is not supported. Please migrate each major version individually.\\n` + `For more information about the update process, see https://update.angular.io/.`);\n            } else {\n              const nextMajorVersionFromCurrent = currentMajorVersion + 1;\n              logger.error(`Updating multiple major versions of '${name}' at once is not supported. Please migrate each major version individually.\\n` + `Run 'ng update ${name}@${nextMajorVersionFromCurrent}' in your workspace directory ` + `to update to latest '${nextMajorVersionFromCurrent}.x' version of '${name}'.\\n\\n` + `For more information about the update process, see https://update.angular.io/?v=${currentMajorVersion}.0-${nextMajorVersionFromCurrent}.0`);\n            }\n            return 1;\n          }\n        }\n        packagesToUpdate.push(requestIdentifier.toString());\n      }\n      if (packagesToUpdate.length === 0) {\n        return 0;\n      }\n      const {\n        success\n      } = yield _this7.executeSchematic(workflow, UPDATE_SCHEMATIC_COLLECTION, 'update', {\n        verbose: options.verbose,\n        force: options.force,\n        next: options.next,\n        packageManager: _this7.context.packageManager.name,\n        packages: packagesToUpdate\n      });\n      if (success) {\n        try {\n          yield fs_1.promises.rm(path.join(_this7.context.root, 'node_modules'), {\n            force: true,\n            recursive: true,\n            maxRetries: 3\n          });\n        } catch {}\n        const installationSuccess = yield _this7.context.packageManager.installAll(_this7.packageManagerForce(options.verbose) ? ['--force'] : [], _this7.context.root);\n        if (!installationSuccess) {\n          return 1;\n        }\n      }\n      if (success && options.createCommits) {\n        if (!_this7.commit(`Angular CLI update for packages - ${packagesToUpdate.join(', ')}`)) {\n          return 1;\n        }\n      }\n      // This is a temporary workaround to allow data to be passed back from the update schematic\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const migrations = global.externalMigrations;\n      if (success && migrations) {\n        const rootRequire = (0, module_1.createRequire)(_this7.context.root + '/');\n        for (const migration of migrations) {\n          // Resolve the package from the workspace root, as otherwise it will be resolved from the temp\n          // installed CLI version.\n          let packagePath;\n          logVerbose(`Resolving migration package '${migration.package}' from '${_this7.context.root}'...`);\n          try {\n            try {\n              packagePath = path.dirname(\n              // This may fail if the `package.json` is not exported as an entry point\n              rootRequire.resolve(path.join(migration.package, 'package.json')));\n            } catch (e) {\n              (0, error_1.assertIsError)(e);\n              if (e.code === 'MODULE_NOT_FOUND') {\n                // Fallback to trying to resolve the package's main entry point\n                packagePath = rootRequire.resolve(migration.package);\n              } else {\n                throw e;\n              }\n            }\n          } catch (e) {\n            (0, error_1.assertIsError)(e);\n            if (e.code === 'MODULE_NOT_FOUND') {\n              logVerbose(e.toString());\n              logger.error(`Migrations for package (${migration.package}) were not found.` + ' The package could not be found in the workspace.');\n            } else {\n              logger.error(`Unable to resolve migrations for package (${migration.package}).  [${e.message}]`);\n            }\n            return 1;\n          }\n          let migrations;\n          // Check if it is a package-local location\n          const localMigrations = path.join(packagePath, migration.collection);\n          if ((0, fs_1.existsSync)(localMigrations)) {\n            migrations = localMigrations;\n          } else {\n            // Try to resolve from package location.\n            // This avoids issues with package hoisting.\n            try {\n              const packageRequire = (0, module_1.createRequire)(packagePath + '/');\n              migrations = packageRequire.resolve(migration.collection);\n            } catch (e) {\n              (0, error_1.assertIsError)(e);\n              if (e.code === 'MODULE_NOT_FOUND') {\n                logger.error(`Migrations for package (${migration.package}) were not found.`);\n              } else {\n                logger.error(`Unable to resolve migrations for package (${migration.package}).  [${e.message}]`);\n              }\n              return 1;\n            }\n          }\n          const result = yield _this7.executeMigrations(workflow, migration.package, migrations, migration.from, migration.to, options.createCommits);\n          // A non-zero value is a failure for the package's migrations\n          if (result !== 0) {\n            return result;\n          }\n        }\n      }\n      return success ? 0 : 1;\n    })();\n  }\n  /**\n   * @return Whether or not the commit was successful.\n   */\n  commit(message) {\n    const {\n      logger\n    } = this.context;\n    // Check if a commit is needed.\n    let commitNeeded;\n    try {\n      commitNeeded = hasChangesToCommit();\n    } catch (err) {\n      logger.error(`  Failed to read Git tree:\\n${err.stderr}`);\n      return false;\n    }\n    if (!commitNeeded) {\n      logger.info('  No changes to commit after migration.');\n      return true;\n    }\n    // Commit changes and abort on error.\n    try {\n      createCommit(message);\n    } catch (err) {\n      logger.error(`Failed to commit update (${message}):\\n${err.stderr}`);\n      return false;\n    }\n    // Notify user of the commit.\n    const hash = findCurrentGitSha();\n    const shortMessage = message.split('\\n')[0];\n    if (hash) {\n      logger.info(`  Committed migration step (${getShortHash(hash)}): ${shortMessage}.`);\n    } else {\n      // Commit was successful, but reading the hash was not. Something weird happened,\n      // but nothing that would stop the update. Just log the weirdness and continue.\n      logger.info(`  Committed migration step: ${shortMessage}.`);\n      logger.warn('  Failed to look up hash of most recent commit, continuing anyways.');\n    }\n    return true;\n  }\n  checkCleanGit() {\n    try {\n      const topLevel = (0, child_process_1.execSync)('git rev-parse --show-toplevel', {\n        encoding: 'utf8',\n        stdio: 'pipe'\n      });\n      const result = (0, child_process_1.execSync)('git status --porcelain', {\n        encoding: 'utf8',\n        stdio: 'pipe'\n      });\n      if (result.trim().length === 0) {\n        return true;\n      }\n      // Only files inside the workspace root are relevant\n      for (const entry of result.split('\\n')) {\n        const relativeEntry = path.relative(path.resolve(this.context.root), path.resolve(topLevel.trim(), entry.slice(3).trim()));\n        if (!relativeEntry.startsWith('..') && !path.isAbsolute(relativeEntry)) {\n          return false;\n        }\n      }\n    } catch {}\n    return true;\n  }\n  /**\n   * Checks if the current installed CLI version is older or newer than a compatible version.\n   * @returns the version to install or null when there is no update to install.\n   */\n  checkCLIVersion(packagesToUpdate, verbose = false, next = false) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        version\n      } = yield (0, package_metadata_1.fetchPackageManifest)(`@angular/cli@${_this8.getCLIUpdateRunnerVersion(packagesToUpdate, next)}`, _this8.context.logger, {\n        verbose,\n        usingYarn: _this8.context.packageManager.name === workspace_schema_1.PackageManager.Yarn\n      });\n      return version_1.VERSION.full === version ? null : version;\n    })();\n  }\n  getCLIUpdateRunnerVersion(packagesToUpdate, next) {\n    var _a, _b;\n    if (next) {\n      return 'next';\n    }\n    const updatingAngularPackage = packagesToUpdate === null || packagesToUpdate === void 0 ? void 0 : packagesToUpdate.find(r => ANGULAR_PACKAGES_REGEXP.test(r));\n    if (updatingAngularPackage) {\n      // If we are updating any Angular package we can update the CLI to the target version because\n      // migrations for @angular/core@13 can be executed using Angular/cli@13.\n      // This is same behaviour as `npx @angular/cli@13 update @angular/core@13`.\n      // `@angular/cli@13` -> ['', 'angular/cli', '13']\n      // `@angular/cli` -> ['', 'angular/cli']\n      const tempVersion = coerceVersionNumber(updatingAngularPackage.split('@')[2]);\n      return (_b = (_a = semver.parse(tempVersion)) === null || _a === void 0 ? void 0 : _a.major) !== null && _b !== void 0 ? _b : 'latest';\n    }\n    // When not updating an Angular package we cannot determine which schematic runtime the migration should to be executed in.\n    // Typically, we can assume that the `@angular/cli` was updated previously.\n    // Example: Angular official packages are typically updated prior to NGRX etc...\n    // Therefore, we only update to the latest patch version of the installed major version of the Angular CLI.\n    // This is important because we might end up in a scenario where locally Angular v12 is installed, updating NGRX from 11 to 12.\n    // We end up using Angular ClI v13 to run the migrations if we run the migrations using the CLI installed major version + 1 logic.\n    return version_1.VERSION.major;\n  }\n  runTempBinary(packageName, args = []) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        success,\n        tempNodeModules\n      } = yield _this9.context.packageManager.installTemp(packageName);\n      if (!success) {\n        return 1;\n      }\n      // Remove version/tag etc... from package name\n      // Ex: @angular/cli@latest -> @angular/cli\n      const packageNameNoVersion = packageName.substring(0, packageName.lastIndexOf('@'));\n      const pkgLocation = (0, path_1.join)(tempNodeModules, packageNameNoVersion);\n      const packageJsonPath = (0, path_1.join)(pkgLocation, 'package.json');\n      // Get a binary location for this package\n      let binPath;\n      if ((0, fs_1.existsSync)(packageJsonPath)) {\n        const content = yield fs_1.promises.readFile(packageJsonPath, 'utf-8');\n        if (content) {\n          const {\n            bin = {}\n          } = JSON.parse(content);\n          const binKeys = Object.keys(bin);\n          if (binKeys.length) {\n            binPath = (0, path_1.resolve)(pkgLocation, bin[binKeys[0]]);\n          }\n        }\n      }\n      if (!binPath) {\n        throw new Error(`Cannot locate bin for temporary package: ${packageNameNoVersion}.`);\n      }\n      const {\n        status,\n        error\n      } = (0, child_process_1.spawnSync)(process.execPath, [binPath, ...args], {\n        stdio: 'inherit',\n        env: {\n          ...process.env,\n          NG_DISABLE_VERSION_CHECK: 'true',\n          NG_CLI_ANALYTICS: 'false'\n        }\n      });\n      if (status === null && error) {\n        throw error;\n      }\n      return status !== null && status !== void 0 ? status : 0;\n    })();\n  }\n  packageManagerForce(verbose) {\n    // npm 7+ can fail due to it incorrectly resolving peer dependencies that have valid SemVer\n    // ranges during an update. Update will set correct versions of dependencies within the\n    // package.json file. The force option is set to workaround these errors.\n    // Example error:\n    // npm ERR! Conflicting peer dependency: @angular/compiler-cli@14.0.0-rc.0\n    // npm ERR! node_modules/@angular/compiler-cli\n    // npm ERR!   peer @angular/compiler-cli@\"^14.0.0 || ^14.0.0-rc\" from @angular-devkit/build-angular@14.0.0-rc.0\n    // npm ERR!   node_modules/@angular-devkit/build-angular\n    // npm ERR!     dev @angular-devkit/build-angular@\"~14.0.0-rc.0\" from the root project\n    if (this.context.packageManager.name === workspace_schema_1.PackageManager.Npm && this.context.packageManager.version && semver.gte(this.context.packageManager.version, '7.0.0')) {\n      if (verbose) {\n        this.context.logger.info('NPM 7+ detected -- enabling force option for package installation');\n      }\n      return true;\n    }\n    return false;\n  }\n}\nexports.UpdateCommandModule = UpdateCommandModule;\n/**\n * @return Whether or not the working directory has Git changes to commit.\n */\nfunction hasChangesToCommit() {\n  // List all modified files not covered by .gitignore.\n  // If any files are returned, then there must be something to commit.\n  return (0, child_process_1.execSync)('git ls-files -m -d -o --exclude-standard').toString() !== '';\n}\n/**\n * Precondition: Must have pending changes to commit, they do not need to be staged.\n * Postcondition: The Git working tree is committed and the repo is clean.\n * @param message The commit message to use.\n */\nfunction createCommit(message) {\n  // Stage entire working tree for commit.\n  (0, child_process_1.execSync)('git add -A', {\n    encoding: 'utf8',\n    stdio: 'pipe'\n  });\n  // Commit with the message passed via stdin to avoid bash escaping issues.\n  (0, child_process_1.execSync)('git commit --no-verify -F -', {\n    encoding: 'utf8',\n    stdio: 'pipe',\n    input: message\n  });\n}\n/**\n * @return The Git SHA hash of the HEAD commit. Returns null if unable to retrieve the hash.\n */\nfunction findCurrentGitSha() {\n  try {\n    return (0, child_process_1.execSync)('git rev-parse HEAD', {\n      encoding: 'utf8',\n      stdio: 'pipe'\n    }).trim();\n  } catch {\n    return null;\n  }\n}\nfunction getShortHash(commitHash) {\n  return commitHash.slice(0, 9);\n}\nfunction coerceVersionNumber(version) {\n  var _a;\n  if (!version) {\n    return undefined;\n  }\n  if (!/^\\d{1,30}\\.\\d{1,30}\\.\\d{1,30}/.test(version)) {\n    const match = version.match(/^\\d{1,30}(\\.\\d{1,30})*/);\n    if (!match) {\n      return undefined;\n    }\n    if (!match[1]) {\n      version = version.substring(0, match[0].length) + '.0.0' + version.substring(match[0].length);\n    } else if (!match[2]) {\n      version = version.substring(0, match[0].length) + '.0' + version.substring(match[0].length);\n    } else {\n      return undefined;\n    }\n  }\n  return (_a = semver.valid(version)) !== null && _a !== void 0 ? _a : undefined;\n}","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","__importDefault","exports","UpdateCommandModule","schematics_1","require","tools_1","child_process_1","fs_1","module_1","npm_package_arg_1","npm_pick_manifest_1","path","path_1","semver","workspace_schema_1","command_module_1","schematic_engine_host_1","schematic_workflow_1","color_1","environment_options_1","error_1","log_file_1","package_metadata_1","package_tree_1","version_1","ANGULAR_PACKAGES_REGEXP","UPDATE_SCHEMATIC_COLLECTION","join","__dirname","CommandModule","constructor","arguments","scope","CommandScope","In","shouldReportAnalytics","command","describe","longDescriptionPath","builder","localYargs","positional","description","type","array","option","default","implies","conflicts","alias","check","packages","allowDirty","migrateOnly","logger","context","length","checkCleanGit","warn","CommandModuleError","strict","run","options","_a","_b","_c","packageManager","ensureCompatibility","disableVersionCheck","cliVersionToInstall","checkCLIVersion","verbose","next","runTempBinary","process","argv","slice","request","packageIdentifier","registry","error","some","name","rawSpec","fetchSpec","push","e","assertIsError","message","info","colors","grey","rootDependencies","getProjectDependencies","root","size","workflow","NodeWorkflow","packageManagerForce","resolvePaths","schemaValidation","engineHostCreator","SchematicEngineHost","success","executeSchematic","force","updatePackagesAndMigrate","collection","schematic","workflowSubscription","subscribeToWorkflow","execute","toPromise","files","UnsuccessfulWorkflowExecution","symbols","cross","logPath","writeErrorToLogFile","fatal","unsubscribe","executeMigration","packageName","collectionPath","migrationName","commit","engine","createCollection","listSchematicNames","find","cyan","createSchematic","executePackageMigrations","executeMigrations","from","to","migrationRange","Range","prerelease","split","migrations","version","coerceVersionNumber","satisfies","includePrerelease","sort","a","b","compare","localeCompare","migration","title","pointer","bold","endsWith","commitPrefix","commitMessage","committed","packageDependency","packagePath","packageNode","package","packageJson","findPackageJson","dirname","readPackageJson","updateMetadata","posix","isAbsolute","win32","replace","startsWith","localMigrations","existsSync","packageRequire","createRequire","resolve","code","createCommits","logVerbose","requests","pkg","node","identifier","packagesToUpdate","requestIdentifier","metadata","fetchPackageMetadata","manifest","raw","test","toBeInstalledMajorVersion","currentMajorVersion","nextMajorVersionFromCurrent","toString","promises","rm","recursive","maxRetries","installationSuccess","installAll","global","externalMigrations","rootRequire","commitNeeded","hasChangesToCommit","err","stderr","createCommit","hash","findCurrentGitSha","shortMessage","getShortHash","topLevel","execSync","encoding","stdio","trim","entry","relativeEntry","relative","fetchPackageManifest","getCLIUpdateRunnerVersion","usingYarn","PackageManager","Yarn","VERSION","full","updatingAngularPackage","r","tempVersion","parse","major","args","tempNodeModules","installTemp","packageNameNoVersion","substring","lastIndexOf","pkgLocation","packageJsonPath","binPath","content","readFile","bin","JSON","binKeys","keys","Error","status","spawnSync","execPath","env","NG_DISABLE_VERSION_CHECK","NG_CLI_ANALYTICS","Npm","gte","input","commitHash","match","valid"],"sources":["I:/Angular/angular-blog/node_modules/@angular/cli/src/commands/update/cli.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UpdateCommandModule = void 0;\nconst schematics_1 = require(\"@angular-devkit/schematics\");\nconst tools_1 = require(\"@angular-devkit/schematics/tools\");\nconst child_process_1 = require(\"child_process\");\nconst fs_1 = require(\"fs\");\nconst module_1 = require(\"module\");\nconst npm_package_arg_1 = __importDefault(require(\"npm-package-arg\"));\nconst npm_pick_manifest_1 = __importDefault(require(\"npm-pick-manifest\"));\nconst path = __importStar(require(\"path\"));\nconst path_1 = require(\"path\");\nconst semver = __importStar(require(\"semver\"));\nconst workspace_schema_1 = require(\"../../../lib/config/workspace-schema\");\nconst command_module_1 = require(\"../../command-builder/command-module\");\nconst schematic_engine_host_1 = require(\"../../command-builder/utilities/schematic-engine-host\");\nconst schematic_workflow_1 = require(\"../../command-builder/utilities/schematic-workflow\");\nconst color_1 = require(\"../../utilities/color\");\nconst environment_options_1 = require(\"../../utilities/environment-options\");\nconst error_1 = require(\"../../utilities/error\");\nconst log_file_1 = require(\"../../utilities/log-file\");\nconst package_metadata_1 = require(\"../../utilities/package-metadata\");\nconst package_tree_1 = require(\"../../utilities/package-tree\");\nconst version_1 = require(\"../../utilities/version\");\nconst ANGULAR_PACKAGES_REGEXP = /^@(?:angular|nguniversal)\\//;\nconst UPDATE_SCHEMATIC_COLLECTION = path.join(__dirname, 'schematic/collection.json');\nclass UpdateCommandModule extends command_module_1.CommandModule {\n    constructor() {\n        super(...arguments);\n        this.scope = command_module_1.CommandScope.In;\n        this.shouldReportAnalytics = false;\n        this.command = 'update [packages..]';\n        this.describe = 'Updates your workspace and its dependencies. See https://update.angular.io/.';\n        this.longDescriptionPath = (0, path_1.join)(__dirname, 'long-description.md');\n    }\n    builder(localYargs) {\n        return localYargs\n            .positional('packages', {\n            description: 'The names of package(s) to update.',\n            type: 'string',\n            array: true,\n        })\n            .option('force', {\n            description: 'Ignore peer dependency version mismatches.',\n            type: 'boolean',\n            default: false,\n        })\n            .option('next', {\n            description: 'Use the prerelease version, including beta and RCs.',\n            type: 'boolean',\n            default: false,\n        })\n            .option('migrate-only', {\n            description: 'Only perform a migration, do not update the installed version.',\n            type: 'boolean',\n        })\n            .option('name', {\n            description: 'The name of the migration to run. ' +\n                `Only available with a single package being updated, and only with 'migrate-only' option.`,\n            type: 'string',\n            implies: ['migrate-only'],\n            conflicts: ['to', 'from'],\n        })\n            .option('from', {\n            description: 'Version from which to migrate from. ' +\n                `Only available with a single package being updated, and only with 'migrate-only'.`,\n            type: 'string',\n            implies: ['to', 'migrate-only'],\n            conflicts: ['name'],\n        })\n            .option('to', {\n            describe: 'Version up to which to apply migrations. Only available with a single package being updated, ' +\n                `and only with 'migrate-only' option. Requires 'from' to be specified. Default to the installed version detected.`,\n            type: 'string',\n            implies: ['from', 'migrate-only'],\n            conflicts: ['name'],\n        })\n            .option('allow-dirty', {\n            describe: 'Whether to allow updating when the repository contains modified or untracked files.',\n            type: 'boolean',\n            default: false,\n        })\n            .option('verbose', {\n            describe: 'Display additional details about internal operations during execution.',\n            type: 'boolean',\n            default: false,\n        })\n            .option('create-commits', {\n            describe: 'Create source control commits for updates and migrations.',\n            type: 'boolean',\n            alias: ['C'],\n            default: false,\n        })\n            .check(({ packages, 'allow-dirty': allowDirty, 'migrate-only': migrateOnly }) => {\n            const { logger } = this.context;\n            // This allows the user to easily reset any changes from the update.\n            if ((packages === null || packages === void 0 ? void 0 : packages.length) && !this.checkCleanGit()) {\n                if (allowDirty) {\n                    logger.warn('Repository is not clean. Update changes will be mixed with pre-existing changes.');\n                }\n                else {\n                    throw new command_module_1.CommandModuleError('Repository is not clean. Please commit or stash any changes before updating.');\n                }\n            }\n            if (migrateOnly) {\n                if ((packages === null || packages === void 0 ? void 0 : packages.length) !== 1) {\n                    throw new command_module_1.CommandModuleError(`A single package must be specified when using the 'migrate-only' option.`);\n                }\n            }\n            return true;\n        })\n            .strict();\n    }\n    async run(options) {\n        var _a, _b, _c;\n        const { logger, packageManager } = this.context;\n        packageManager.ensureCompatibility();\n        // Check if the current installed CLI version is older than the latest compatible version.\n        // Skip when running `ng update` without a package name as this will not trigger an actual update.\n        if (!environment_options_1.disableVersionCheck && ((_a = options.packages) === null || _a === void 0 ? void 0 : _a.length)) {\n            const cliVersionToInstall = await this.checkCLIVersion(options.packages, options.verbose, options.next);\n            if (cliVersionToInstall) {\n                logger.warn('The installed Angular CLI version is outdated.\\n' +\n                    `Installing a temporary Angular CLI versioned ${cliVersionToInstall} to perform the update.`);\n                return this.runTempBinary(`@angular/cli@${cliVersionToInstall}`, process.argv.slice(2));\n            }\n        }\n        const packages = [];\n        for (const request of (_b = options.packages) !== null && _b !== void 0 ? _b : []) {\n            try {\n                const packageIdentifier = (0, npm_package_arg_1.default)(request);\n                // only registry identifiers are supported\n                if (!packageIdentifier.registry) {\n                    logger.error(`Package '${request}' is not a registry package identifer.`);\n                    return 1;\n                }\n                if (packages.some((v) => v.name === packageIdentifier.name)) {\n                    logger.error(`Duplicate package '${packageIdentifier.name}' specified.`);\n                    return 1;\n                }\n                if (options.migrateOnly && packageIdentifier.rawSpec) {\n                    logger.warn('Package specifier has no effect when using \"migrate-only\" option.');\n                }\n                // If next option is used and no specifier supplied, use next tag\n                if (options.next && !packageIdentifier.rawSpec) {\n                    packageIdentifier.fetchSpec = 'next';\n                }\n                packages.push(packageIdentifier);\n            }\n            catch (e) {\n                (0, error_1.assertIsError)(e);\n                logger.error(e.message);\n                return 1;\n            }\n        }\n        logger.info(`Using package manager: ${color_1.colors.grey(packageManager.name)}`);\n        logger.info('Collecting installed dependencies...');\n        const rootDependencies = await (0, package_tree_1.getProjectDependencies)(this.context.root);\n        logger.info(`Found ${rootDependencies.size} dependencies.`);\n        const workflow = new tools_1.NodeWorkflow(this.context.root, {\n            packageManager: packageManager.name,\n            packageManagerForce: this.packageManagerForce(options.verbose),\n            // __dirname -> favor @schematics/update from this package\n            // Otherwise, use packages from the active workspace (migrations)\n            resolvePaths: [__dirname, this.context.root],\n            schemaValidation: true,\n            engineHostCreator: (options) => new schematic_engine_host_1.SchematicEngineHost(options.resolvePaths),\n        });\n        if (packages.length === 0) {\n            // Show status\n            const { success } = await this.executeSchematic(workflow, UPDATE_SCHEMATIC_COLLECTION, 'update', {\n                force: options.force,\n                next: options.next,\n                verbose: options.verbose,\n                packageManager: packageManager.name,\n                packages: [],\n            });\n            return success ? 0 : 1;\n        }\n        return options.migrateOnly\n            ? this.migrateOnly(workflow, ((_c = options.packages) !== null && _c !== void 0 ? _c : [])[0], rootDependencies, options)\n            : this.updatePackagesAndMigrate(workflow, rootDependencies, options, packages);\n    }\n    async executeSchematic(workflow, collection, schematic, options = {}) {\n        const { logger } = this.context;\n        const workflowSubscription = (0, schematic_workflow_1.subscribeToWorkflow)(workflow, logger);\n        // TODO: Allow passing a schematic instance directly\n        try {\n            await workflow\n                .execute({\n                collection,\n                schematic,\n                options,\n                logger,\n            })\n                .toPromise();\n            return { success: !workflowSubscription.error, files: workflowSubscription.files };\n        }\n        catch (e) {\n            if (e instanceof schematics_1.UnsuccessfulWorkflowExecution) {\n                logger.error(`${color_1.colors.symbols.cross} Migration failed. See above for further details.\\n`);\n            }\n            else {\n                (0, error_1.assertIsError)(e);\n                const logPath = (0, log_file_1.writeErrorToLogFile)(e);\n                logger.fatal(`${color_1.colors.symbols.cross} Migration failed: ${e.message}\\n` +\n                    `  See \"${logPath}\" for further details.\\n`);\n            }\n            return { success: false, files: workflowSubscription.files };\n        }\n        finally {\n            workflowSubscription.unsubscribe();\n        }\n    }\n    /**\n     * @return Whether or not the migration was performed successfully.\n     */\n    async executeMigration(workflow, packageName, collectionPath, migrationName, commit) {\n        const { logger } = this.context;\n        const collection = workflow.engine.createCollection(collectionPath);\n        const name = collection.listSchematicNames().find((name) => name === migrationName);\n        if (!name) {\n            logger.error(`Cannot find migration '${migrationName}' in '${packageName}'.`);\n            return 1;\n        }\n        logger.info(color_1.colors.cyan(`** Executing '${migrationName}' of package '${packageName}' **\\n`));\n        const schematic = workflow.engine.createSchematic(name, collection);\n        return this.executePackageMigrations(workflow, [schematic.description], packageName, commit);\n    }\n    /**\n     * @return Whether or not the migrations were performed successfully.\n     */\n    async executeMigrations(workflow, packageName, collectionPath, from, to, commit) {\n        const collection = workflow.engine.createCollection(collectionPath);\n        const migrationRange = new semver.Range('>' + (semver.prerelease(from) ? from.split('-')[0] + '-0' : from) + ' <=' + to.split('-')[0]);\n        const migrations = [];\n        for (const name of collection.listSchematicNames()) {\n            const schematic = workflow.engine.createSchematic(name, collection);\n            const description = schematic.description;\n            description.version = coerceVersionNumber(description.version);\n            if (!description.version) {\n                continue;\n            }\n            if (semver.satisfies(description.version, migrationRange, { includePrerelease: true })) {\n                migrations.push(description);\n            }\n        }\n        if (migrations.length === 0) {\n            return 0;\n        }\n        migrations.sort((a, b) => semver.compare(a.version, b.version) || a.name.localeCompare(b.name));\n        this.context.logger.info(color_1.colors.cyan(`** Executing migrations of package '${packageName}' **\\n`));\n        return this.executePackageMigrations(workflow, migrations, packageName, commit);\n    }\n    async executePackageMigrations(workflow, migrations, packageName, commit = false) {\n        const { logger } = this.context;\n        for (const migration of migrations) {\n            const [title, ...description] = migration.description.split('. ');\n            logger.info(color_1.colors.cyan(color_1.colors.symbols.pointer) +\n                ' ' +\n                color_1.colors.bold(title.endsWith('.') ? title : title + '.'));\n            if (description.length) {\n                logger.info('  ' + description.join('.\\n  '));\n            }\n            const result = await this.executeSchematic(workflow, migration.collection.name, migration.name);\n            if (!result.success) {\n                return 1;\n            }\n            logger.info('  Migration completed.');\n            // Commit migration\n            if (commit) {\n                const commitPrefix = `${packageName} migration - ${migration.name}`;\n                const commitMessage = migration.description\n                    ? `${commitPrefix}\\n\\n${migration.description}`\n                    : commitPrefix;\n                const committed = this.commit(commitMessage);\n                if (!committed) {\n                    // Failed to commit, something went wrong. Abort the update.\n                    return 1;\n                }\n            }\n            logger.info(''); // Extra trailing newline.\n        }\n        return 0;\n    }\n    async migrateOnly(workflow, packageName, rootDependencies, options) {\n        const { logger } = this.context;\n        const packageDependency = rootDependencies.get(packageName);\n        let packagePath = packageDependency === null || packageDependency === void 0 ? void 0 : packageDependency.path;\n        let packageNode = packageDependency === null || packageDependency === void 0 ? void 0 : packageDependency.package;\n        if (packageDependency && !packageNode) {\n            logger.error('Package found in package.json but is not installed.');\n            return 1;\n        }\n        else if (!packageDependency) {\n            // Allow running migrations on transitively installed dependencies\n            // There can technically be nested multiple versions\n            // TODO: If multiple, this should find all versions and ask which one to use\n            const packageJson = (0, package_tree_1.findPackageJson)(this.context.root, packageName);\n            if (packageJson) {\n                packagePath = path.dirname(packageJson);\n                packageNode = await (0, package_tree_1.readPackageJson)(packageJson);\n            }\n        }\n        if (!packageNode || !packagePath) {\n            logger.error('Package is not installed.');\n            return 1;\n        }\n        const updateMetadata = packageNode['ng-update'];\n        let migrations = updateMetadata === null || updateMetadata === void 0 ? void 0 : updateMetadata.migrations;\n        if (migrations === undefined) {\n            logger.error('Package does not provide migrations.');\n            return 1;\n        }\n        else if (typeof migrations !== 'string') {\n            logger.error('Package contains a malformed migrations field.');\n            return 1;\n        }\n        else if (path.posix.isAbsolute(migrations) || path.win32.isAbsolute(migrations)) {\n            logger.error('Package contains an invalid migrations field. Absolute paths are not permitted.');\n            return 1;\n        }\n        // Normalize slashes\n        migrations = migrations.replace(/\\\\/g, '/');\n        if (migrations.startsWith('../')) {\n            logger.error('Package contains an invalid migrations field. Paths outside the package root are not permitted.');\n            return 1;\n        }\n        // Check if it is a package-local location\n        const localMigrations = path.join(packagePath, migrations);\n        if ((0, fs_1.existsSync)(localMigrations)) {\n            migrations = localMigrations;\n        }\n        else {\n            // Try to resolve from package location.\n            // This avoids issues with package hoisting.\n            try {\n                const packageRequire = (0, module_1.createRequire)(packagePath + '/');\n                migrations = packageRequire.resolve(migrations);\n            }\n            catch (e) {\n                (0, error_1.assertIsError)(e);\n                if (e.code === 'MODULE_NOT_FOUND') {\n                    logger.error('Migrations for package were not found.');\n                }\n                else {\n                    logger.error(`Unable to resolve migrations for package.  [${e.message}]`);\n                }\n                return 1;\n            }\n        }\n        if (options.name) {\n            return this.executeMigration(workflow, packageName, migrations, options.name, options.createCommits);\n        }\n        const from = coerceVersionNumber(options.from);\n        if (!from) {\n            logger.error(`\"from\" value [${options.from}] is not a valid version.`);\n            return 1;\n        }\n        return this.executeMigrations(workflow, packageName, migrations, from, options.to || packageNode.version, options.createCommits);\n    }\n    // eslint-disable-next-line max-lines-per-function\n    async updatePackagesAndMigrate(workflow, rootDependencies, options, packages) {\n        var _a;\n        const { logger } = this.context;\n        const logVerbose = (message) => {\n            if (options.verbose) {\n                logger.info(message);\n            }\n        };\n        const requests = [];\n        // Validate packages actually are part of the workspace\n        for (const pkg of packages) {\n            const node = rootDependencies.get(pkg.name);\n            if (!(node === null || node === void 0 ? void 0 : node.package)) {\n                logger.error(`Package '${pkg.name}' is not a dependency.`);\n                return 1;\n            }\n            // If a specific version is requested and matches the installed version, skip.\n            if (pkg.type === 'version' && node.package.version === pkg.fetchSpec) {\n                logger.info(`Package '${pkg.name}' is already at '${pkg.fetchSpec}'.`);\n                continue;\n            }\n            requests.push({ identifier: pkg, node });\n        }\n        if (requests.length === 0) {\n            return 0;\n        }\n        logger.info('Fetching dependency metadata from registry...');\n        const packagesToUpdate = [];\n        for (const { identifier: requestIdentifier, node } of requests) {\n            const packageName = requestIdentifier.name;\n            let metadata;\n            try {\n                // Metadata requests are internally cached; multiple requests for same name\n                // does not result in additional network traffic\n                metadata = await (0, package_metadata_1.fetchPackageMetadata)(packageName, logger, {\n                    verbose: options.verbose,\n                });\n            }\n            catch (e) {\n                (0, error_1.assertIsError)(e);\n                logger.error(`Error fetching metadata for '${packageName}': ` + e.message);\n                return 1;\n            }\n            // Try to find a package version based on the user requested package specifier\n            // registry specifier types are either version, range, or tag\n            let manifest;\n            if (requestIdentifier.type === 'version' ||\n                requestIdentifier.type === 'range' ||\n                requestIdentifier.type === 'tag') {\n                try {\n                    manifest = (0, npm_pick_manifest_1.default)(metadata, requestIdentifier.fetchSpec);\n                }\n                catch (e) {\n                    (0, error_1.assertIsError)(e);\n                    if (e.code === 'ETARGET') {\n                        // If not found and next was used and user did not provide a specifier, try latest.\n                        // Package may not have a next tag.\n                        if (requestIdentifier.type === 'tag' &&\n                            requestIdentifier.fetchSpec === 'next' &&\n                            !requestIdentifier.rawSpec) {\n                            try {\n                                manifest = (0, npm_pick_manifest_1.default)(metadata, 'latest');\n                            }\n                            catch (e) {\n                                (0, error_1.assertIsError)(e);\n                                if (e.code !== 'ETARGET' && e.code !== 'ENOVERSIONS') {\n                                    throw e;\n                                }\n                            }\n                        }\n                    }\n                    else if (e.code !== 'ENOVERSIONS') {\n                        throw e;\n                    }\n                }\n            }\n            if (!manifest) {\n                logger.error(`Package specified by '${requestIdentifier.raw}' does not exist within the registry.`);\n                return 1;\n            }\n            if (manifest.version === ((_a = node.package) === null || _a === void 0 ? void 0 : _a.version)) {\n                logger.info(`Package '${packageName}' is already up to date.`);\n                continue;\n            }\n            if (node.package && ANGULAR_PACKAGES_REGEXP.test(node.package.name)) {\n                const { name, version } = node.package;\n                const toBeInstalledMajorVersion = +manifest.version.split('.')[0];\n                const currentMajorVersion = +version.split('.')[0];\n                if (toBeInstalledMajorVersion - currentMajorVersion > 1) {\n                    // Only allow updating a single version at a time.\n                    if (currentMajorVersion < 6) {\n                        // Before version 6, the major versions were not always sequential.\n                        // Example @angular/core skipped version 3, @angular/cli skipped versions 2-5.\n                        logger.error(`Updating multiple major versions of '${name}' at once is not supported. Please migrate each major version individually.\\n` +\n                            `For more information about the update process, see https://update.angular.io/.`);\n                    }\n                    else {\n                        const nextMajorVersionFromCurrent = currentMajorVersion + 1;\n                        logger.error(`Updating multiple major versions of '${name}' at once is not supported. Please migrate each major version individually.\\n` +\n                            `Run 'ng update ${name}@${nextMajorVersionFromCurrent}' in your workspace directory ` +\n                            `to update to latest '${nextMajorVersionFromCurrent}.x' version of '${name}'.\\n\\n` +\n                            `For more information about the update process, see https://update.angular.io/?v=${currentMajorVersion}.0-${nextMajorVersionFromCurrent}.0`);\n                    }\n                    return 1;\n                }\n            }\n            packagesToUpdate.push(requestIdentifier.toString());\n        }\n        if (packagesToUpdate.length === 0) {\n            return 0;\n        }\n        const { success } = await this.executeSchematic(workflow, UPDATE_SCHEMATIC_COLLECTION, 'update', {\n            verbose: options.verbose,\n            force: options.force,\n            next: options.next,\n            packageManager: this.context.packageManager.name,\n            packages: packagesToUpdate,\n        });\n        if (success) {\n            try {\n                await fs_1.promises.rm(path.join(this.context.root, 'node_modules'), {\n                    force: true,\n                    recursive: true,\n                    maxRetries: 3,\n                });\n            }\n            catch { }\n            const installationSuccess = await this.context.packageManager.installAll(this.packageManagerForce(options.verbose) ? ['--force'] : [], this.context.root);\n            if (!installationSuccess) {\n                return 1;\n            }\n        }\n        if (success && options.createCommits) {\n            if (!this.commit(`Angular CLI update for packages - ${packagesToUpdate.join(', ')}`)) {\n                return 1;\n            }\n        }\n        // This is a temporary workaround to allow data to be passed back from the update schematic\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const migrations = global.externalMigrations;\n        if (success && migrations) {\n            const rootRequire = (0, module_1.createRequire)(this.context.root + '/');\n            for (const migration of migrations) {\n                // Resolve the package from the workspace root, as otherwise it will be resolved from the temp\n                // installed CLI version.\n                let packagePath;\n                logVerbose(`Resolving migration package '${migration.package}' from '${this.context.root}'...`);\n                try {\n                    try {\n                        packagePath = path.dirname(\n                        // This may fail if the `package.json` is not exported as an entry point\n                        rootRequire.resolve(path.join(migration.package, 'package.json')));\n                    }\n                    catch (e) {\n                        (0, error_1.assertIsError)(e);\n                        if (e.code === 'MODULE_NOT_FOUND') {\n                            // Fallback to trying to resolve the package's main entry point\n                            packagePath = rootRequire.resolve(migration.package);\n                        }\n                        else {\n                            throw e;\n                        }\n                    }\n                }\n                catch (e) {\n                    (0, error_1.assertIsError)(e);\n                    if (e.code === 'MODULE_NOT_FOUND') {\n                        logVerbose(e.toString());\n                        logger.error(`Migrations for package (${migration.package}) were not found.` +\n                            ' The package could not be found in the workspace.');\n                    }\n                    else {\n                        logger.error(`Unable to resolve migrations for package (${migration.package}).  [${e.message}]`);\n                    }\n                    return 1;\n                }\n                let migrations;\n                // Check if it is a package-local location\n                const localMigrations = path.join(packagePath, migration.collection);\n                if ((0, fs_1.existsSync)(localMigrations)) {\n                    migrations = localMigrations;\n                }\n                else {\n                    // Try to resolve from package location.\n                    // This avoids issues with package hoisting.\n                    try {\n                        const packageRequire = (0, module_1.createRequire)(packagePath + '/');\n                        migrations = packageRequire.resolve(migration.collection);\n                    }\n                    catch (e) {\n                        (0, error_1.assertIsError)(e);\n                        if (e.code === 'MODULE_NOT_FOUND') {\n                            logger.error(`Migrations for package (${migration.package}) were not found.`);\n                        }\n                        else {\n                            logger.error(`Unable to resolve migrations for package (${migration.package}).  [${e.message}]`);\n                        }\n                        return 1;\n                    }\n                }\n                const result = await this.executeMigrations(workflow, migration.package, migrations, migration.from, migration.to, options.createCommits);\n                // A non-zero value is a failure for the package's migrations\n                if (result !== 0) {\n                    return result;\n                }\n            }\n        }\n        return success ? 0 : 1;\n    }\n    /**\n     * @return Whether or not the commit was successful.\n     */\n    commit(message) {\n        const { logger } = this.context;\n        // Check if a commit is needed.\n        let commitNeeded;\n        try {\n            commitNeeded = hasChangesToCommit();\n        }\n        catch (err) {\n            logger.error(`  Failed to read Git tree:\\n${err.stderr}`);\n            return false;\n        }\n        if (!commitNeeded) {\n            logger.info('  No changes to commit after migration.');\n            return true;\n        }\n        // Commit changes and abort on error.\n        try {\n            createCommit(message);\n        }\n        catch (err) {\n            logger.error(`Failed to commit update (${message}):\\n${err.stderr}`);\n            return false;\n        }\n        // Notify user of the commit.\n        const hash = findCurrentGitSha();\n        const shortMessage = message.split('\\n')[0];\n        if (hash) {\n            logger.info(`  Committed migration step (${getShortHash(hash)}): ${shortMessage}.`);\n        }\n        else {\n            // Commit was successful, but reading the hash was not. Something weird happened,\n            // but nothing that would stop the update. Just log the weirdness and continue.\n            logger.info(`  Committed migration step: ${shortMessage}.`);\n            logger.warn('  Failed to look up hash of most recent commit, continuing anyways.');\n        }\n        return true;\n    }\n    checkCleanGit() {\n        try {\n            const topLevel = (0, child_process_1.execSync)('git rev-parse --show-toplevel', {\n                encoding: 'utf8',\n                stdio: 'pipe',\n            });\n            const result = (0, child_process_1.execSync)('git status --porcelain', { encoding: 'utf8', stdio: 'pipe' });\n            if (result.trim().length === 0) {\n                return true;\n            }\n            // Only files inside the workspace root are relevant\n            for (const entry of result.split('\\n')) {\n                const relativeEntry = path.relative(path.resolve(this.context.root), path.resolve(topLevel.trim(), entry.slice(3).trim()));\n                if (!relativeEntry.startsWith('..') && !path.isAbsolute(relativeEntry)) {\n                    return false;\n                }\n            }\n        }\n        catch { }\n        return true;\n    }\n    /**\n     * Checks if the current installed CLI version is older or newer than a compatible version.\n     * @returns the version to install or null when there is no update to install.\n     */\n    async checkCLIVersion(packagesToUpdate, verbose = false, next = false) {\n        const { version } = await (0, package_metadata_1.fetchPackageManifest)(`@angular/cli@${this.getCLIUpdateRunnerVersion(packagesToUpdate, next)}`, this.context.logger, {\n            verbose,\n            usingYarn: this.context.packageManager.name === workspace_schema_1.PackageManager.Yarn,\n        });\n        return version_1.VERSION.full === version ? null : version;\n    }\n    getCLIUpdateRunnerVersion(packagesToUpdate, next) {\n        var _a, _b;\n        if (next) {\n            return 'next';\n        }\n        const updatingAngularPackage = packagesToUpdate === null || packagesToUpdate === void 0 ? void 0 : packagesToUpdate.find((r) => ANGULAR_PACKAGES_REGEXP.test(r));\n        if (updatingAngularPackage) {\n            // If we are updating any Angular package we can update the CLI to the target version because\n            // migrations for @angular/core@13 can be executed using Angular/cli@13.\n            // This is same behaviour as `npx @angular/cli@13 update @angular/core@13`.\n            // `@angular/cli@13` -> ['', 'angular/cli', '13']\n            // `@angular/cli` -> ['', 'angular/cli']\n            const tempVersion = coerceVersionNumber(updatingAngularPackage.split('@')[2]);\n            return (_b = (_a = semver.parse(tempVersion)) === null || _a === void 0 ? void 0 : _a.major) !== null && _b !== void 0 ? _b : 'latest';\n        }\n        // When not updating an Angular package we cannot determine which schematic runtime the migration should to be executed in.\n        // Typically, we can assume that the `@angular/cli` was updated previously.\n        // Example: Angular official packages are typically updated prior to NGRX etc...\n        // Therefore, we only update to the latest patch version of the installed major version of the Angular CLI.\n        // This is important because we might end up in a scenario where locally Angular v12 is installed, updating NGRX from 11 to 12.\n        // We end up using Angular ClI v13 to run the migrations if we run the migrations using the CLI installed major version + 1 logic.\n        return version_1.VERSION.major;\n    }\n    async runTempBinary(packageName, args = []) {\n        const { success, tempNodeModules } = await this.context.packageManager.installTemp(packageName);\n        if (!success) {\n            return 1;\n        }\n        // Remove version/tag etc... from package name\n        // Ex: @angular/cli@latest -> @angular/cli\n        const packageNameNoVersion = packageName.substring(0, packageName.lastIndexOf('@'));\n        const pkgLocation = (0, path_1.join)(tempNodeModules, packageNameNoVersion);\n        const packageJsonPath = (0, path_1.join)(pkgLocation, 'package.json');\n        // Get a binary location for this package\n        let binPath;\n        if ((0, fs_1.existsSync)(packageJsonPath)) {\n            const content = await fs_1.promises.readFile(packageJsonPath, 'utf-8');\n            if (content) {\n                const { bin = {} } = JSON.parse(content);\n                const binKeys = Object.keys(bin);\n                if (binKeys.length) {\n                    binPath = (0, path_1.resolve)(pkgLocation, bin[binKeys[0]]);\n                }\n            }\n        }\n        if (!binPath) {\n            throw new Error(`Cannot locate bin for temporary package: ${packageNameNoVersion}.`);\n        }\n        const { status, error } = (0, child_process_1.spawnSync)(process.execPath, [binPath, ...args], {\n            stdio: 'inherit',\n            env: {\n                ...process.env,\n                NG_DISABLE_VERSION_CHECK: 'true',\n                NG_CLI_ANALYTICS: 'false',\n            },\n        });\n        if (status === null && error) {\n            throw error;\n        }\n        return status !== null && status !== void 0 ? status : 0;\n    }\n    packageManagerForce(verbose) {\n        // npm 7+ can fail due to it incorrectly resolving peer dependencies that have valid SemVer\n        // ranges during an update. Update will set correct versions of dependencies within the\n        // package.json file. The force option is set to workaround these errors.\n        // Example error:\n        // npm ERR! Conflicting peer dependency: @angular/compiler-cli@14.0.0-rc.0\n        // npm ERR! node_modules/@angular/compiler-cli\n        // npm ERR!   peer @angular/compiler-cli@\"^14.0.0 || ^14.0.0-rc\" from @angular-devkit/build-angular@14.0.0-rc.0\n        // npm ERR!   node_modules/@angular-devkit/build-angular\n        // npm ERR!     dev @angular-devkit/build-angular@\"~14.0.0-rc.0\" from the root project\n        if (this.context.packageManager.name === workspace_schema_1.PackageManager.Npm &&\n            this.context.packageManager.version &&\n            semver.gte(this.context.packageManager.version, '7.0.0')) {\n            if (verbose) {\n                this.context.logger.info('NPM 7+ detected -- enabling force option for package installation');\n            }\n            return true;\n        }\n        return false;\n    }\n}\nexports.UpdateCommandModule = UpdateCommandModule;\n/**\n * @return Whether or not the working directory has Git changes to commit.\n */\nfunction hasChangesToCommit() {\n    // List all modified files not covered by .gitignore.\n    // If any files are returned, then there must be something to commit.\n    return (0, child_process_1.execSync)('git ls-files -m -d -o --exclude-standard').toString() !== '';\n}\n/**\n * Precondition: Must have pending changes to commit, they do not need to be staged.\n * Postcondition: The Git working tree is committed and the repo is clean.\n * @param message The commit message to use.\n */\nfunction createCommit(message) {\n    // Stage entire working tree for commit.\n    (0, child_process_1.execSync)('git add -A', { encoding: 'utf8', stdio: 'pipe' });\n    // Commit with the message passed via stdin to avoid bash escaping issues.\n    (0, child_process_1.execSync)('git commit --no-verify -F -', { encoding: 'utf8', stdio: 'pipe', input: message });\n}\n/**\n * @return The Git SHA hash of the HEAD commit. Returns null if unable to retrieve the hash.\n */\nfunction findCurrentGitSha() {\n    try {\n        return (0, child_process_1.execSync)('git rev-parse HEAD', { encoding: 'utf8', stdio: 'pipe' }).trim();\n    }\n    catch {\n        return null;\n    }\n}\nfunction getShortHash(commitHash) {\n    return commitHash.slice(0, 9);\n}\nfunction coerceVersionNumber(version) {\n    var _a;\n    if (!version) {\n        return undefined;\n    }\n    if (!/^\\d{1,30}\\.\\d{1,30}\\.\\d{1,30}/.test(version)) {\n        const match = version.match(/^\\d{1,30}(\\.\\d{1,30})*/);\n        if (!match) {\n            return undefined;\n        }\n        if (!match[1]) {\n            version = version.substring(0, match[0].length) + '.0.0' + version.substring(match[0].length);\n        }\n        else if (!match[2]) {\n            version = version.substring(0, match[0].length) + '.0' + version.substring(match[0].length);\n        }\n        else {\n            return undefined;\n        }\n    }\n    return (_a = semver.valid(version)) !== null && _a !== void 0 ? _a : undefined;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}