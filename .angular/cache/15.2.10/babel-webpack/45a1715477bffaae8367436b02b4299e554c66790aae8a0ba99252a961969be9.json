{"ast":null,"code":"var charToInteger = {};\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nfor (var i = 0; i < chars.length; i++) {\n  charToInteger[chars.charCodeAt(i)] = i;\n}\nfunction decode(mappings) {\n  var decoded = [];\n  var line = [];\n  var segment = [0, 0, 0, 0, 0];\n  var j = 0;\n  for (var i = 0, shift = 0, value = 0; i < mappings.length; i++) {\n    var c = mappings.charCodeAt(i);\n    if (c === 44) {\n      // \",\"\n      segmentify(line, segment, j);\n      j = 0;\n    } else if (c === 59) {\n      // \";\"\n      segmentify(line, segment, j);\n      j = 0;\n      decoded.push(line);\n      line = [];\n      segment[0] = 0;\n    } else {\n      var integer = charToInteger[c];\n      if (integer === undefined) {\n        throw new Error('Invalid character (' + String.fromCharCode(c) + ')');\n      }\n      var hasContinuationBit = integer & 32;\n      integer &= 31;\n      value += integer << shift;\n      if (hasContinuationBit) {\n        shift += 5;\n      } else {\n        var shouldNegate = value & 1;\n        value >>>= 1;\n        if (shouldNegate) {\n          value = value === 0 ? -0x80000000 : -value;\n        }\n        segment[j] += value;\n        j++;\n        value = shift = 0; // reset\n      }\n    }\n  }\n\n  segmentify(line, segment, j);\n  decoded.push(line);\n  return decoded;\n}\nfunction segmentify(line, segment, j) {\n  // This looks ugly, but we're creating specialized arrays with a specific\n  // length. This is much faster than creating a new array (which v8 expands to\n  // a capacity of 17 after pushing the first item), or slicing out a subarray\n  // (which is slow). Length 4 is assumed to be the most frequent, followed by\n  // length 5 (since not everything will have an associated name), followed by\n  // length 1 (it's probably rare for a source substring to not have an\n  // associated segment data).\n  if (j === 4) line.push([segment[0], segment[1], segment[2], segment[3]]);else if (j === 5) line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);else if (j === 1) line.push([segment[0]]);\n}\nfunction encode(decoded) {\n  var sourceFileIndex = 0; // second field\n  var sourceCodeLine = 0; // third field\n  var sourceCodeColumn = 0; // fourth field\n  var nameIndex = 0; // fifth field\n  var mappings = '';\n  for (var i = 0; i < decoded.length; i++) {\n    var line = decoded[i];\n    if (i > 0) mappings += ';';\n    if (line.length === 0) continue;\n    var generatedCodeColumn = 0; // first field\n    var lineMappings = [];\n    for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {\n      var segment = line_1[_i];\n      var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);\n      generatedCodeColumn = segment[0];\n      if (segment.length > 1) {\n        segmentMappings += encodeInteger(segment[1] - sourceFileIndex) + encodeInteger(segment[2] - sourceCodeLine) + encodeInteger(segment[3] - sourceCodeColumn);\n        sourceFileIndex = segment[1];\n        sourceCodeLine = segment[2];\n        sourceCodeColumn = segment[3];\n      }\n      if (segment.length === 5) {\n        segmentMappings += encodeInteger(segment[4] - nameIndex);\n        nameIndex = segment[4];\n      }\n      lineMappings.push(segmentMappings);\n    }\n    mappings += lineMappings.join(',');\n  }\n  return mappings;\n}\nfunction encodeInteger(num) {\n  var result = '';\n  num = num < 0 ? -num << 1 | 1 : num << 1;\n  do {\n    var clamped = num & 31;\n    num >>>= 5;\n    if (num > 0) {\n      clamped |= 32;\n    }\n    result += chars[clamped];\n  } while (num > 0);\n  return result;\n}\nexport { decode, encode };","map":{"version":3,"names":["charToInteger","chars","i","length","charCodeAt","decode","mappings","decoded","line","segment","j","shift","value","c","segmentify","push","integer","undefined","Error","String","fromCharCode","hasContinuationBit","shouldNegate","encode","sourceFileIndex","sourceCodeLine","sourceCodeColumn","nameIndex","generatedCodeColumn","lineMappings","_i","line_1","segmentMappings","encodeInteger","join","num","result","clamped"],"sources":["I:/Angular/angular-blog/node_modules/sourcemap-codec/dist/sourcemap-codec.es.js"],"sourcesContent":["var charToInteger = {};\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nfor (var i = 0; i < chars.length; i++) {\n    charToInteger[chars.charCodeAt(i)] = i;\n}\nfunction decode(mappings) {\n    var decoded = [];\n    var line = [];\n    var segment = [\n        0,\n        0,\n        0,\n        0,\n        0,\n    ];\n    var j = 0;\n    for (var i = 0, shift = 0, value = 0; i < mappings.length; i++) {\n        var c = mappings.charCodeAt(i);\n        if (c === 44) { // \",\"\n            segmentify(line, segment, j);\n            j = 0;\n        }\n        else if (c === 59) { // \";\"\n            segmentify(line, segment, j);\n            j = 0;\n            decoded.push(line);\n            line = [];\n            segment[0] = 0;\n        }\n        else {\n            var integer = charToInteger[c];\n            if (integer === undefined) {\n                throw new Error('Invalid character (' + String.fromCharCode(c) + ')');\n            }\n            var hasContinuationBit = integer & 32;\n            integer &= 31;\n            value += integer << shift;\n            if (hasContinuationBit) {\n                shift += 5;\n            }\n            else {\n                var shouldNegate = value & 1;\n                value >>>= 1;\n                if (shouldNegate) {\n                    value = value === 0 ? -0x80000000 : -value;\n                }\n                segment[j] += value;\n                j++;\n                value = shift = 0; // reset\n            }\n        }\n    }\n    segmentify(line, segment, j);\n    decoded.push(line);\n    return decoded;\n}\nfunction segmentify(line, segment, j) {\n    // This looks ugly, but we're creating specialized arrays with a specific\n    // length. This is much faster than creating a new array (which v8 expands to\n    // a capacity of 17 after pushing the first item), or slicing out a subarray\n    // (which is slow). Length 4 is assumed to be the most frequent, followed by\n    // length 5 (since not everything will have an associated name), followed by\n    // length 1 (it's probably rare for a source substring to not have an\n    // associated segment data).\n    if (j === 4)\n        line.push([segment[0], segment[1], segment[2], segment[3]]);\n    else if (j === 5)\n        line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);\n    else if (j === 1)\n        line.push([segment[0]]);\n}\nfunction encode(decoded) {\n    var sourceFileIndex = 0; // second field\n    var sourceCodeLine = 0; // third field\n    var sourceCodeColumn = 0; // fourth field\n    var nameIndex = 0; // fifth field\n    var mappings = '';\n    for (var i = 0; i < decoded.length; i++) {\n        var line = decoded[i];\n        if (i > 0)\n            mappings += ';';\n        if (line.length === 0)\n            continue;\n        var generatedCodeColumn = 0; // first field\n        var lineMappings = [];\n        for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {\n            var segment = line_1[_i];\n            var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);\n            generatedCodeColumn = segment[0];\n            if (segment.length > 1) {\n                segmentMappings +=\n                    encodeInteger(segment[1] - sourceFileIndex) +\n                        encodeInteger(segment[2] - sourceCodeLine) +\n                        encodeInteger(segment[3] - sourceCodeColumn);\n                sourceFileIndex = segment[1];\n                sourceCodeLine = segment[2];\n                sourceCodeColumn = segment[3];\n            }\n            if (segment.length === 5) {\n                segmentMappings += encodeInteger(segment[4] - nameIndex);\n                nameIndex = segment[4];\n            }\n            lineMappings.push(segmentMappings);\n        }\n        mappings += lineMappings.join(',');\n    }\n    return mappings;\n}\nfunction encodeInteger(num) {\n    var result = '';\n    num = num < 0 ? (-num << 1) | 1 : num << 1;\n    do {\n        var clamped = num & 31;\n        num >>>= 5;\n        if (num > 0) {\n            clamped |= 32;\n        }\n        result += chars[clamped];\n    } while (num > 0);\n    return result;\n}\n\nexport { decode, encode };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}