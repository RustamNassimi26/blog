{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"I:/Angular/angular-blog/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst fs = require('graceful-fs');\nconst os = require('os');\nconst {\n  backOff\n} = require('exponential-backoff');\nconst rm = require('rimraf');\nconst tar = require('tar');\nconst path = require('path');\nconst util = require('util');\nconst stream = require('stream');\nconst crypto = require('crypto');\nconst log = require('npmlog');\nconst semver = require('semver');\nconst fetch = require('make-fetch-happen');\nconst processRelease = require('./process-release');\nconst win = process.platform === 'win32';\nconst streamPipeline = util.promisify(stream.pipeline);\n\n/**\n * @param {typeof import('graceful-fs')} fs\n */\nfunction install(_x, _x2, _x3) {\n  return _install.apply(this, arguments);\n}\nfunction _install() {\n  _install = _asyncToGenerator(function* (fs, gyp, argv) {\n    const release = processRelease(argv, gyp, process.version, process.release);\n    // Detecting target_arch based on logic from create-cnfig-gyp.js. Used on Windows only.\n    const arch = win ? gyp.opts.target_arch || gyp.opts.arch || process.arch || 'ia32' : '';\n    // Used to prevent downloading tarball if only new node.lib is required on Windows.\n    let shouldDownloadTarball = true;\n\n    // Determine which node dev files version we are installing\n    log.verbose('install', 'input version string %j', release.version);\n    if (!release.semver) {\n      // could not parse the version string with semver\n      throw new Error('Invalid version number: ' + release.version);\n    }\n    if (semver.lt(release.version, '0.8.0')) {\n      throw new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version);\n    }\n\n    // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n    if (release.semver.prerelease[0] === 'pre') {\n      log.verbose('detected \"pre\" node version', release.version);\n      if (!gyp.opts.nodedir) {\n        throw new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead');\n      }\n      log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir);\n      return;\n    }\n\n    // flatten version into String\n    log.verbose('install', 'installing version: %s', release.versionDir);\n\n    // the directory where the dev files will be installed\n    const devDir = path.resolve(gyp.devDir, release.versionDir);\n\n    // If '--ensure' was passed, then don't *always* install the version;\n    // check if it is already installed, and only install when needed\n    if (gyp.opts.ensure) {\n      log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed');\n      try {\n        yield fs.promises.stat(devDir);\n      } catch (err) {\n        if (err.code === 'ENOENT') {\n          log.verbose('install', 'version not already installed, continuing with install', release.version);\n          try {\n            return yield go();\n          } catch (err) {\n            return rollback(err);\n          }\n        } else if (err.code === 'EACCES') {\n          return eaccesFallback(err);\n        }\n        throw err;\n      }\n      log.verbose('install', 'version is already installed, need to check \"installVersion\"');\n      const installVersionFile = path.resolve(devDir, 'installVersion');\n      let installVersion = 0;\n      try {\n        const ver = yield fs.promises.readFile(installVersionFile, 'ascii');\n        installVersion = parseInt(ver, 10) || 0;\n      } catch (err) {\n        if (err.code !== 'ENOENT') {\n          throw err;\n        }\n      }\n      log.verbose('got \"installVersion\"', installVersion);\n      log.verbose('needs \"installVersion\"', gyp.package.installVersion);\n      if (installVersion < gyp.package.installVersion) {\n        log.verbose('install', 'version is no good; reinstalling');\n        try {\n          return yield go();\n        } catch (err) {\n          return rollback(err);\n        }\n      }\n      log.verbose('install', 'version is good');\n      if (win) {\n        log.verbose('on Windows; need to check node.lib');\n        const nodeLibPath = path.resolve(devDir, arch, 'node.lib');\n        try {\n          yield fs.promises.stat(nodeLibPath);\n        } catch (err) {\n          if (err.code === 'ENOENT') {\n            log.verbose('install', `version not already installed for ${arch}, continuing with install`, release.version);\n            try {\n              shouldDownloadTarball = false;\n              return yield go();\n            } catch (err) {\n              return rollback(err);\n            }\n          } else if (err.code === 'EACCES') {\n            return eaccesFallback(err);\n          }\n          throw err;\n        }\n      }\n    } else {\n      try {\n        return yield go();\n      } catch (err) {\n        return rollback(err);\n      }\n    }\n    function copyDirectory(_x7, _x8) {\n      return _copyDirectory.apply(this, arguments);\n    }\n    function _copyDirectory() {\n      _copyDirectory = _asyncToGenerator(function* (src, dest) {\n        try {\n          yield fs.promises.stat(src);\n        } catch {\n          throw new Error(`Missing source directory for copy: ${src}`);\n        }\n        yield fs.promises.mkdir(dest, {\n          recursive: true\n        });\n        const entries = yield fs.promises.readdir(src, {\n          withFileTypes: true\n        });\n        for (const entry of entries) {\n          if (entry.isDirectory()) {\n            yield copyDirectory(path.join(src, entry.name), path.join(dest, entry.name));\n          } else if (entry.isFile()) {\n            // with parallel installs, copying files may cause file errors on\n            // Windows so use an exponential backoff to resolve collisions\n            yield backOff( /*#__PURE__*/_asyncToGenerator(function* () {\n              try {\n                yield fs.promises.copyFile(path.join(src, entry.name), path.join(dest, entry.name));\n              } catch (err) {\n                // if ensure, check if file already exists and that's good enough\n                if (gyp.opts.ensure && err.code === 'EBUSY') {\n                  try {\n                    yield fs.promises.stat(path.join(dest, entry.name));\n                    return;\n                  } catch {}\n                }\n                throw err;\n              }\n            }));\n          } else {\n            throw new Error('Unexpected file directory entry type');\n          }\n        }\n      });\n      return _copyDirectory.apply(this, arguments);\n    }\n    function go() {\n      return _go.apply(this, arguments);\n    } // go()\n    /**\n     * Checks if a given filename is \"valid\" for this installation.\n     */\n    function _go() {\n      _go = _asyncToGenerator(function* () {\n        log.verbose('ensuring devDir is created', devDir);\n\n        // first create the dir for the node dev files\n        try {\n          const created = yield fs.promises.mkdir(devDir, {\n            recursive: true\n          });\n          if (created) {\n            log.verbose('created devDir', created);\n          }\n        } catch (err) {\n          if (err.code === 'EACCES') {\n            return eaccesFallback(err);\n          }\n          throw err;\n        }\n\n        // now download the node tarball\n        const tarPath = gyp.opts.tarball;\n        let extractErrors = false;\n        let extractCount = 0;\n        const contentShasums = {};\n        const expectShasums = {};\n\n        // checks if a file to be extracted from the tarball is valid.\n        // only .h header files and the gyp files get extracted\n        function isValid(path) {\n          const isValid = valid(path);\n          if (isValid) {\n            log.verbose('extracted file from tarball', path);\n            extractCount++;\n          } else {\n            // invalid\n            log.silly('ignoring from tarball', path);\n          }\n          return isValid;\n        }\n        function onwarn(code, message) {\n          extractErrors = true;\n          log.error('error while extracting tarball', code, message);\n        }\n\n        // download the tarball and extract!\n        // Ommited on Windows if only new node.lib is required\n\n        // on Windows there can be file errors from tar if parallel installs\n        // are happening (not uncommon with multiple native modules) so\n        // extract the tarball to a temp directory first and then copy over\n        const tarExtractDir = win ? yield fs.promises.mkdtemp(path.join(os.tmpdir(), 'node-gyp-tmp-')) : devDir;\n        try {\n          if (shouldDownloadTarball) {\n            if (tarPath) {\n              yield tar.extract({\n                file: tarPath,\n                strip: 1,\n                filter: isValid,\n                onwarn,\n                cwd: tarExtractDir\n              });\n            } else {\n              try {\n                const res = yield download(gyp, release.tarballUrl);\n                if (res.status !== 200) {\n                  throw new Error(`${res.status} response downloading ${release.tarballUrl}`);\n                }\n                yield streamPipeline(res.body,\n                // content checksum\n                new ShaSum((_, checksum) => {\n                  const filename = path.basename(release.tarballUrl).trim();\n                  contentShasums[filename] = checksum;\n                  log.verbose('content checksum', filename, checksum);\n                }), tar.extract({\n                  strip: 1,\n                  cwd: tarExtractDir,\n                  filter: isValid,\n                  onwarn\n                }));\n              } catch (err) {\n                // something went wrong downloading the tarball?\n                if (err.code === 'ENOTFOUND') {\n                  throw new Error('This is most likely not a problem with node-gyp or the package itself and\\n' + 'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' + 'network settings.');\n                }\n                throw err;\n              }\n            }\n\n            // invoked after the tarball has finished being extracted\n            if (extractErrors || extractCount === 0) {\n              throw new Error('There was a fatal problem while downloading/extracting the tarball');\n            }\n            log.verbose('tarball', 'done parsing tarball');\n          }\n          const installVersionPath = path.resolve(tarExtractDir, 'installVersion');\n          yield Promise.all([\n          // need to download node.lib\n          ...(win ? [downloadNodeLib()] : []),\n          // write the \"installVersion\" file\n          fs.promises.writeFile(installVersionPath, gyp.package.installVersion + '\\n'),\n          // Only download SHASUMS.txt if we downloaded something in need of SHA verification\n          ...(!tarPath || win ? [downloadShasums()] : [])]);\n          log.verbose('download contents checksum', JSON.stringify(contentShasums));\n          // check content shasums\n          for (const k in contentShasums) {\n            log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k]);\n            if (contentShasums[k] !== expectShasums[k]) {\n              throw new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k]);\n            }\n          }\n\n          // copy over the files from the temp tarball extract directory to devDir\n          if (tarExtractDir !== devDir) {\n            yield copyDirectory(tarExtractDir, devDir);\n          }\n        } finally {\n          if (tarExtractDir !== devDir) {\n            try {\n              // try to cleanup temp dir\n              yield util.promisify(rm)(tarExtractDir);\n            } catch {\n              log.warn('failed to clean up temp tarball extract directory');\n            }\n          }\n        }\n        function downloadShasums() {\n          return _downloadShasums.apply(this, arguments);\n        }\n        function _downloadShasums() {\n          _downloadShasums = _asyncToGenerator(function* () {\n            log.verbose('check download content checksum, need to download `SHASUMS256.txt`...');\n            log.verbose('checksum url', release.shasumsUrl);\n            const res = yield download(gyp, release.shasumsUrl);\n            if (res.status !== 200) {\n              throw new Error(`${res.status}  status code downloading checksum`);\n            }\n            for (const line of (yield res.text()).trim().split('\\n')) {\n              const items = line.trim().split(/\\s+/);\n              if (items.length !== 2) {\n                return;\n              }\n\n              // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n              const name = items[1].replace(/^\\.\\//, '');\n              expectShasums[name] = items[0];\n            }\n            log.verbose('checksum data', JSON.stringify(expectShasums));\n          });\n          return _downloadShasums.apply(this, arguments);\n        }\n        function downloadNodeLib() {\n          return _downloadNodeLib.apply(this, arguments);\n        } // downloadNodeLib()\n        function _downloadNodeLib() {\n          _downloadNodeLib = _asyncToGenerator(function* () {\n            log.verbose('on Windows; need to download `' + release.name + '.lib`...');\n            const dir = path.resolve(tarExtractDir, arch);\n            const targetLibPath = path.resolve(dir, release.name + '.lib');\n            const {\n              libUrl,\n              libPath\n            } = release[arch];\n            const name = `${arch} ${release.name}.lib`;\n            log.verbose(name, 'dir', dir);\n            log.verbose(name, 'url', libUrl);\n            yield fs.promises.mkdir(dir, {\n              recursive: true\n            });\n            log.verbose('streaming', name, 'to:', targetLibPath);\n            const res = yield download(gyp, libUrl);\n\n            // Since only required node.lib is downloaded throw error if it is not fetched\n            if (res.status !== 200) {\n              throw new Error(`${res.status} status code downloading ${name}`);\n            }\n            return streamPipeline(res.body, new ShaSum((_, checksum) => {\n              contentShasums[libPath] = checksum;\n              log.verbose('content checksum', libPath, checksum);\n            }), fs.createWriteStream(targetLibPath));\n          });\n          return _downloadNodeLib.apply(this, arguments);\n        }\n      });\n      return _go.apply(this, arguments);\n    }\n    function valid(file) {\n      // header files\n      const extname = path.extname(file);\n      return extname === '.h' || extname === '.gypi';\n    }\n    function rollback(_x9) {\n      return _rollback.apply(this, arguments);\n    }\n    /**\n     * The EACCES fallback is a workaround for npm's `sudo` behavior, where\n     * it drops the permissions before invoking any child processes (like\n     * node-gyp). So what happens is the \"nobody\" user doesn't have\n     * permission to create the dev dir. As a fallback, make the tmpdir() be\n     * the dev dir for this installation. This is not ideal, but at least\n     * the compilation will succeed...\n     */\n    function _rollback() {\n      _rollback = _asyncToGenerator(function* (err) {\n        log.warn('install', 'got an error, rolling back install');\n        // roll-back the install if anything went wrong\n        yield util.promisify(gyp.commands.remove)([release.versionDir]);\n        throw err;\n      });\n      return _rollback.apply(this, arguments);\n    }\n    function eaccesFallback(_x10) {\n      return _eaccesFallback.apply(this, arguments);\n    }\n    function _eaccesFallback() {\n      _eaccesFallback = _asyncToGenerator(function* (err) {\n        const noretry = '--node_gyp_internal_noretry';\n        if (argv.indexOf(noretry) !== -1) {\n          throw err;\n        }\n        const tmpdir = os.tmpdir();\n        gyp.devDir = path.resolve(tmpdir, '.node-gyp');\n        let userString = '';\n        try {\n          // os.userInfo can fail on some systems, it's not critical here\n          userString = ` (\"${os.userInfo().username}\")`;\n        } catch (e) {}\n        log.warn('EACCES', 'current user%s does not have permission to access the dev dir \"%s\"', userString, devDir);\n        log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir);\n        if (process.cwd() === tmpdir) {\n          log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space');\n          gyp.todo.push({\n            name: 'remove',\n            args: argv\n          });\n        }\n        return util.promisify(gyp.commands.install)([noretry].concat(argv));\n      });\n      return _eaccesFallback.apply(this, arguments);\n    }\n  });\n  return _install.apply(this, arguments);\n}\nclass ShaSum extends stream.Transform {\n  constructor(callback) {\n    super();\n    this._callback = callback;\n    this._digester = crypto.createHash('sha256');\n  }\n  _transform(chunk, _, callback) {\n    this._digester.update(chunk);\n    callback(null, chunk);\n  }\n  _flush(callback) {\n    this._callback(null, this._digester.digest('hex'));\n    callback();\n  }\n}\nfunction download(_x4, _x5) {\n  return _download.apply(this, arguments);\n}\nfunction _download() {\n  _download = _asyncToGenerator(function* (gyp, url) {\n    log.http('GET', url);\n    const requestOpts = {\n      headers: {\n        'User-Agent': `node-gyp v${gyp.version} (node ${process.version})`,\n        Connection: 'keep-alive'\n      },\n      proxy: gyp.opts.proxy,\n      noProxy: gyp.opts.noproxy\n    };\n    const cafile = gyp.opts.cafile;\n    if (cafile) {\n      requestOpts.ca = yield readCAFile(cafile);\n    }\n    const res = yield fetch(url, requestOpts);\n    log.http(res.status, res.url);\n    return res;\n  });\n  return _download.apply(this, arguments);\n}\nfunction readCAFile(_x6) {\n  return _readCAFile.apply(this, arguments);\n}\nfunction _readCAFile() {\n  _readCAFile = _asyncToGenerator(function* (filename) {\n    // The CA file can contain multiple certificates so split on certificate\n    // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n    const ca = yield fs.promises.readFile(filename, 'utf8');\n    const re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g;\n    return ca.match(re);\n  });\n  return _readCAFile.apply(this, arguments);\n}\nmodule.exports = function (gyp, argv, callback) {\n  install(fs, gyp, argv).then(callback.bind(undefined, null), callback);\n};\nmodule.exports.test = {\n  download,\n  install,\n  readCAFile\n};\nmodule.exports.usage = 'Install node development files for the specified node version.';","map":{"version":3,"names":["fs","require","os","backOff","rm","tar","path","util","stream","crypto","log","semver","fetch","processRelease","win","process","platform","streamPipeline","promisify","pipeline","install","gyp","argv","release","version","arch","opts","target_arch","shouldDownloadTarball","verbose","Error","lt","prerelease","nodedir","versionDir","devDir","resolve","ensure","promises","stat","err","code","go","rollback","eaccesFallback","installVersionFile","installVersion","ver","readFile","parseInt","package","nodeLibPath","copyDirectory","src","dest","mkdir","recursive","entries","readdir","withFileTypes","entry","isDirectory","join","name","isFile","copyFile","created","tarPath","tarball","extractErrors","extractCount","contentShasums","expectShasums","isValid","valid","silly","onwarn","message","error","tarExtractDir","mkdtemp","tmpdir","extract","file","strip","filter","cwd","res","download","tarballUrl","status","body","ShaSum","_","checksum","filename","basename","trim","installVersionPath","Promise","all","downloadNodeLib","writeFile","downloadShasums","JSON","stringify","k","warn","shasumsUrl","line","text","split","items","length","replace","dir","targetLibPath","libUrl","libPath","createWriteStream","extname","commands","remove","noretry","indexOf","userString","userInfo","username","e","todo","push","args","concat","Transform","constructor","callback","_callback","_digester","createHash","_transform","chunk","update","_flush","digest","url","http","requestOpts","headers","Connection","proxy","noProxy","noproxy","cafile","ca","readCAFile","re","match","module","exports","then","bind","undefined","test","usage"],"sources":["I:/Angular/angular-blog/node_modules/node-gyp/lib/install.js"],"sourcesContent":["'use strict'\n\nconst fs = require('graceful-fs')\nconst os = require('os')\nconst { backOff } = require('exponential-backoff')\nconst rm = require('rimraf')\nconst tar = require('tar')\nconst path = require('path')\nconst util = require('util')\nconst stream = require('stream')\nconst crypto = require('crypto')\nconst log = require('npmlog')\nconst semver = require('semver')\nconst fetch = require('make-fetch-happen')\nconst processRelease = require('./process-release')\nconst win = process.platform === 'win32'\nconst streamPipeline = util.promisify(stream.pipeline)\n\n/**\n * @param {typeof import('graceful-fs')} fs\n */\n\nasync function install (fs, gyp, argv) {\n  const release = processRelease(argv, gyp, process.version, process.release)\n  // Detecting target_arch based on logic from create-cnfig-gyp.js. Used on Windows only.\n  const arch = win ? (gyp.opts.target_arch || gyp.opts.arch || process.arch || 'ia32') : ''\n  // Used to prevent downloading tarball if only new node.lib is required on Windows.\n  let shouldDownloadTarball = true\n\n  // Determine which node dev files version we are installing\n  log.verbose('install', 'input version string %j', release.version)\n\n  if (!release.semver) {\n    // could not parse the version string with semver\n    throw new Error('Invalid version number: ' + release.version)\n  }\n\n  if (semver.lt(release.version, '0.8.0')) {\n    throw new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version)\n  }\n\n  // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n  if (release.semver.prerelease[0] === 'pre') {\n    log.verbose('detected \"pre\" node version', release.version)\n    if (!gyp.opts.nodedir) {\n      throw new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead')\n    }\n    log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir)\n    return\n  }\n\n  // flatten version into String\n  log.verbose('install', 'installing version: %s', release.versionDir)\n\n  // the directory where the dev files will be installed\n  const devDir = path.resolve(gyp.devDir, release.versionDir)\n\n  // If '--ensure' was passed, then don't *always* install the version;\n  // check if it is already installed, and only install when needed\n  if (gyp.opts.ensure) {\n    log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed')\n    try {\n      await fs.promises.stat(devDir)\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        log.verbose('install', 'version not already installed, continuing with install', release.version)\n        try {\n          return await go()\n        } catch (err) {\n          return rollback(err)\n        }\n      } else if (err.code === 'EACCES') {\n        return eaccesFallback(err)\n      }\n      throw err\n    }\n    log.verbose('install', 'version is already installed, need to check \"installVersion\"')\n    const installVersionFile = path.resolve(devDir, 'installVersion')\n    let installVersion = 0\n    try {\n      const ver = await fs.promises.readFile(installVersionFile, 'ascii')\n      installVersion = parseInt(ver, 10) || 0\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        throw err\n      }\n    }\n    log.verbose('got \"installVersion\"', installVersion)\n    log.verbose('needs \"installVersion\"', gyp.package.installVersion)\n    if (installVersion < gyp.package.installVersion) {\n      log.verbose('install', 'version is no good; reinstalling')\n      try {\n        return await go()\n      } catch (err) {\n        return rollback(err)\n      }\n    }\n    log.verbose('install', 'version is good')\n    if (win) {\n      log.verbose('on Windows; need to check node.lib')\n      const nodeLibPath = path.resolve(devDir, arch, 'node.lib')\n      try {\n        await fs.promises.stat(nodeLibPath)\n      } catch (err) {\n        if (err.code === 'ENOENT') {\n          log.verbose('install', `version not already installed for ${arch}, continuing with install`, release.version)\n          try {\n            shouldDownloadTarball = false\n            return await go()\n          } catch (err) {\n            return rollback(err)\n          }\n        } else if (err.code === 'EACCES') {\n          return eaccesFallback(err)\n        }\n        throw err\n      }\n    }\n  } else {\n    try {\n      return await go()\n    } catch (err) {\n      return rollback(err)\n    }\n  }\n\n  async function copyDirectory (src, dest) {\n    try {\n      await fs.promises.stat(src)\n    } catch {\n      throw new Error(`Missing source directory for copy: ${src}`)\n    }\n    await fs.promises.mkdir(dest, { recursive: true })\n    const entries = await fs.promises.readdir(src, { withFileTypes: true })\n    for (const entry of entries) {\n      if (entry.isDirectory()) {\n        await copyDirectory(path.join(src, entry.name), path.join(dest, entry.name))\n      } else if (entry.isFile()) {\n        // with parallel installs, copying files may cause file errors on\n        // Windows so use an exponential backoff to resolve collisions\n        await backOff(async () => {\n          try {\n            await fs.promises.copyFile(path.join(src, entry.name), path.join(dest, entry.name))\n          } catch (err) {\n            // if ensure, check if file already exists and that's good enough\n            if (gyp.opts.ensure && err.code === 'EBUSY') {\n              try {\n                await fs.promises.stat(path.join(dest, entry.name))\n                return\n              } catch {}\n            }\n            throw err\n          }\n        })\n      } else {\n        throw new Error('Unexpected file directory entry type')\n      }\n    }\n  }\n\n  async function go () {\n    log.verbose('ensuring devDir is created', devDir)\n\n    // first create the dir for the node dev files\n    try {\n      const created = await fs.promises.mkdir(devDir, { recursive: true })\n\n      if (created) {\n        log.verbose('created devDir', created)\n      }\n    } catch (err) {\n      if (err.code === 'EACCES') {\n        return eaccesFallback(err)\n      }\n\n      throw err\n    }\n\n    // now download the node tarball\n    const tarPath = gyp.opts.tarball\n    let extractErrors = false\n    let extractCount = 0\n    const contentShasums = {}\n    const expectShasums = {}\n\n    // checks if a file to be extracted from the tarball is valid.\n    // only .h header files and the gyp files get extracted\n    function isValid (path) {\n      const isValid = valid(path)\n      if (isValid) {\n        log.verbose('extracted file from tarball', path)\n        extractCount++\n      } else {\n        // invalid\n        log.silly('ignoring from tarball', path)\n      }\n      return isValid\n    }\n\n    function onwarn (code, message) {\n      extractErrors = true\n      log.error('error while extracting tarball', code, message)\n    }\n\n    // download the tarball and extract!\n    // Ommited on Windows if only new node.lib is required\n\n    // on Windows there can be file errors from tar if parallel installs\n    // are happening (not uncommon with multiple native modules) so\n    // extract the tarball to a temp directory first and then copy over\n    const tarExtractDir = win ? await fs.promises.mkdtemp(path.join(os.tmpdir(), 'node-gyp-tmp-')) : devDir\n\n    try {\n      if (shouldDownloadTarball) {\n        if (tarPath) {\n          await tar.extract({\n            file: tarPath,\n            strip: 1,\n            filter: isValid,\n            onwarn,\n            cwd: tarExtractDir\n          })\n        } else {\n          try {\n            const res = await download(gyp, release.tarballUrl)\n\n            if (res.status !== 200) {\n              throw new Error(`${res.status} response downloading ${release.tarballUrl}`)\n            }\n\n            await streamPipeline(\n              res.body,\n              // content checksum\n              new ShaSum((_, checksum) => {\n                const filename = path.basename(release.tarballUrl).trim()\n                contentShasums[filename] = checksum\n                log.verbose('content checksum', filename, checksum)\n              }),\n              tar.extract({\n                strip: 1,\n                cwd: tarExtractDir,\n                filter: isValid,\n                onwarn\n              })\n            )\n          } catch (err) {\n          // something went wrong downloading the tarball?\n            if (err.code === 'ENOTFOUND') {\n              throw new Error('This is most likely not a problem with node-gyp or the package itself and\\n' +\n              'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' +\n              'network settings.')\n            }\n            throw err\n          }\n        }\n\n        // invoked after the tarball has finished being extracted\n        if (extractErrors || extractCount === 0) {\n          throw new Error('There was a fatal problem while downloading/extracting the tarball')\n        }\n\n        log.verbose('tarball', 'done parsing tarball')\n      }\n\n      const installVersionPath = path.resolve(tarExtractDir, 'installVersion')\n      await Promise.all([\n      // need to download node.lib\n        ...(win ? [downloadNodeLib()] : []),\n        // write the \"installVersion\" file\n        fs.promises.writeFile(installVersionPath, gyp.package.installVersion + '\\n'),\n        // Only download SHASUMS.txt if we downloaded something in need of SHA verification\n        ...(!tarPath || win ? [downloadShasums()] : [])\n      ])\n\n      log.verbose('download contents checksum', JSON.stringify(contentShasums))\n      // check content shasums\n      for (const k in contentShasums) {\n        log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k])\n        if (contentShasums[k] !== expectShasums[k]) {\n          throw new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k])\n        }\n      }\n\n      // copy over the files from the temp tarball extract directory to devDir\n      if (tarExtractDir !== devDir) {\n        await copyDirectory(tarExtractDir, devDir)\n      }\n    } finally {\n      if (tarExtractDir !== devDir) {\n        try {\n          // try to cleanup temp dir\n          await util.promisify(rm)(tarExtractDir)\n        } catch {\n          log.warn('failed to clean up temp tarball extract directory')\n        }\n      }\n    }\n\n    async function downloadShasums () {\n      log.verbose('check download content checksum, need to download `SHASUMS256.txt`...')\n      log.verbose('checksum url', release.shasumsUrl)\n\n      const res = await download(gyp, release.shasumsUrl)\n\n      if (res.status !== 200) {\n        throw new Error(`${res.status}  status code downloading checksum`)\n      }\n\n      for (const line of (await res.text()).trim().split('\\n')) {\n        const items = line.trim().split(/\\s+/)\n        if (items.length !== 2) {\n          return\n        }\n\n        // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n        const name = items[1].replace(/^\\.\\//, '')\n        expectShasums[name] = items[0]\n      }\n\n      log.verbose('checksum data', JSON.stringify(expectShasums))\n    }\n\n    async function downloadNodeLib () {\n      log.verbose('on Windows; need to download `' + release.name + '.lib`...')\n      const dir = path.resolve(tarExtractDir, arch)\n      const targetLibPath = path.resolve(dir, release.name + '.lib')\n      const { libUrl, libPath } = release[arch]\n      const name = `${arch} ${release.name}.lib`\n      log.verbose(name, 'dir', dir)\n      log.verbose(name, 'url', libUrl)\n\n      await fs.promises.mkdir(dir, { recursive: true })\n      log.verbose('streaming', name, 'to:', targetLibPath)\n\n      const res = await download(gyp, libUrl)\n\n      // Since only required node.lib is downloaded throw error if it is not fetched\n      if (res.status !== 200) {\n        throw new Error(`${res.status} status code downloading ${name}`)\n      }\n\n      return streamPipeline(\n        res.body,\n        new ShaSum((_, checksum) => {\n          contentShasums[libPath] = checksum\n          log.verbose('content checksum', libPath, checksum)\n        }),\n        fs.createWriteStream(targetLibPath)\n      )\n    } // downloadNodeLib()\n  } // go()\n\n  /**\n   * Checks if a given filename is \"valid\" for this installation.\n   */\n\n  function valid (file) {\n    // header files\n    const extname = path.extname(file)\n    return extname === '.h' || extname === '.gypi'\n  }\n\n  async function rollback (err) {\n    log.warn('install', 'got an error, rolling back install')\n    // roll-back the install if anything went wrong\n    await util.promisify(gyp.commands.remove)([release.versionDir])\n    throw err\n  }\n\n  /**\n   * The EACCES fallback is a workaround for npm's `sudo` behavior, where\n   * it drops the permissions before invoking any child processes (like\n   * node-gyp). So what happens is the \"nobody\" user doesn't have\n   * permission to create the dev dir. As a fallback, make the tmpdir() be\n   * the dev dir for this installation. This is not ideal, but at least\n   * the compilation will succeed...\n   */\n\n  async function eaccesFallback (err) {\n    const noretry = '--node_gyp_internal_noretry'\n    if (argv.indexOf(noretry) !== -1) {\n      throw err\n    }\n    const tmpdir = os.tmpdir()\n    gyp.devDir = path.resolve(tmpdir, '.node-gyp')\n    let userString = ''\n    try {\n      // os.userInfo can fail on some systems, it's not critical here\n      userString = ` (\"${os.userInfo().username}\")`\n    } catch (e) {}\n    log.warn('EACCES', 'current user%s does not have permission to access the dev dir \"%s\"', userString, devDir)\n    log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir)\n    if (process.cwd() === tmpdir) {\n      log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space')\n      gyp.todo.push({ name: 'remove', args: argv })\n    }\n    return util.promisify(gyp.commands.install)([noretry].concat(argv))\n  }\n}\n\nclass ShaSum extends stream.Transform {\n  constructor (callback) {\n    super()\n    this._callback = callback\n    this._digester = crypto.createHash('sha256')\n  }\n\n  _transform (chunk, _, callback) {\n    this._digester.update(chunk)\n    callback(null, chunk)\n  }\n\n  _flush (callback) {\n    this._callback(null, this._digester.digest('hex'))\n    callback()\n  }\n}\n\nasync function download (gyp, url) {\n  log.http('GET', url)\n\n  const requestOpts = {\n    headers: {\n      'User-Agent': `node-gyp v${gyp.version} (node ${process.version})`,\n      Connection: 'keep-alive'\n    },\n    proxy: gyp.opts.proxy,\n    noProxy: gyp.opts.noproxy\n  }\n\n  const cafile = gyp.opts.cafile\n  if (cafile) {\n    requestOpts.ca = await readCAFile(cafile)\n  }\n\n  const res = await fetch(url, requestOpts)\n  log.http(res.status, res.url)\n\n  return res\n}\n\nasync function readCAFile (filename) {\n  // The CA file can contain multiple certificates so split on certificate\n  // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n  const ca = await fs.promises.readFile(filename, 'utf8')\n  const re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g\n  return ca.match(re)\n}\n\nmodule.exports = function (gyp, argv, callback) {\n  install(fs, gyp, argv).then(callback.bind(undefined, null), callback)\n}\nmodule.exports.test = {\n  download,\n  install,\n  readCAFile\n}\nmodule.exports.usage = 'Install node development files for the specified node version.'\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}