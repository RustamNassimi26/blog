{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"I:/Angular/angular-blog/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PathScurry = exports.Path = exports.PathScurryDarwin = exports.PathScurryPosix = exports.PathScurryWin32 = exports.PathScurryBase = exports.PathPosix = exports.PathWin32 = exports.PathBase = exports.ChildrenCache = exports.ResolveCache = void 0;\nconst lru_cache_1 = require(\"lru-cache\");\nconst path_1 = require(\"path\");\nconst url_1 = require(\"url\");\nconst actualFS = __importStar(require(\"fs\"));\nconst fs_1 = require(\"fs\");\nconst realpathSync = fs_1.realpathSync.native;\n// TODO: test perf of fs/promises realpath vs realpathCB,\n// since the promises one uses realpath.native\nconst promises_1 = require(\"fs/promises\");\nconst minipass_1 = require(\"minipass\");\nconst defaultFS = {\n  lstatSync: fs_1.lstatSync,\n  readdir: fs_1.readdir,\n  readdirSync: fs_1.readdirSync,\n  readlinkSync: fs_1.readlinkSync,\n  realpathSync,\n  promises: {\n    lstat: promises_1.lstat,\n    readdir: promises_1.readdir,\n    readlink: promises_1.readlink,\n    realpath: promises_1.realpath\n  }\n};\n// if they just gave us require('fs') then use our default\nconst fsFromOption = fsOption => !fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {\n  ...defaultFS,\n  ...fsOption,\n  promises: {\n    ...defaultFS.promises,\n    ...(fsOption.promises || {})\n  }\n};\n// turn something like //?/c:/ into c:\\\nconst uncDriveRegexp = /^\\\\\\\\\\?\\\\([a-z]:)\\\\?$/i;\nconst uncToDrive = rootPath => rootPath.replace(/\\//g, '\\\\').replace(uncDriveRegexp, '$1\\\\');\n// windows paths are separated by either / or \\\nconst eitherSep = /[\\\\\\/]/;\nconst UNKNOWN = 0; // may not even exist, for all we know\nconst IFIFO = 0b0001;\nconst IFCHR = 0b0010;\nconst IFDIR = 0b0100;\nconst IFBLK = 0b0110;\nconst IFREG = 0b1000;\nconst IFLNK = 0b1010;\nconst IFSOCK = 0b1100;\nconst IFMT = 0b1111;\n// mask to unset low 4 bits\nconst IFMT_UNKNOWN = ~IFMT;\n// set after successfully calling readdir() and getting entries.\nconst READDIR_CALLED = 16;\n// set after a successful lstat()\nconst LSTAT_CALLED = 32;\n// set if an entry (or one of its parents) is definitely not a dir\nconst ENOTDIR = 64;\n// set if an entry (or one of its parents) does not exist\n// (can also be set on lstat errors like EACCES or ENAMETOOLONG)\nconst ENOENT = 128;\n// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK\n// set if we fail to readlink\nconst ENOREADLINK = 256;\n// set if we know realpath() will fail\nconst ENOREALPATH = 512;\nconst ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;\nconst TYPEMASK = 1023;\nconst entToType = s => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;\n// normalize unicode path names\nconst normalizeCache = new Map();\nconst normalize = s => {\n  const c = normalizeCache.get(s);\n  if (c) return c;\n  const n = s.normalize('NFKD');\n  normalizeCache.set(s, n);\n  return n;\n};\nconst normalizeNocaseCache = new Map();\nconst normalizeNocase = s => {\n  const c = normalizeNocaseCache.get(s);\n  if (c) return c;\n  const n = normalize(s.toLowerCase());\n  normalizeNocaseCache.set(s, n);\n  return n;\n};\n/**\n * An LRUCache for storing resolved path strings or Path objects.\n * @internal\n */\nclass ResolveCache extends lru_cache_1.LRUCache {\n  constructor() {\n    super({\n      max: 256\n    });\n  }\n}\nexports.ResolveCache = ResolveCache;\n// In order to prevent blowing out the js heap by allocating hundreds of\n// thousands of Path entries when walking extremely large trees, the \"children\"\n// in this tree are represented by storing an array of Path entries in an\n// LRUCache, indexed by the parent.  At any time, Path.children() may return an\n// empty array, indicating that it doesn't know about any of its children, and\n// thus has to rebuild that cache.  This is fine, it just means that we don't\n// benefit as much from having the cached entries, but huge directory walks\n// don't blow out the stack, and smaller ones are still as fast as possible.\n//\n//It does impose some complexity when building up the readdir data, because we\n//need to pass a reference to the children array that we started with.\n/**\n * an LRUCache for storing child entries.\n * @internal\n */\nclass ChildrenCache extends lru_cache_1.LRUCache {\n  constructor(maxSize = 16 * 1024) {\n    super({\n      maxSize,\n      // parent + children\n      sizeCalculation: a => a.length + 1\n    });\n  }\n}\nexports.ChildrenCache = ChildrenCache;\nconst setAsCwd = Symbol('PathScurry setAsCwd');\n/**\n * Path objects are sort of like a super-powered\n * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}\n *\n * Each one represents a single filesystem entry on disk, which may or may not\n * exist. It includes methods for reading various types of information via\n * lstat, readlink, and readdir, and caches all information to the greatest\n * degree possible.\n *\n * Note that fs operations that would normally throw will instead return an\n * \"empty\" value. This is in order to prevent excessive overhead from error\n * stack traces.\n */\nclass PathBase {\n  /**\n   * the basename of this path\n   *\n   * **Important**: *always* test the path name against any test string\n   * usingthe {@link isNamed} method, and not by directly comparing this\n   * string. Otherwise, unicode path strings that the system sees as identical\n   * will not be properly treated as the same path, leading to incorrect\n   * behavior and possible security issues.\n   */\n  name;\n  /**\n   * the Path entry corresponding to the path root.\n   *\n   * @internal\n   */\n  root;\n  /**\n   * All roots found within the current PathScurry family\n   *\n   * @internal\n   */\n  roots;\n  /**\n   * a reference to the parent path, or undefined in the case of root entries\n   *\n   * @internal\n   */\n  parent;\n  /**\n   * boolean indicating whether paths are compared case-insensitively\n   * @internal\n   */\n  nocase;\n  // potential default fs override\n  #fs;\n  // Stats fields\n  #dev;\n  get dev() {\n    return this.#dev;\n  }\n  #mode;\n  get mode() {\n    return this.#mode;\n  }\n  #nlink;\n  get nlink() {\n    return this.#nlink;\n  }\n  #uid;\n  get uid() {\n    return this.#uid;\n  }\n  #gid;\n  get gid() {\n    return this.#gid;\n  }\n  #rdev;\n  get rdev() {\n    return this.#rdev;\n  }\n  #blksize;\n  get blksize() {\n    return this.#blksize;\n  }\n  #ino;\n  get ino() {\n    return this.#ino;\n  }\n  #size;\n  get size() {\n    return this.#size;\n  }\n  #blocks;\n  get blocks() {\n    return this.#blocks;\n  }\n  #atimeMs;\n  get atimeMs() {\n    return this.#atimeMs;\n  }\n  #mtimeMs;\n  get mtimeMs() {\n    return this.#mtimeMs;\n  }\n  #ctimeMs;\n  get ctimeMs() {\n    return this.#ctimeMs;\n  }\n  #birthtimeMs;\n  get birthtimeMs() {\n    return this.#birthtimeMs;\n  }\n  #atime;\n  get atime() {\n    return this.#atime;\n  }\n  #mtime;\n  get mtime() {\n    return this.#mtime;\n  }\n  #ctime;\n  get ctime() {\n    return this.#ctime;\n  }\n  #birthtime;\n  get birthtime() {\n    return this.#birthtime;\n  }\n  #matchName;\n  #depth;\n  #fullpath;\n  #fullpathPosix;\n  #relative;\n  #relativePosix;\n  #type;\n  #children;\n  #linkTarget;\n  #realpath;\n  /**\n   * This property is for compatibility with the Dirent class as of\n   * Node v20, where Dirent['path'] refers to the path of the directory\n   * that was passed to readdir.  So, somewhat counterintuitively, this\n   * property refers to the *parent* path, not the path object itself.\n   * For root entries, it's the path to the entry itself.\n   */\n  get path() {\n    return (this.parent || this).fullpath();\n  }\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {\n    this.name = name;\n    this.#matchName = nocase ? normalizeNocase(name) : normalize(name);\n    this.#type = type & TYPEMASK;\n    this.nocase = nocase;\n    this.roots = roots;\n    this.root = root || this;\n    this.#children = children;\n    this.#fullpath = opts.fullpath;\n    this.#relative = opts.relative;\n    this.#relativePosix = opts.relativePosix;\n    this.parent = opts.parent;\n    if (this.parent) {\n      this.#fs = this.parent.#fs;\n    } else {\n      this.#fs = fsFromOption(opts.fs);\n    }\n  }\n  /**\n   * Returns the depth of the Path object from its root.\n   *\n   * For example, a path at `/foo/bar` would have a depth of 2.\n   */\n  depth() {\n    if (this.#depth !== undefined) return this.#depth;\n    if (!this.parent) return this.#depth = 0;\n    return this.#depth = this.parent.depth() + 1;\n  }\n  /**\n   * @internal\n   */\n  childrenCache() {\n    return this.#children;\n  }\n  /**\n   * Get the Path object referenced by the string path, resolved from this Path\n   */\n  resolve(path) {\n    if (!path) {\n      return this;\n    }\n    const rootPath = this.getRootString(path);\n    const dir = path.substring(rootPath.length);\n    const dirParts = dir.split(this.splitSep);\n    const result = rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);\n    return result;\n  }\n  #resolveParts(dirParts) {\n    let p = this;\n    for (const part of dirParts) {\n      p = p.child(part);\n    }\n    return p;\n  }\n  /**\n   * Returns the cached children Path objects, if still available.  If they\n   * have fallen out of the cache, then returns an empty array, and resets the\n   * READDIR_CALLED bit, so that future calls to readdir() will require an fs\n   * lookup.\n   *\n   * @internal\n   */\n  children() {\n    const cached = this.#children.get(this);\n    if (cached) {\n      return cached;\n    }\n    const children = Object.assign([], {\n      provisional: 0\n    });\n    this.#children.set(this, children);\n    this.#type &= ~READDIR_CALLED;\n    return children;\n  }\n  /**\n   * Resolves a path portion and returns or creates the child Path.\n   *\n   * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is\n   * `'..'`.\n   *\n   * This should not be called directly.  If `pathPart` contains any path\n   * separators, it will lead to unsafe undefined behavior.\n   *\n   * Use `Path.resolve()` instead.\n   *\n   * @internal\n   */\n  child(pathPart, opts) {\n    if (pathPart === '' || pathPart === '.') {\n      return this;\n    }\n    if (pathPart === '..') {\n      return this.parent || this;\n    }\n    // find the child\n    const children = this.children();\n    const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);\n    for (const p of children) {\n      if (p.#matchName === name) {\n        return p;\n      }\n    }\n    // didn't find it, create provisional child, since it might not\n    // actually exist.  If we know the parent isn't a dir, then\n    // in fact it CAN'T exist.\n    const s = this.parent ? this.sep : '';\n    const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : undefined;\n    const pchild = this.newChild(pathPart, UNKNOWN, {\n      ...opts,\n      parent: this,\n      fullpath\n    });\n    if (!this.canReaddir()) {\n      pchild.#type |= ENOENT;\n    }\n    // don't have to update provisional, because if we have real children,\n    // then provisional is set to children.length, otherwise a lower number\n    children.push(pchild);\n    return pchild;\n  }\n  /**\n   * The relative path from the cwd. If it does not share an ancestor with\n   * the cwd, then this ends up being equivalent to the fullpath()\n   */\n  relative() {\n    if (this.#relative !== undefined) {\n      return this.#relative;\n    }\n    const name = this.name;\n    const p = this.parent;\n    if (!p) {\n      return this.#relative = this.name;\n    }\n    const pv = p.relative();\n    return pv + (!pv || !p.parent ? '' : this.sep) + name;\n  }\n  /**\n   * The relative path from the cwd, using / as the path separator.\n   * If it does not share an ancestor with\n   * the cwd, then this ends up being equivalent to the fullpathPosix()\n   * On posix systems, this is identical to relative().\n   */\n  relativePosix() {\n    if (this.sep === '/') return this.relative();\n    if (this.#relativePosix !== undefined) return this.#relativePosix;\n    const name = this.name;\n    const p = this.parent;\n    if (!p) {\n      return this.#relativePosix = this.fullpathPosix();\n    }\n    const pv = p.relativePosix();\n    return pv + (!pv || !p.parent ? '' : '/') + name;\n  }\n  /**\n   * The fully resolved path string for this Path entry\n   */\n  fullpath() {\n    if (this.#fullpath !== undefined) {\n      return this.#fullpath;\n    }\n    const name = this.name;\n    const p = this.parent;\n    if (!p) {\n      return this.#fullpath = this.name;\n    }\n    const pv = p.fullpath();\n    const fp = pv + (!p.parent ? '' : this.sep) + name;\n    return this.#fullpath = fp;\n  }\n  /**\n   * On platforms other than windows, this is identical to fullpath.\n   *\n   * On windows, this is overridden to return the forward-slash form of the\n   * full UNC path.\n   */\n  fullpathPosix() {\n    if (this.#fullpathPosix !== undefined) return this.#fullpathPosix;\n    if (this.sep === '/') return this.#fullpathPosix = this.fullpath();\n    if (!this.parent) {\n      const p = this.fullpath().replace(/\\\\/g, '/');\n      if (/^[a-z]:\\//i.test(p)) {\n        return this.#fullpathPosix = `//?/${p}`;\n      } else {\n        return this.#fullpathPosix = p;\n      }\n    }\n    const p = this.parent;\n    const pfpp = p.fullpathPosix();\n    const fpp = pfpp + (!pfpp || !p.parent ? '' : '/') + this.name;\n    return this.#fullpathPosix = fpp;\n  }\n  /**\n   * Is the Path of an unknown type?\n   *\n   * Note that we might know *something* about it if there has been a previous\n   * filesystem operation, for example that it does not exist, or is not a\n   * link, or whether it has child entries.\n   */\n  isUnknown() {\n    return (this.#type & IFMT) === UNKNOWN;\n  }\n  isType(type) {\n    return this[`is${type}`]();\n  }\n  getType() {\n    return this.isUnknown() ? 'Unknown' : this.isDirectory() ? 'Directory' : this.isFile() ? 'File' : this.isSymbolicLink() ? 'SymbolicLink' : this.isFIFO() ? 'FIFO' : this.isCharacterDevice() ? 'CharacterDevice' : this.isBlockDevice() ? 'BlockDevice' : /* c8 ignore start */this.isSocket() ? 'Socket' : 'Unknown';\n    /* c8 ignore stop */\n  }\n  /**\n   * Is the Path a regular file?\n   */\n  isFile() {\n    return (this.#type & IFMT) === IFREG;\n  }\n  /**\n   * Is the Path a directory?\n   */\n  isDirectory() {\n    return (this.#type & IFMT) === IFDIR;\n  }\n  /**\n   * Is the path a character device?\n   */\n  isCharacterDevice() {\n    return (this.#type & IFMT) === IFCHR;\n  }\n  /**\n   * Is the path a block device?\n   */\n  isBlockDevice() {\n    return (this.#type & IFMT) === IFBLK;\n  }\n  /**\n   * Is the path a FIFO pipe?\n   */\n  isFIFO() {\n    return (this.#type & IFMT) === IFIFO;\n  }\n  /**\n   * Is the path a socket?\n   */\n  isSocket() {\n    return (this.#type & IFMT) === IFSOCK;\n  }\n  /**\n   * Is the path a symbolic link?\n   */\n  isSymbolicLink() {\n    return (this.#type & IFLNK) === IFLNK;\n  }\n  /**\n   * Return the entry if it has been subject of a successful lstat, or\n   * undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* simply\n   * mean that we haven't called lstat on it.\n   */\n  lstatCached() {\n    return this.#type & LSTAT_CALLED ? this : undefined;\n  }\n  /**\n   * Return the cached link target if the entry has been the subject of a\n   * successful readlink, or undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * readlink() has been called at some point.\n   */\n  readlinkCached() {\n    return this.#linkTarget;\n  }\n  /**\n   * Returns the cached realpath target if the entry has been the subject\n   * of a successful realpath, or undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * realpath() has been called at some point.\n   */\n  realpathCached() {\n    return this.#realpath;\n  }\n  /**\n   * Returns the cached child Path entries array if the entry has been the\n   * subject of a successful readdir(), or [] otherwise.\n   *\n   * Does not read the filesystem, so an empty array *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * readdir() has been called recently enough to still be valid.\n   */\n  readdirCached() {\n    const children = this.children();\n    return children.slice(0, children.provisional);\n  }\n  /**\n   * Return true if it's worth trying to readlink.  Ie, we don't (yet) have\n   * any indication that readlink will definitely fail.\n   *\n   * Returns false if the path is known to not be a symlink, if a previous\n   * readlink failed, or if the entry does not exist.\n   */\n  canReadlink() {\n    if (this.#linkTarget) return true;\n    if (!this.parent) return false;\n    // cases where it cannot possibly succeed\n    const ifmt = this.#type & IFMT;\n    return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);\n  }\n  /**\n   * Return true if readdir has previously been successfully called on this\n   * path, indicating that cachedReaddir() is likely valid.\n   */\n  calledReaddir() {\n    return !!(this.#type & READDIR_CALLED);\n  }\n  /**\n   * Returns true if the path is known to not exist. That is, a previous lstat\n   * or readdir failed to verify its existence when that would have been\n   * expected, or a parent entry was marked either enoent or enotdir.\n   */\n  isENOENT() {\n    return !!(this.#type & ENOENT);\n  }\n  /**\n   * Return true if the path is a match for the given path name.  This handles\n   * case sensitivity and unicode normalization.\n   *\n   * Note: even on case-sensitive systems, it is **not** safe to test the\n   * equality of the `.name` property to determine whether a given pathname\n   * matches, due to unicode normalization mismatches.\n   *\n   * Always use this method instead of testing the `path.name` property\n   * directly.\n   */\n  isNamed(n) {\n    return !this.nocase ? this.#matchName === normalize(n) : this.#matchName === normalizeNocase(n);\n  }\n  /**\n   * Return the Path object corresponding to the target of a symbolic link.\n   *\n   * If the Path is not a symbolic link, or if the readlink call fails for any\n   * reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   */\n  readlink() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const target = _this.#linkTarget;\n      if (target) {\n        return target;\n      }\n      if (!_this.canReadlink()) {\n        return undefined;\n      }\n      /* c8 ignore start */\n      // already covered by the canReadlink test, here for ts grumples\n      if (!_this.parent) {\n        return undefined;\n      }\n      /* c8 ignore stop */\n      try {\n        const read = yield _this.#fs.promises.readlink(_this.fullpath());\n        const linkTarget = _this.parent.resolve(read);\n        if (linkTarget) {\n          return _this.#linkTarget = linkTarget;\n        }\n      } catch (er) {\n        _this.#readlinkFail(er.code);\n        return undefined;\n      }\n    })();\n  }\n  /**\n   * Synchronous {@link PathBase.readlink}\n   */\n  readlinkSync() {\n    const target = this.#linkTarget;\n    if (target) {\n      return target;\n    }\n    if (!this.canReadlink()) {\n      return undefined;\n    }\n    /* c8 ignore start */\n    // already covered by the canReadlink test, here for ts grumples\n    if (!this.parent) {\n      return undefined;\n    }\n    /* c8 ignore stop */\n    try {\n      const read = this.#fs.readlinkSync(this.fullpath());\n      const linkTarget = this.parent.resolve(read);\n      if (linkTarget) {\n        return this.#linkTarget = linkTarget;\n      }\n    } catch (er) {\n      this.#readlinkFail(er.code);\n      return undefined;\n    }\n  }\n  #readdirSuccess(children) {\n    // succeeded, mark readdir called bit\n    this.#type |= READDIR_CALLED;\n    // mark all remaining provisional children as ENOENT\n    for (let p = children.provisional; p < children.length; p++) {\n      children[p].#markENOENT();\n    }\n  }\n  #markENOENT() {\n    // mark as UNKNOWN and ENOENT\n    if (this.#type & ENOENT) return;\n    this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;\n    this.#markChildrenENOENT();\n  }\n  #markChildrenENOENT() {\n    // all children are provisional and do not exist\n    const children = this.children();\n    children.provisional = 0;\n    for (const p of children) {\n      p.#markENOENT();\n    }\n  }\n  #markENOREALPATH() {\n    this.#type |= ENOREALPATH;\n    this.#markENOTDIR();\n  }\n  // save the information when we know the entry is not a dir\n  #markENOTDIR() {\n    // entry is not a directory, so any children can't exist.\n    // this *should* be impossible, since any children created\n    // after it's been marked ENOTDIR should be marked ENOENT,\n    // so it won't even get to this point.\n    /* c8 ignore start */\n    if (this.#type & ENOTDIR) return;\n    /* c8 ignore stop */\n    let t = this.#type;\n    // this could happen if we stat a dir, then delete it,\n    // then try to read it or one of its children.\n    if ((t & IFMT) === IFDIR) t &= IFMT_UNKNOWN;\n    this.#type = t | ENOTDIR;\n    this.#markChildrenENOENT();\n  }\n  #readdirFail(code = '') {\n    // markENOTDIR and markENOENT also set provisional=0\n    if (code === 'ENOTDIR' || code === 'EPERM') {\n      this.#markENOTDIR();\n    } else if (code === 'ENOENT') {\n      this.#markENOENT();\n    } else {\n      this.children().provisional = 0;\n    }\n  }\n  #lstatFail(code = '') {\n    // Windows just raises ENOENT in this case, disable for win CI\n    /* c8 ignore start */\n    if (code === 'ENOTDIR') {\n      // already know it has a parent by this point\n      const p = this.parent;\n      p.#markENOTDIR();\n    } else if (code === 'ENOENT') {\n      /* c8 ignore stop */\n      this.#markENOENT();\n    }\n  }\n  #readlinkFail(code = '') {\n    let ter = this.#type;\n    ter |= ENOREADLINK;\n    if (code === 'ENOENT') ter |= ENOENT;\n    // windows gets a weird error when you try to readlink a file\n    if (code === 'EINVAL' || code === 'UNKNOWN') {\n      // exists, but not a symlink, we don't know WHAT it is, so remove\n      // all IFMT bits.\n      ter &= IFMT_UNKNOWN;\n    }\n    this.#type = ter;\n    // windows just gets ENOENT in this case.  We do cover the case,\n    // just disabled because it's impossible on Windows CI\n    /* c8 ignore start */\n    if (code === 'ENOTDIR' && this.parent) {\n      this.parent.#markENOTDIR();\n    }\n    /* c8 ignore stop */\n  }\n\n  #readdirAddChild(e, c) {\n    return this.#readdirMaybePromoteChild(e, c) || this.#readdirAddNewChild(e, c);\n  }\n  #readdirAddNewChild(e, c) {\n    // alloc new entry at head, so it's never provisional\n    const type = entToType(e);\n    const child = this.newChild(e.name, type, {\n      parent: this\n    });\n    const ifmt = child.#type & IFMT;\n    if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {\n      child.#type |= ENOTDIR;\n    }\n    c.unshift(child);\n    c.provisional++;\n    return child;\n  }\n  #readdirMaybePromoteChild(e, c) {\n    for (let p = c.provisional; p < c.length; p++) {\n      const pchild = c[p];\n      const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);\n      if (name !== pchild.#matchName) {\n        continue;\n      }\n      return this.#readdirPromoteChild(e, pchild, p, c);\n    }\n  }\n  #readdirPromoteChild(e, p, index, c) {\n    const v = p.name;\n    // retain any other flags, but set ifmt from dirent\n    p.#type = p.#type & IFMT_UNKNOWN | entToType(e);\n    // case sensitivity fixing when we learn the true name.\n    if (v !== e.name) p.name = e.name;\n    // just advance provisional index (potentially off the list),\n    // otherwise we have to splice/pop it out and re-insert at head\n    if (index !== c.provisional) {\n      if (index === c.length - 1) c.pop();else c.splice(index, 1);\n      c.unshift(p);\n    }\n    c.provisional++;\n    return p;\n  }\n  /**\n   * Call lstat() on this Path, and update all known information that can be\n   * determined.\n   *\n   * Note that unlike `fs.lstat()`, the returned value does not contain some\n   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n   * information is required, you will need to call `fs.lstat` yourself.\n   *\n   * If the Path refers to a nonexistent file, or if the lstat call fails for\n   * any reason, `undefined` is returned.  Otherwise the updated Path object is\n   * returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  lstat() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if ((_this2.#type & ENOENT) === 0) {\n        try {\n          _this2.#applyStat(yield _this2.#fs.promises.lstat(_this2.fullpath()));\n          return _this2;\n        } catch (er) {\n          _this2.#lstatFail(er.code);\n        }\n      }\n    })();\n  }\n  /**\n   * synchronous {@link PathBase.lstat}\n   */\n  lstatSync() {\n    if ((this.#type & ENOENT) === 0) {\n      try {\n        this.#applyStat(this.#fs.lstatSync(this.fullpath()));\n        return this;\n      } catch (er) {\n        this.#lstatFail(er.code);\n      }\n    }\n  }\n  #applyStat(st) {\n    const {\n      atime,\n      atimeMs,\n      birthtime,\n      birthtimeMs,\n      blksize,\n      blocks,\n      ctime,\n      ctimeMs,\n      dev,\n      gid,\n      ino,\n      mode,\n      mtime,\n      mtimeMs,\n      nlink,\n      rdev,\n      size,\n      uid\n    } = st;\n    this.#atime = atime;\n    this.#atimeMs = atimeMs;\n    this.#birthtime = birthtime;\n    this.#birthtimeMs = birthtimeMs;\n    this.#blksize = blksize;\n    this.#blocks = blocks;\n    this.#ctime = ctime;\n    this.#ctimeMs = ctimeMs;\n    this.#dev = dev;\n    this.#gid = gid;\n    this.#ino = ino;\n    this.#mode = mode;\n    this.#mtime = mtime;\n    this.#mtimeMs = mtimeMs;\n    this.#nlink = nlink;\n    this.#rdev = rdev;\n    this.#size = size;\n    this.#uid = uid;\n    const ifmt = entToType(st);\n    // retain any other flags, but set the ifmt\n    this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED;\n    if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {\n      this.#type |= ENOTDIR;\n    }\n  }\n  #onReaddirCB = [];\n  #readdirCBInFlight = false;\n  #callOnReaddirCB(children) {\n    this.#readdirCBInFlight = false;\n    const cbs = this.#onReaddirCB.slice();\n    this.#onReaddirCB.length = 0;\n    cbs.forEach(cb => cb(null, children));\n  }\n  /**\n   * Standard node-style callback interface to get list of directory entries.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   *\n   * @param cb The callback called with (er, entries).  Note that the `er`\n   * param is somewhat extraneous, as all readdir() errors are handled and\n   * simply result in an empty set of entries being returned.\n   * @param allowZalgo Boolean indicating that immediately known results should\n   * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release\n   * zalgo at your peril, the dark pony lord is devious and unforgiving.\n   */\n  readdirCB(cb, allowZalgo = false) {\n    if (!this.canReaddir()) {\n      if (allowZalgo) cb(null, []);else queueMicrotask(() => cb(null, []));\n      return;\n    }\n    const children = this.children();\n    if (this.calledReaddir()) {\n      const c = children.slice(0, children.provisional);\n      if (allowZalgo) cb(null, c);else queueMicrotask(() => cb(null, c));\n      return;\n    }\n    // don't have to worry about zalgo at this point.\n    this.#onReaddirCB.push(cb);\n    if (this.#readdirCBInFlight) {\n      return;\n    }\n    this.#readdirCBInFlight = true;\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath();\n    this.#fs.readdir(fullpath, {\n      withFileTypes: true\n    }, (er, entries) => {\n      if (er) {\n        this.#readdirFail(er.code);\n        children.provisional = 0;\n      } else {\n        // if we didn't get an error, we always get entries.\n        //@ts-ignore\n        for (const e of entries) {\n          this.#readdirAddChild(e, children);\n        }\n        this.#readdirSuccess(children);\n      }\n      this.#callOnReaddirCB(children.slice(0, children.provisional));\n      return;\n    });\n  }\n  #asyncReaddirInFlight;\n  /**\n   * Return an array of known child entries.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  readdir() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this3.canReaddir()) {\n        return [];\n      }\n      const children = _this3.children();\n      if (_this3.calledReaddir()) {\n        return children.slice(0, children.provisional);\n      }\n      // else read the directory, fill up children\n      // de-provisionalize any provisional children.\n      const fullpath = _this3.fullpath();\n      if (_this3.#asyncReaddirInFlight) {\n        yield _this3.#asyncReaddirInFlight;\n      } else {\n        /* c8 ignore start */\n        let resolve = () => {};\n        /* c8 ignore stop */\n        _this3.#asyncReaddirInFlight = new Promise(res => resolve = res);\n        try {\n          for (const e of yield _this3.#fs.promises.readdir(fullpath, {\n            withFileTypes: true\n          })) {\n            _this3.#readdirAddChild(e, children);\n          }\n          _this3.#readdirSuccess(children);\n        } catch (er) {\n          _this3.#readdirFail(er.code);\n          children.provisional = 0;\n        }\n        _this3.#asyncReaddirInFlight = undefined;\n        resolve();\n      }\n      return children.slice(0, children.provisional);\n    })();\n  }\n  /**\n   * synchronous {@link PathBase.readdir}\n   */\n  readdirSync() {\n    if (!this.canReaddir()) {\n      return [];\n    }\n    const children = this.children();\n    if (this.calledReaddir()) {\n      return children.slice(0, children.provisional);\n    }\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath();\n    try {\n      for (const e of this.#fs.readdirSync(fullpath, {\n        withFileTypes: true\n      })) {\n        this.#readdirAddChild(e, children);\n      }\n      this.#readdirSuccess(children);\n    } catch (er) {\n      this.#readdirFail(er.code);\n      children.provisional = 0;\n    }\n    return children.slice(0, children.provisional);\n  }\n  canReaddir() {\n    if (this.#type & ENOCHILD) return false;\n    const ifmt = IFMT & this.#type;\n    // we always set ENOTDIR when setting IFMT, so should be impossible\n    /* c8 ignore start */\n    if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {\n      return false;\n    }\n    /* c8 ignore stop */\n    return true;\n  }\n  shouldWalk(dirs, walkFilter) {\n    return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));\n  }\n  /**\n   * Return the Path object corresponding to path as resolved\n   * by realpath(3).\n   *\n   * If the realpath call fails for any reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   * On success, returns a Path object.\n   */\n  realpath() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      if (_this4.#realpath) return _this4.#realpath;\n      if ((ENOREALPATH | ENOREADLINK | ENOENT) & _this4.#type) return undefined;\n      try {\n        const rp = yield _this4.#fs.promises.realpath(_this4.fullpath());\n        return _this4.#realpath = _this4.resolve(rp);\n      } catch (_) {\n        _this4.#markENOREALPATH();\n      }\n    })();\n  }\n  /**\n   * Synchronous {@link realpath}\n   */\n  realpathSync() {\n    if (this.#realpath) return this.#realpath;\n    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type) return undefined;\n    try {\n      const rp = this.#fs.realpathSync(this.fullpath());\n      return this.#realpath = this.resolve(rp);\n    } catch (_) {\n      this.#markENOREALPATH();\n    }\n  }\n  /**\n   * Internal method to mark this Path object as the scurry cwd,\n   * called by {@link PathScurry#chdir}\n   *\n   * @internal\n   */\n  [setAsCwd](oldCwd) {\n    if (oldCwd === this) return;\n    const changed = new Set([]);\n    let rp = [];\n    let p = this;\n    while (p && p.parent) {\n      changed.add(p);\n      p.#relative = rp.join(this.sep);\n      p.#relativePosix = rp.join('/');\n      p = p.parent;\n      rp.push('..');\n    }\n    // now un-memoize parents of old cwd\n    p = oldCwd;\n    while (p && p.parent && !changed.has(p)) {\n      p.#relative = undefined;\n      p.#relativePosix = undefined;\n      p = p.parent;\n    }\n  }\n}\nexports.PathBase = PathBase;\n/**\n * Path class used on win32 systems\n *\n * Uses `'\\\\'` as the path separator for returned paths, either `'\\\\'` or `'/'`\n * as the path separator for parsing paths.\n */\nclass PathWin32 extends PathBase {\n  /**\n   * Separator for generating path strings.\n   */\n  sep = '\\\\';\n  /**\n   * Separator for parsing path strings.\n   */\n  splitSep = eitherSep;\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {\n    super(name, type, root, roots, nocase, children, opts);\n  }\n  /**\n   * @internal\n   */\n  newChild(name, type = UNKNOWN, opts = {}) {\n    return new PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);\n  }\n  /**\n   * @internal\n   */\n  getRootString(path) {\n    return path_1.win32.parse(path).root;\n  }\n  /**\n   * @internal\n   */\n  getRoot(rootPath) {\n    rootPath = uncToDrive(rootPath.toUpperCase());\n    if (rootPath === this.root.name) {\n      return this.root;\n    }\n    // ok, not that one, check if it matches another we know about\n    for (const [compare, root] of Object.entries(this.roots)) {\n      if (this.sameRoot(rootPath, compare)) {\n        return this.roots[rootPath] = root;\n      }\n    }\n    // otherwise, have to create a new one.\n    return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;\n  }\n  /**\n   * @internal\n   */\n  sameRoot(rootPath, compare = this.root.name) {\n    // windows can (rarely) have case-sensitive filesystem, but\n    // UNC and drive letters are always case-insensitive, and canonically\n    // represented uppercase.\n    rootPath = rootPath.toUpperCase().replace(/\\//g, '\\\\').replace(uncDriveRegexp, '$1\\\\');\n    return rootPath === compare;\n  }\n}\nexports.PathWin32 = PathWin32;\n/**\n * Path class used on all posix systems.\n *\n * Uses `'/'` as the path separator.\n */\nclass PathPosix extends PathBase {\n  /**\n   * separator for parsing path strings\n   */\n  splitSep = '/';\n  /**\n   * separator for generating path strings\n   */\n  sep = '/';\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {\n    super(name, type, root, roots, nocase, children, opts);\n  }\n  /**\n   * @internal\n   */\n  getRootString(path) {\n    return path.startsWith('/') ? '/' : '';\n  }\n  /**\n   * @internal\n   */\n  getRoot(_rootPath) {\n    return this.root;\n  }\n  /**\n   * @internal\n   */\n  newChild(name, type = UNKNOWN, opts = {}) {\n    return new PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);\n  }\n}\nexports.PathPosix = PathPosix;\n/**\n * The base class for all PathScurry classes, providing the interface for path\n * resolution and filesystem operations.\n *\n * Typically, you should *not* instantiate this class directly, but rather one\n * of the platform-specific classes, or the exported {@link PathScurry} which\n * defaults to the current platform.\n */\nclass PathScurryBase {\n  /**\n   * The root Path entry for the current working directory of this Scurry\n   */\n  root;\n  /**\n   * The string path for the root of this Scurry's current working directory\n   */\n  rootPath;\n  /**\n   * A collection of all roots encountered, referenced by rootPath\n   */\n  roots;\n  /**\n   * The Path entry corresponding to this PathScurry's current working directory.\n   */\n  cwd;\n  #resolveCache;\n  #resolvePosixCache;\n  #children;\n  /**\n   * Perform path comparisons case-insensitively.\n   *\n   * Defaults true on Darwin and Windows systems, false elsewhere.\n   */\n  nocase;\n  #fs;\n  /**\n   * This class should not be instantiated directly.\n   *\n   * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry\n   *\n   * @internal\n   */\n  constructor(cwd = process.cwd(), pathImpl, sep, {\n    nocase,\n    childrenCacheSize = 16 * 1024,\n    fs = defaultFS\n  } = {}) {\n    this.#fs = fsFromOption(fs);\n    if (cwd instanceof URL || cwd.startsWith('file://')) {\n      cwd = (0, url_1.fileURLToPath)(cwd);\n    }\n    // resolve and split root, and then add to the store.\n    // this is the only time we call path.resolve()\n    const cwdPath = pathImpl.resolve(cwd);\n    this.roots = Object.create(null);\n    this.rootPath = this.parseRootPath(cwdPath);\n    this.#resolveCache = new ResolveCache();\n    this.#resolvePosixCache = new ResolveCache();\n    this.#children = new ChildrenCache(childrenCacheSize);\n    const split = cwdPath.substring(this.rootPath.length).split(sep);\n    // resolve('/') leaves '', splits to [''], we don't want that.\n    if (split.length === 1 && !split[0]) {\n      split.pop();\n    }\n    /* c8 ignore start */\n    if (nocase === undefined) {\n      throw new TypeError('must provide nocase setting to PathScurryBase ctor');\n    }\n    /* c8 ignore stop */\n    this.nocase = nocase;\n    this.root = this.newRoot(this.#fs);\n    this.roots[this.rootPath] = this.root;\n    let prev = this.root;\n    let len = split.length - 1;\n    const joinSep = pathImpl.sep;\n    let abs = this.rootPath;\n    let sawFirst = false;\n    for (const part of split) {\n      const l = len--;\n      prev = prev.child(part, {\n        relative: new Array(l).fill('..').join(joinSep),\n        relativePosix: new Array(l).fill('..').join('/'),\n        fullpath: abs += (sawFirst ? '' : joinSep) + part\n      });\n      sawFirst = true;\n    }\n    this.cwd = prev;\n  }\n  /**\n   * Get the depth of a provided path, string, or the cwd\n   */\n  depth(path = this.cwd) {\n    if (typeof path === 'string') {\n      path = this.cwd.resolve(path);\n    }\n    return path.depth();\n  }\n  /**\n   * Return the cache of child entries.  Exposed so subclasses can create\n   * child Path objects in a platform-specific way.\n   *\n   * @internal\n   */\n  childrenCache() {\n    return this.#children;\n  }\n  /**\n   * Resolve one or more path strings to a resolved string\n   *\n   * Same interface as require('path').resolve.\n   *\n   * Much faster than path.resolve() when called multiple times for the same\n   * path, because the resolved Path objects are cached.  Much slower\n   * otherwise.\n   */\n  resolve(...paths) {\n    // first figure out the minimum number of paths we have to test\n    // we always start at cwd, but any absolutes will bump the start\n    let r = '';\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const p = paths[i];\n      if (!p || p === '.') continue;\n      r = r ? `${p}/${r}` : p;\n      if (this.isAbsolute(p)) {\n        break;\n      }\n    }\n    const cached = this.#resolveCache.get(r);\n    if (cached !== undefined) {\n      return cached;\n    }\n    const result = this.cwd.resolve(r).fullpath();\n    this.#resolveCache.set(r, result);\n    return result;\n  }\n  /**\n   * Resolve one or more path strings to a resolved string, returning\n   * the posix path.  Identical to .resolve() on posix systems, but on\n   * windows will return a forward-slash separated UNC path.\n   *\n   * Same interface as require('path').resolve.\n   *\n   * Much faster than path.resolve() when called multiple times for the same\n   * path, because the resolved Path objects are cached.  Much slower\n   * otherwise.\n   */\n  resolvePosix(...paths) {\n    // first figure out the minimum number of paths we have to test\n    // we always start at cwd, but any absolutes will bump the start\n    let r = '';\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const p = paths[i];\n      if (!p || p === '.') continue;\n      r = r ? `${p}/${r}` : p;\n      if (this.isAbsolute(p)) {\n        break;\n      }\n    }\n    const cached = this.#resolvePosixCache.get(r);\n    if (cached !== undefined) {\n      return cached;\n    }\n    const result = this.cwd.resolve(r).fullpathPosix();\n    this.#resolvePosixCache.set(r, result);\n    return result;\n  }\n  /**\n   * find the relative path from the cwd to the supplied path string or entry\n   */\n  relative(entry = this.cwd) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    }\n    return entry.relative();\n  }\n  /**\n   * find the relative path from the cwd to the supplied path string or\n   * entry, using / as the path delimiter, even on Windows.\n   */\n  relativePosix(entry = this.cwd) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    }\n    return entry.relativePosix();\n  }\n  /**\n   * Return the basename for the provided string or Path object\n   */\n  basename(entry = this.cwd) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    }\n    return entry.name;\n  }\n  /**\n   * Return the dirname for the provided string or Path object\n   */\n  dirname(entry = this.cwd) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    }\n    return (entry.parent || entry).fullpath();\n  }\n  readdir(entry = this.cwd, opts = {\n    withFileTypes: true\n  }) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      if (typeof entry === 'string') {\n        entry = _this5.cwd.resolve(entry);\n      } else if (!(entry instanceof PathBase)) {\n        opts = entry;\n        entry = _this5.cwd;\n      }\n      const {\n        withFileTypes\n      } = opts;\n      if (!entry.canReaddir()) {\n        return [];\n      } else {\n        const p = yield entry.readdir();\n        return withFileTypes ? p : p.map(e => e.name);\n      }\n    })();\n  }\n  readdirSync(entry = this.cwd, opts = {\n    withFileTypes: true\n  }) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry;\n      entry = this.cwd;\n    }\n    const {\n      withFileTypes = true\n    } = opts;\n    if (!entry.canReaddir()) {\n      return [];\n    } else if (withFileTypes) {\n      return entry.readdirSync();\n    } else {\n      return entry.readdirSync().map(e => e.name);\n    }\n  }\n  /**\n   * Call lstat() on the string or Path object, and update all known\n   * information that can be determined.\n   *\n   * Note that unlike `fs.lstat()`, the returned value does not contain some\n   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n   * information is required, you will need to call `fs.lstat` yourself.\n   *\n   * If the Path refers to a nonexistent file, or if the lstat call fails for\n   * any reason, `undefined` is returned.  Otherwise the updated Path object is\n   * returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  lstat(entry = this.cwd) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      if (typeof entry === 'string') {\n        entry = _this6.cwd.resolve(entry);\n      }\n      return entry.lstat();\n    })();\n  }\n  /**\n   * synchronous {@link PathScurryBase.lstat}\n   */\n  lstatSync(entry = this.cwd) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    }\n    return entry.lstatSync();\n  }\n  readlink(entry = this.cwd, {\n    withFileTypes\n  } = {\n    withFileTypes: false\n  }) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      if (typeof entry === 'string') {\n        entry = _this7.cwd.resolve(entry);\n      } else if (!(entry instanceof PathBase)) {\n        withFileTypes = entry.withFileTypes;\n        entry = _this7.cwd;\n      }\n      const e = yield entry.readlink();\n      return withFileTypes ? e : e?.fullpath();\n    })();\n  }\n  readlinkSync(entry = this.cwd, {\n    withFileTypes\n  } = {\n    withFileTypes: false\n  }) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes;\n      entry = this.cwd;\n    }\n    const e = entry.readlinkSync();\n    return withFileTypes ? e : e?.fullpath();\n  }\n  realpath(entry = this.cwd, {\n    withFileTypes\n  } = {\n    withFileTypes: false\n  }) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      if (typeof entry === 'string') {\n        entry = _this8.cwd.resolve(entry);\n      } else if (!(entry instanceof PathBase)) {\n        withFileTypes = entry.withFileTypes;\n        entry = _this8.cwd;\n      }\n      const e = yield entry.realpath();\n      return withFileTypes ? e : e?.fullpath();\n    })();\n  }\n  realpathSync(entry = this.cwd, {\n    withFileTypes\n  } = {\n    withFileTypes: false\n  }) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes;\n      entry = this.cwd;\n    }\n    const e = entry.realpathSync();\n    return withFileTypes ? e : e?.fullpath();\n  }\n  walk(entry = this.cwd, opts = {}) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      if (typeof entry === 'string') {\n        entry = _this9.cwd.resolve(entry);\n      } else if (!(entry instanceof PathBase)) {\n        opts = entry;\n        entry = _this9.cwd;\n      }\n      const {\n        withFileTypes = true,\n        follow = false,\n        filter,\n        walkFilter\n      } = opts;\n      const results = [];\n      if (!filter || filter(entry)) {\n        results.push(withFileTypes ? entry : entry.fullpath());\n      }\n      const dirs = new Set();\n      const walk = (dir, cb) => {\n        dirs.add(dir);\n        dir.readdirCB((er, entries) => {\n          /* c8 ignore start */\n          if (er) {\n            return cb(er);\n          }\n          /* c8 ignore stop */\n          let len = entries.length;\n          if (!len) return cb();\n          const next = () => {\n            if (--len === 0) {\n              cb();\n            }\n          };\n          for (const e of entries) {\n            if (!filter || filter(e)) {\n              results.push(withFileTypes ? e : e.fullpath());\n            }\n            if (follow && e.isSymbolicLink()) {\n              e.realpath().then(r => r?.isUnknown() ? r.lstat() : r).then(r => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());\n            } else {\n              if (e.shouldWalk(dirs, walkFilter)) {\n                walk(e, next);\n              } else {\n                next();\n              }\n            }\n          }\n        }, true); // zalgooooooo\n      };\n\n      const start = entry;\n      return new Promise((res, rej) => {\n        walk(start, er => {\n          /* c8 ignore start */\n          if (er) return rej(er);\n          /* c8 ignore stop */\n          res(results);\n        });\n      });\n    })();\n  }\n  walkSync(entry = this.cwd, opts = {}) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry;\n      entry = this.cwd;\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter\n    } = opts;\n    const results = [];\n    if (!filter || filter(entry)) {\n      results.push(withFileTypes ? entry : entry.fullpath());\n    }\n    const dirs = new Set([entry]);\n    for (const dir of dirs) {\n      const entries = dir.readdirSync();\n      for (const e of entries) {\n        if (!filter || filter(e)) {\n          results.push(withFileTypes ? e : e.fullpath());\n        }\n        let r = e;\n        if (e.isSymbolicLink()) {\n          if (!(follow && (r = e.realpathSync()))) continue;\n          if (r.isUnknown()) r.lstatSync();\n        }\n        if (r.shouldWalk(dirs, walkFilter)) {\n          dirs.add(r);\n        }\n      }\n    }\n    return results;\n  }\n  /**\n   * Support for `for await`\n   *\n   * Alias for {@link PathScurryBase.iterate}\n   *\n   * Note: As of Node 19, this is very slow, compared to other methods of\n   * walking.  Consider using {@link PathScurryBase.stream} if memory overhead\n   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.\n   */\n  [Symbol.asyncIterator]() {\n    return this.iterate();\n  }\n  iterate(entry = this.cwd, options = {}) {\n    // iterating async over the stream is significantly more performant,\n    // especially in the warm-cache scenario, because it buffers up directory\n    // entries in the background instead of waiting for a yield for each one.\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      options = entry;\n      entry = this.cwd;\n    }\n    return this.stream(entry, options)[Symbol.asyncIterator]();\n  }\n  /**\n   * Iterating over a PathScurry performs a synchronous walk.\n   *\n   * Alias for {@link PathScurryBase.iterateSync}\n   */\n  [Symbol.iterator]() {\n    return this.iterateSync();\n  }\n  *iterateSync(entry = this.cwd, opts = {}) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry;\n      entry = this.cwd;\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter\n    } = opts;\n    if (!filter || filter(entry)) {\n      yield withFileTypes ? entry : entry.fullpath();\n    }\n    const dirs = new Set([entry]);\n    for (const dir of dirs) {\n      const entries = dir.readdirSync();\n      for (const e of entries) {\n        if (!filter || filter(e)) {\n          yield withFileTypes ? e : e.fullpath();\n        }\n        let r = e;\n        if (e.isSymbolicLink()) {\n          if (!(follow && (r = e.realpathSync()))) continue;\n          if (r.isUnknown()) r.lstatSync();\n        }\n        if (r.shouldWalk(dirs, walkFilter)) {\n          dirs.add(r);\n        }\n      }\n    }\n  }\n  stream(entry = this.cwd, opts = {}) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry;\n      entry = this.cwd;\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter\n    } = opts;\n    const results = new minipass_1.Minipass({\n      objectMode: true\n    });\n    if (!filter || filter(entry)) {\n      results.write(withFileTypes ? entry : entry.fullpath());\n    }\n    const dirs = new Set();\n    const queue = [entry];\n    let processing = 0;\n    const process = () => {\n      let paused = false;\n      while (!paused) {\n        const dir = queue.shift();\n        if (!dir) {\n          if (processing === 0) results.end();\n          return;\n        }\n        processing++;\n        dirs.add(dir);\n        const onReaddir = (er, entries, didRealpaths = false) => {\n          /* c8 ignore start */\n          if (er) return results.emit('error', er);\n          /* c8 ignore stop */\n          if (follow && !didRealpaths) {\n            const promises = [];\n            for (const e of entries) {\n              if (e.isSymbolicLink()) {\n                promises.push(e.realpath().then(r => r?.isUnknown() ? r.lstat() : r));\n              }\n            }\n            if (promises.length) {\n              Promise.all(promises).then(() => onReaddir(null, entries, true));\n              return;\n            }\n          }\n          for (const e of entries) {\n            if (e && (!filter || filter(e))) {\n              if (!results.write(withFileTypes ? e : e.fullpath())) {\n                paused = true;\n              }\n            }\n          }\n          processing--;\n          for (const e of entries) {\n            const r = e.realpathCached() || e;\n            if (r.shouldWalk(dirs, walkFilter)) {\n              queue.push(r);\n            }\n          }\n          if (paused && !results.flowing) {\n            results.once('drain', process);\n          } else if (!sync) {\n            process();\n          }\n        };\n        // zalgo containment\n        let sync = true;\n        dir.readdirCB(onReaddir, true);\n        sync = false;\n      }\n    };\n    process();\n    return results;\n  }\n  streamSync(entry = this.cwd, opts = {}) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry;\n      entry = this.cwd;\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter\n    } = opts;\n    const results = new minipass_1.Minipass({\n      objectMode: true\n    });\n    const dirs = new Set();\n    if (!filter || filter(entry)) {\n      results.write(withFileTypes ? entry : entry.fullpath());\n    }\n    const queue = [entry];\n    let processing = 0;\n    const process = () => {\n      let paused = false;\n      while (!paused) {\n        const dir = queue.shift();\n        if (!dir) {\n          if (processing === 0) results.end();\n          return;\n        }\n        processing++;\n        dirs.add(dir);\n        const entries = dir.readdirSync();\n        for (const e of entries) {\n          if (!filter || filter(e)) {\n            if (!results.write(withFileTypes ? e : e.fullpath())) {\n              paused = true;\n            }\n          }\n        }\n        processing--;\n        for (const e of entries) {\n          let r = e;\n          if (e.isSymbolicLink()) {\n            if (!(follow && (r = e.realpathSync()))) continue;\n            if (r.isUnknown()) r.lstatSync();\n          }\n          if (r.shouldWalk(dirs, walkFilter)) {\n            queue.push(r);\n          }\n        }\n      }\n      if (paused && !results.flowing) results.once('drain', process);\n    };\n    process();\n    return results;\n  }\n  chdir(path = this.cwd) {\n    const oldCwd = this.cwd;\n    this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path;\n    this.cwd[setAsCwd](oldCwd);\n  }\n}\nexports.PathScurryBase = PathScurryBase;\n/**\n * Windows implementation of {@link PathScurryBase}\n *\n * Defaults to case insensitve, uses `'\\\\'` to generate path strings.  Uses\n * {@link PathWin32} for Path objects.\n */\nclass PathScurryWin32 extends PathScurryBase {\n  /**\n   * separator for generating path strings\n   */\n  sep = '\\\\';\n  constructor(cwd = process.cwd(), opts = {}) {\n    const {\n      nocase = true\n    } = opts;\n    super(cwd, path_1.win32, '\\\\', {\n      ...opts,\n      nocase\n    });\n    this.nocase = nocase;\n    for (let p = this.cwd; p; p = p.parent) {\n      p.nocase = this.nocase;\n    }\n  }\n  /**\n   * @internal\n   */\n  parseRootPath(dir) {\n    // if the path starts with a single separator, it's not a UNC, and we'll\n    // just get separator as the root, and driveFromUNC will return \\\n    // In that case, mount \\ on the root from the cwd.\n    return path_1.win32.parse(dir).root.toUpperCase();\n  }\n  /**\n   * @internal\n   */\n  newRoot(fs) {\n    return new PathWin32(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), {\n      fs\n    });\n  }\n  /**\n   * Return true if the provided path string is an absolute path\n   */\n  isAbsolute(p) {\n    return p.startsWith('/') || p.startsWith('\\\\') || /^[a-z]:(\\/|\\\\)/i.test(p);\n  }\n}\nexports.PathScurryWin32 = PathScurryWin32;\n/**\n * {@link PathScurryBase} implementation for all posix systems other than Darwin.\n *\n * Defaults to case-sensitive matching, uses `'/'` to generate path strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nclass PathScurryPosix extends PathScurryBase {\n  /**\n   * separator for generating path strings\n   */\n  sep = '/';\n  constructor(cwd = process.cwd(), opts = {}) {\n    const {\n      nocase = false\n    } = opts;\n    super(cwd, path_1.posix, '/', {\n      ...opts,\n      nocase\n    });\n    this.nocase = nocase;\n  }\n  /**\n   * @internal\n   */\n  parseRootPath(_dir) {\n    return '/';\n  }\n  /**\n   * @internal\n   */\n  newRoot(fs) {\n    return new PathPosix(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), {\n      fs\n    });\n  }\n  /**\n   * Return true if the provided path string is an absolute path\n   */\n  isAbsolute(p) {\n    return p.startsWith('/');\n  }\n}\nexports.PathScurryPosix = PathScurryPosix;\n/**\n * {@link PathScurryBase} implementation for Darwin (macOS) systems.\n *\n * Defaults to case-insensitive matching, uses `'/'` for generating path\n * strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nclass PathScurryDarwin extends PathScurryPosix {\n  constructor(cwd = process.cwd(), opts = {}) {\n    const {\n      nocase = true\n    } = opts;\n    super(cwd, {\n      ...opts,\n      nocase\n    });\n  }\n}\nexports.PathScurryDarwin = PathScurryDarwin;\n/**\n * Default {@link PathBase} implementation for the current platform.\n *\n * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.\n */\nexports.Path = process.platform === 'win32' ? PathWin32 : PathPosix;\n/**\n * Default {@link PathScurryBase} implementation for the current platform.\n *\n * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on\n * Darwin (macOS) systems, {@link PathScurryPosix} on all others.\n */\nexports.PathScurry = process.platform === 'win32' ? PathScurryWin32 : process.platform === 'darwin' ? PathScurryDarwin : PathScurryPosix;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","exports","PathScurry","Path","PathScurryDarwin","PathScurryPosix","PathScurryWin32","PathScurryBase","PathPosix","PathWin32","PathBase","ChildrenCache","ResolveCache","lru_cache_1","require","path_1","url_1","actualFS","fs_1","realpathSync","native","promises_1","minipass_1","defaultFS","lstatSync","readdir","readdirSync","readlinkSync","promises","lstat","readlink","realpath","fsFromOption","fsOption","uncDriveRegexp","uncToDrive","rootPath","replace","eitherSep","UNKNOWN","IFIFO","IFCHR","IFDIR","IFBLK","IFREG","IFLNK","IFSOCK","IFMT","IFMT_UNKNOWN","READDIR_CALLED","LSTAT_CALLED","ENOTDIR","ENOENT","ENOREADLINK","ENOREALPATH","ENOCHILD","TYPEMASK","entToType","s","isFile","isDirectory","isSymbolicLink","isCharacterDevice","isBlockDevice","isSocket","isFIFO","normalizeCache","Map","normalize","c","n","set","normalizeNocaseCache","normalizeNocase","toLowerCase","LRUCache","constructor","max","maxSize","sizeCalculation","a","length","setAsCwd","Symbol","name","root","roots","parent","nocase","fs","dev","mode","nlink","uid","gid","rdev","blksize","ino","size","blocks","atimeMs","mtimeMs","ctimeMs","birthtimeMs","atime","mtime","ctime","birthtime","matchName","depth","fullpath","fullpathPosix","relative","relativePosix","type","children","linkTarget","path","opts","childrenCache","resolve","getRootString","dir","substring","dirParts","split","splitSep","getRoot","resolveParts","p","part","child","cached","assign","provisional","pathPart","sep","pchild","newChild","canReaddir","push","pv","fp","test","pfpp","fpp","isUnknown","isType","getType","lstatCached","readlinkCached","realpathCached","readdirCached","slice","canReadlink","ifmt","calledReaddir","isENOENT","isNamed","target","read","er","readlinkFail","code","readdirSuccess","markENOENT","markChildrenENOENT","markENOREALPATH","markENOTDIR","t","readdirFail","lstatFail","ter","readdirAddChild","e","readdirMaybePromoteChild","readdirAddNewChild","unshift","readdirPromoteChild","index","pop","splice","applyStat","st","onReaddirCB","readdirCBInFlight","callOnReaddirCB","cbs","forEach","cb","readdirCB","allowZalgo","queueMicrotask","withFileTypes","entries","asyncReaddirInFlight","Promise","res","shouldWalk","dirs","walkFilter","has","rp","_","oldCwd","changed","Set","add","join","win32","parse","toUpperCase","compare","sameRoot","startsWith","_rootPath","cwd","resolveCache","resolvePosixCache","process","pathImpl","childrenCacheSize","URL","fileURLToPath","cwdPath","parseRootPath","TypeError","newRoot","prev","len","joinSep","abs","sawFirst","l","Array","fill","paths","r","i","isAbsolute","resolvePosix","entry","basename","dirname","map","walk","follow","filter","results","next","then","start","rej","walkSync","asyncIterator","iterate","options","stream","iterator","iterateSync","Minipass","objectMode","write","queue","processing","paused","shift","end","onReaddir","didRealpaths","emit","all","flowing","once","sync","streamSync","chdir","posix","_dir","platform"],"sources":["I:/Angular/angular-blog/node_modules/path-scurry/dist/cjs/index.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PathScurry = exports.Path = exports.PathScurryDarwin = exports.PathScurryPosix = exports.PathScurryWin32 = exports.PathScurryBase = exports.PathPosix = exports.PathWin32 = exports.PathBase = exports.ChildrenCache = exports.ResolveCache = void 0;\nconst lru_cache_1 = require(\"lru-cache\");\nconst path_1 = require(\"path\");\nconst url_1 = require(\"url\");\nconst actualFS = __importStar(require(\"fs\"));\nconst fs_1 = require(\"fs\");\nconst realpathSync = fs_1.realpathSync.native;\n// TODO: test perf of fs/promises realpath vs realpathCB,\n// since the promises one uses realpath.native\nconst promises_1 = require(\"fs/promises\");\nconst minipass_1 = require(\"minipass\");\nconst defaultFS = {\n    lstatSync: fs_1.lstatSync,\n    readdir: fs_1.readdir,\n    readdirSync: fs_1.readdirSync,\n    readlinkSync: fs_1.readlinkSync,\n    realpathSync,\n    promises: {\n        lstat: promises_1.lstat,\n        readdir: promises_1.readdir,\n        readlink: promises_1.readlink,\n        realpath: promises_1.realpath,\n    },\n};\n// if they just gave us require('fs') then use our default\nconst fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS\n    ? defaultFS\n    : {\n        ...defaultFS,\n        ...fsOption,\n        promises: {\n            ...defaultFS.promises,\n            ...(fsOption.promises || {}),\n        },\n    };\n// turn something like //?/c:/ into c:\\\nconst uncDriveRegexp = /^\\\\\\\\\\?\\\\([a-z]:)\\\\?$/i;\nconst uncToDrive = (rootPath) => rootPath.replace(/\\//g, '\\\\').replace(uncDriveRegexp, '$1\\\\');\n// windows paths are separated by either / or \\\nconst eitherSep = /[\\\\\\/]/;\nconst UNKNOWN = 0; // may not even exist, for all we know\nconst IFIFO = 0b0001;\nconst IFCHR = 0b0010;\nconst IFDIR = 0b0100;\nconst IFBLK = 0b0110;\nconst IFREG = 0b1000;\nconst IFLNK = 0b1010;\nconst IFSOCK = 0b1100;\nconst IFMT = 0b1111;\n// mask to unset low 4 bits\nconst IFMT_UNKNOWN = ~IFMT;\n// set after successfully calling readdir() and getting entries.\nconst READDIR_CALLED = 16;\n// set after a successful lstat()\nconst LSTAT_CALLED = 32;\n// set if an entry (or one of its parents) is definitely not a dir\nconst ENOTDIR = 64;\n// set if an entry (or one of its parents) does not exist\n// (can also be set on lstat errors like EACCES or ENAMETOOLONG)\nconst ENOENT = 128;\n// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK\n// set if we fail to readlink\nconst ENOREADLINK = 256;\n// set if we know realpath() will fail\nconst ENOREALPATH = 512;\nconst ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;\nconst TYPEMASK = 1023;\nconst entToType = (s) => s.isFile()\n    ? IFREG\n    : s.isDirectory()\n        ? IFDIR\n        : s.isSymbolicLink()\n            ? IFLNK\n            : s.isCharacterDevice()\n                ? IFCHR\n                : s.isBlockDevice()\n                    ? IFBLK\n                    : s.isSocket()\n                        ? IFSOCK\n                        : s.isFIFO()\n                            ? IFIFO\n                            : UNKNOWN;\n// normalize unicode path names\nconst normalizeCache = new Map();\nconst normalize = (s) => {\n    const c = normalizeCache.get(s);\n    if (c)\n        return c;\n    const n = s.normalize('NFKD');\n    normalizeCache.set(s, n);\n    return n;\n};\nconst normalizeNocaseCache = new Map();\nconst normalizeNocase = (s) => {\n    const c = normalizeNocaseCache.get(s);\n    if (c)\n        return c;\n    const n = normalize(s.toLowerCase());\n    normalizeNocaseCache.set(s, n);\n    return n;\n};\n/**\n * An LRUCache for storing resolved path strings or Path objects.\n * @internal\n */\nclass ResolveCache extends lru_cache_1.LRUCache {\n    constructor() {\n        super({ max: 256 });\n    }\n}\nexports.ResolveCache = ResolveCache;\n// In order to prevent blowing out the js heap by allocating hundreds of\n// thousands of Path entries when walking extremely large trees, the \"children\"\n// in this tree are represented by storing an array of Path entries in an\n// LRUCache, indexed by the parent.  At any time, Path.children() may return an\n// empty array, indicating that it doesn't know about any of its children, and\n// thus has to rebuild that cache.  This is fine, it just means that we don't\n// benefit as much from having the cached entries, but huge directory walks\n// don't blow out the stack, and smaller ones are still as fast as possible.\n//\n//It does impose some complexity when building up the readdir data, because we\n//need to pass a reference to the children array that we started with.\n/**\n * an LRUCache for storing child entries.\n * @internal\n */\nclass ChildrenCache extends lru_cache_1.LRUCache {\n    constructor(maxSize = 16 * 1024) {\n        super({\n            maxSize,\n            // parent + children\n            sizeCalculation: a => a.length + 1,\n        });\n    }\n}\nexports.ChildrenCache = ChildrenCache;\nconst setAsCwd = Symbol('PathScurry setAsCwd');\n/**\n * Path objects are sort of like a super-powered\n * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}\n *\n * Each one represents a single filesystem entry on disk, which may or may not\n * exist. It includes methods for reading various types of information via\n * lstat, readlink, and readdir, and caches all information to the greatest\n * degree possible.\n *\n * Note that fs operations that would normally throw will instead return an\n * \"empty\" value. This is in order to prevent excessive overhead from error\n * stack traces.\n */\nclass PathBase {\n    /**\n     * the basename of this path\n     *\n     * **Important**: *always* test the path name against any test string\n     * usingthe {@link isNamed} method, and not by directly comparing this\n     * string. Otherwise, unicode path strings that the system sees as identical\n     * will not be properly treated as the same path, leading to incorrect\n     * behavior and possible security issues.\n     */\n    name;\n    /**\n     * the Path entry corresponding to the path root.\n     *\n     * @internal\n     */\n    root;\n    /**\n     * All roots found within the current PathScurry family\n     *\n     * @internal\n     */\n    roots;\n    /**\n     * a reference to the parent path, or undefined in the case of root entries\n     *\n     * @internal\n     */\n    parent;\n    /**\n     * boolean indicating whether paths are compared case-insensitively\n     * @internal\n     */\n    nocase;\n    // potential default fs override\n    #fs;\n    // Stats fields\n    #dev;\n    get dev() {\n        return this.#dev;\n    }\n    #mode;\n    get mode() {\n        return this.#mode;\n    }\n    #nlink;\n    get nlink() {\n        return this.#nlink;\n    }\n    #uid;\n    get uid() {\n        return this.#uid;\n    }\n    #gid;\n    get gid() {\n        return this.#gid;\n    }\n    #rdev;\n    get rdev() {\n        return this.#rdev;\n    }\n    #blksize;\n    get blksize() {\n        return this.#blksize;\n    }\n    #ino;\n    get ino() {\n        return this.#ino;\n    }\n    #size;\n    get size() {\n        return this.#size;\n    }\n    #blocks;\n    get blocks() {\n        return this.#blocks;\n    }\n    #atimeMs;\n    get atimeMs() {\n        return this.#atimeMs;\n    }\n    #mtimeMs;\n    get mtimeMs() {\n        return this.#mtimeMs;\n    }\n    #ctimeMs;\n    get ctimeMs() {\n        return this.#ctimeMs;\n    }\n    #birthtimeMs;\n    get birthtimeMs() {\n        return this.#birthtimeMs;\n    }\n    #atime;\n    get atime() {\n        return this.#atime;\n    }\n    #mtime;\n    get mtime() {\n        return this.#mtime;\n    }\n    #ctime;\n    get ctime() {\n        return this.#ctime;\n    }\n    #birthtime;\n    get birthtime() {\n        return this.#birthtime;\n    }\n    #matchName;\n    #depth;\n    #fullpath;\n    #fullpathPosix;\n    #relative;\n    #relativePosix;\n    #type;\n    #children;\n    #linkTarget;\n    #realpath;\n    /**\n     * This property is for compatibility with the Dirent class as of\n     * Node v20, where Dirent['path'] refers to the path of the directory\n     * that was passed to readdir.  So, somewhat counterintuitively, this\n     * property refers to the *parent* path, not the path object itself.\n     * For root entries, it's the path to the entry itself.\n     */\n    get path() {\n        return (this.parent || this).fullpath();\n    }\n    /**\n     * Do not create new Path objects directly.  They should always be accessed\n     * via the PathScurry class or other methods on the Path class.\n     *\n     * @internal\n     */\n    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {\n        this.name = name;\n        this.#matchName = nocase ? normalizeNocase(name) : normalize(name);\n        this.#type = type & TYPEMASK;\n        this.nocase = nocase;\n        this.roots = roots;\n        this.root = root || this;\n        this.#children = children;\n        this.#fullpath = opts.fullpath;\n        this.#relative = opts.relative;\n        this.#relativePosix = opts.relativePosix;\n        this.parent = opts.parent;\n        if (this.parent) {\n            this.#fs = this.parent.#fs;\n        }\n        else {\n            this.#fs = fsFromOption(opts.fs);\n        }\n    }\n    /**\n     * Returns the depth of the Path object from its root.\n     *\n     * For example, a path at `/foo/bar` would have a depth of 2.\n     */\n    depth() {\n        if (this.#depth !== undefined)\n            return this.#depth;\n        if (!this.parent)\n            return (this.#depth = 0);\n        return (this.#depth = this.parent.depth() + 1);\n    }\n    /**\n     * @internal\n     */\n    childrenCache() {\n        return this.#children;\n    }\n    /**\n     * Get the Path object referenced by the string path, resolved from this Path\n     */\n    resolve(path) {\n        if (!path) {\n            return this;\n        }\n        const rootPath = this.getRootString(path);\n        const dir = path.substring(rootPath.length);\n        const dirParts = dir.split(this.splitSep);\n        const result = rootPath\n            ? this.getRoot(rootPath).#resolveParts(dirParts)\n            : this.#resolveParts(dirParts);\n        return result;\n    }\n    #resolveParts(dirParts) {\n        let p = this;\n        for (const part of dirParts) {\n            p = p.child(part);\n        }\n        return p;\n    }\n    /**\n     * Returns the cached children Path objects, if still available.  If they\n     * have fallen out of the cache, then returns an empty array, and resets the\n     * READDIR_CALLED bit, so that future calls to readdir() will require an fs\n     * lookup.\n     *\n     * @internal\n     */\n    children() {\n        const cached = this.#children.get(this);\n        if (cached) {\n            return cached;\n        }\n        const children = Object.assign([], { provisional: 0 });\n        this.#children.set(this, children);\n        this.#type &= ~READDIR_CALLED;\n        return children;\n    }\n    /**\n     * Resolves a path portion and returns or creates the child Path.\n     *\n     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is\n     * `'..'`.\n     *\n     * This should not be called directly.  If `pathPart` contains any path\n     * separators, it will lead to unsafe undefined behavior.\n     *\n     * Use `Path.resolve()` instead.\n     *\n     * @internal\n     */\n    child(pathPart, opts) {\n        if (pathPart === '' || pathPart === '.') {\n            return this;\n        }\n        if (pathPart === '..') {\n            return this.parent || this;\n        }\n        // find the child\n        const children = this.children();\n        const name = this.nocase\n            ? normalizeNocase(pathPart)\n            : normalize(pathPart);\n        for (const p of children) {\n            if (p.#matchName === name) {\n                return p;\n            }\n        }\n        // didn't find it, create provisional child, since it might not\n        // actually exist.  If we know the parent isn't a dir, then\n        // in fact it CAN'T exist.\n        const s = this.parent ? this.sep : '';\n        const fullpath = this.#fullpath\n            ? this.#fullpath + s + pathPart\n            : undefined;\n        const pchild = this.newChild(pathPart, UNKNOWN, {\n            ...opts,\n            parent: this,\n            fullpath,\n        });\n        if (!this.canReaddir()) {\n            pchild.#type |= ENOENT;\n        }\n        // don't have to update provisional, because if we have real children,\n        // then provisional is set to children.length, otherwise a lower number\n        children.push(pchild);\n        return pchild;\n    }\n    /**\n     * The relative path from the cwd. If it does not share an ancestor with\n     * the cwd, then this ends up being equivalent to the fullpath()\n     */\n    relative() {\n        if (this.#relative !== undefined) {\n            return this.#relative;\n        }\n        const name = this.name;\n        const p = this.parent;\n        if (!p) {\n            return (this.#relative = this.name);\n        }\n        const pv = p.relative();\n        return pv + (!pv || !p.parent ? '' : this.sep) + name;\n    }\n    /**\n     * The relative path from the cwd, using / as the path separator.\n     * If it does not share an ancestor with\n     * the cwd, then this ends up being equivalent to the fullpathPosix()\n     * On posix systems, this is identical to relative().\n     */\n    relativePosix() {\n        if (this.sep === '/')\n            return this.relative();\n        if (this.#relativePosix !== undefined)\n            return this.#relativePosix;\n        const name = this.name;\n        const p = this.parent;\n        if (!p) {\n            return (this.#relativePosix = this.fullpathPosix());\n        }\n        const pv = p.relativePosix();\n        return pv + (!pv || !p.parent ? '' : '/') + name;\n    }\n    /**\n     * The fully resolved path string for this Path entry\n     */\n    fullpath() {\n        if (this.#fullpath !== undefined) {\n            return this.#fullpath;\n        }\n        const name = this.name;\n        const p = this.parent;\n        if (!p) {\n            return (this.#fullpath = this.name);\n        }\n        const pv = p.fullpath();\n        const fp = pv + (!p.parent ? '' : this.sep) + name;\n        return (this.#fullpath = fp);\n    }\n    /**\n     * On platforms other than windows, this is identical to fullpath.\n     *\n     * On windows, this is overridden to return the forward-slash form of the\n     * full UNC path.\n     */\n    fullpathPosix() {\n        if (this.#fullpathPosix !== undefined)\n            return this.#fullpathPosix;\n        if (this.sep === '/')\n            return (this.#fullpathPosix = this.fullpath());\n        if (!this.parent) {\n            const p = this.fullpath().replace(/\\\\/g, '/');\n            if (/^[a-z]:\\//i.test(p)) {\n                return (this.#fullpathPosix = `//?/${p}`);\n            }\n            else {\n                return (this.#fullpathPosix = p);\n            }\n        }\n        const p = this.parent;\n        const pfpp = p.fullpathPosix();\n        const fpp = pfpp + (!pfpp || !p.parent ? '' : '/') + this.name;\n        return (this.#fullpathPosix = fpp);\n    }\n    /**\n     * Is the Path of an unknown type?\n     *\n     * Note that we might know *something* about it if there has been a previous\n     * filesystem operation, for example that it does not exist, or is not a\n     * link, or whether it has child entries.\n     */\n    isUnknown() {\n        return (this.#type & IFMT) === UNKNOWN;\n    }\n    isType(type) {\n        return this[`is${type}`]();\n    }\n    getType() {\n        return this.isUnknown()\n            ? 'Unknown'\n            : this.isDirectory()\n                ? 'Directory'\n                : this.isFile()\n                    ? 'File'\n                    : this.isSymbolicLink()\n                        ? 'SymbolicLink'\n                        : this.isFIFO()\n                            ? 'FIFO'\n                            : this.isCharacterDevice()\n                                ? 'CharacterDevice'\n                                : this.isBlockDevice()\n                                    ? 'BlockDevice'\n                                    : /* c8 ignore start */ this.isSocket()\n                                        ? 'Socket'\n                                        : 'Unknown';\n        /* c8 ignore stop */\n    }\n    /**\n     * Is the Path a regular file?\n     */\n    isFile() {\n        return (this.#type & IFMT) === IFREG;\n    }\n    /**\n     * Is the Path a directory?\n     */\n    isDirectory() {\n        return (this.#type & IFMT) === IFDIR;\n    }\n    /**\n     * Is the path a character device?\n     */\n    isCharacterDevice() {\n        return (this.#type & IFMT) === IFCHR;\n    }\n    /**\n     * Is the path a block device?\n     */\n    isBlockDevice() {\n        return (this.#type & IFMT) === IFBLK;\n    }\n    /**\n     * Is the path a FIFO pipe?\n     */\n    isFIFO() {\n        return (this.#type & IFMT) === IFIFO;\n    }\n    /**\n     * Is the path a socket?\n     */\n    isSocket() {\n        return (this.#type & IFMT) === IFSOCK;\n    }\n    /**\n     * Is the path a symbolic link?\n     */\n    isSymbolicLink() {\n        return (this.#type & IFLNK) === IFLNK;\n    }\n    /**\n     * Return the entry if it has been subject of a successful lstat, or\n     * undefined otherwise.\n     *\n     * Does not read the filesystem, so an undefined result *could* simply\n     * mean that we haven't called lstat on it.\n     */\n    lstatCached() {\n        return this.#type & LSTAT_CALLED ? this : undefined;\n    }\n    /**\n     * Return the cached link target if the entry has been the subject of a\n     * successful readlink, or undefined otherwise.\n     *\n     * Does not read the filesystem, so an undefined result *could* just mean we\n     * don't have any cached data. Only use it if you are very sure that a\n     * readlink() has been called at some point.\n     */\n    readlinkCached() {\n        return this.#linkTarget;\n    }\n    /**\n     * Returns the cached realpath target if the entry has been the subject\n     * of a successful realpath, or undefined otherwise.\n     *\n     * Does not read the filesystem, so an undefined result *could* just mean we\n     * don't have any cached data. Only use it if you are very sure that a\n     * realpath() has been called at some point.\n     */\n    realpathCached() {\n        return this.#realpath;\n    }\n    /**\n     * Returns the cached child Path entries array if the entry has been the\n     * subject of a successful readdir(), or [] otherwise.\n     *\n     * Does not read the filesystem, so an empty array *could* just mean we\n     * don't have any cached data. Only use it if you are very sure that a\n     * readdir() has been called recently enough to still be valid.\n     */\n    readdirCached() {\n        const children = this.children();\n        return children.slice(0, children.provisional);\n    }\n    /**\n     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have\n     * any indication that readlink will definitely fail.\n     *\n     * Returns false if the path is known to not be a symlink, if a previous\n     * readlink failed, or if the entry does not exist.\n     */\n    canReadlink() {\n        if (this.#linkTarget)\n            return true;\n        if (!this.parent)\n            return false;\n        // cases where it cannot possibly succeed\n        const ifmt = this.#type & IFMT;\n        return !((ifmt !== UNKNOWN && ifmt !== IFLNK) ||\n            this.#type & ENOREADLINK ||\n            this.#type & ENOENT);\n    }\n    /**\n     * Return true if readdir has previously been successfully called on this\n     * path, indicating that cachedReaddir() is likely valid.\n     */\n    calledReaddir() {\n        return !!(this.#type & READDIR_CALLED);\n    }\n    /**\n     * Returns true if the path is known to not exist. That is, a previous lstat\n     * or readdir failed to verify its existence when that would have been\n     * expected, or a parent entry was marked either enoent or enotdir.\n     */\n    isENOENT() {\n        return !!(this.#type & ENOENT);\n    }\n    /**\n     * Return true if the path is a match for the given path name.  This handles\n     * case sensitivity and unicode normalization.\n     *\n     * Note: even on case-sensitive systems, it is **not** safe to test the\n     * equality of the `.name` property to determine whether a given pathname\n     * matches, due to unicode normalization mismatches.\n     *\n     * Always use this method instead of testing the `path.name` property\n     * directly.\n     */\n    isNamed(n) {\n        return !this.nocase\n            ? this.#matchName === normalize(n)\n            : this.#matchName === normalizeNocase(n);\n    }\n    /**\n     * Return the Path object corresponding to the target of a symbolic link.\n     *\n     * If the Path is not a symbolic link, or if the readlink call fails for any\n     * reason, `undefined` is returned.\n     *\n     * Result is cached, and thus may be outdated if the filesystem is mutated.\n     */\n    async readlink() {\n        const target = this.#linkTarget;\n        if (target) {\n            return target;\n        }\n        if (!this.canReadlink()) {\n            return undefined;\n        }\n        /* c8 ignore start */\n        // already covered by the canReadlink test, here for ts grumples\n        if (!this.parent) {\n            return undefined;\n        }\n        /* c8 ignore stop */\n        try {\n            const read = await this.#fs.promises.readlink(this.fullpath());\n            const linkTarget = this.parent.resolve(read);\n            if (linkTarget) {\n                return (this.#linkTarget = linkTarget);\n            }\n        }\n        catch (er) {\n            this.#readlinkFail(er.code);\n            return undefined;\n        }\n    }\n    /**\n     * Synchronous {@link PathBase.readlink}\n     */\n    readlinkSync() {\n        const target = this.#linkTarget;\n        if (target) {\n            return target;\n        }\n        if (!this.canReadlink()) {\n            return undefined;\n        }\n        /* c8 ignore start */\n        // already covered by the canReadlink test, here for ts grumples\n        if (!this.parent) {\n            return undefined;\n        }\n        /* c8 ignore stop */\n        try {\n            const read = this.#fs.readlinkSync(this.fullpath());\n            const linkTarget = this.parent.resolve(read);\n            if (linkTarget) {\n                return (this.#linkTarget = linkTarget);\n            }\n        }\n        catch (er) {\n            this.#readlinkFail(er.code);\n            return undefined;\n        }\n    }\n    #readdirSuccess(children) {\n        // succeeded, mark readdir called bit\n        this.#type |= READDIR_CALLED;\n        // mark all remaining provisional children as ENOENT\n        for (let p = children.provisional; p < children.length; p++) {\n            children[p].#markENOENT();\n        }\n    }\n    #markENOENT() {\n        // mark as UNKNOWN and ENOENT\n        if (this.#type & ENOENT)\n            return;\n        this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;\n        this.#markChildrenENOENT();\n    }\n    #markChildrenENOENT() {\n        // all children are provisional and do not exist\n        const children = this.children();\n        children.provisional = 0;\n        for (const p of children) {\n            p.#markENOENT();\n        }\n    }\n    #markENOREALPATH() {\n        this.#type |= ENOREALPATH;\n        this.#markENOTDIR();\n    }\n    // save the information when we know the entry is not a dir\n    #markENOTDIR() {\n        // entry is not a directory, so any children can't exist.\n        // this *should* be impossible, since any children created\n        // after it's been marked ENOTDIR should be marked ENOENT,\n        // so it won't even get to this point.\n        /* c8 ignore start */\n        if (this.#type & ENOTDIR)\n            return;\n        /* c8 ignore stop */\n        let t = this.#type;\n        // this could happen if we stat a dir, then delete it,\n        // then try to read it or one of its children.\n        if ((t & IFMT) === IFDIR)\n            t &= IFMT_UNKNOWN;\n        this.#type = t | ENOTDIR;\n        this.#markChildrenENOENT();\n    }\n    #readdirFail(code = '') {\n        // markENOTDIR and markENOENT also set provisional=0\n        if (code === 'ENOTDIR' || code === 'EPERM') {\n            this.#markENOTDIR();\n        }\n        else if (code === 'ENOENT') {\n            this.#markENOENT();\n        }\n        else {\n            this.children().provisional = 0;\n        }\n    }\n    #lstatFail(code = '') {\n        // Windows just raises ENOENT in this case, disable for win CI\n        /* c8 ignore start */\n        if (code === 'ENOTDIR') {\n            // already know it has a parent by this point\n            const p = this.parent;\n            p.#markENOTDIR();\n        }\n        else if (code === 'ENOENT') {\n            /* c8 ignore stop */\n            this.#markENOENT();\n        }\n    }\n    #readlinkFail(code = '') {\n        let ter = this.#type;\n        ter |= ENOREADLINK;\n        if (code === 'ENOENT')\n            ter |= ENOENT;\n        // windows gets a weird error when you try to readlink a file\n        if (code === 'EINVAL' || code === 'UNKNOWN') {\n            // exists, but not a symlink, we don't know WHAT it is, so remove\n            // all IFMT bits.\n            ter &= IFMT_UNKNOWN;\n        }\n        this.#type = ter;\n        // windows just gets ENOENT in this case.  We do cover the case,\n        // just disabled because it's impossible on Windows CI\n        /* c8 ignore start */\n        if (code === 'ENOTDIR' && this.parent) {\n            this.parent.#markENOTDIR();\n        }\n        /* c8 ignore stop */\n    }\n    #readdirAddChild(e, c) {\n        return (this.#readdirMaybePromoteChild(e, c) ||\n            this.#readdirAddNewChild(e, c));\n    }\n    #readdirAddNewChild(e, c) {\n        // alloc new entry at head, so it's never provisional\n        const type = entToType(e);\n        const child = this.newChild(e.name, type, { parent: this });\n        const ifmt = child.#type & IFMT;\n        if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {\n            child.#type |= ENOTDIR;\n        }\n        c.unshift(child);\n        c.provisional++;\n        return child;\n    }\n    #readdirMaybePromoteChild(e, c) {\n        for (let p = c.provisional; p < c.length; p++) {\n            const pchild = c[p];\n            const name = this.nocase\n                ? normalizeNocase(e.name)\n                : normalize(e.name);\n            if (name !== pchild.#matchName) {\n                continue;\n            }\n            return this.#readdirPromoteChild(e, pchild, p, c);\n        }\n    }\n    #readdirPromoteChild(e, p, index, c) {\n        const v = p.name;\n        // retain any other flags, but set ifmt from dirent\n        p.#type = (p.#type & IFMT_UNKNOWN) | entToType(e);\n        // case sensitivity fixing when we learn the true name.\n        if (v !== e.name)\n            p.name = e.name;\n        // just advance provisional index (potentially off the list),\n        // otherwise we have to splice/pop it out and re-insert at head\n        if (index !== c.provisional) {\n            if (index === c.length - 1)\n                c.pop();\n            else\n                c.splice(index, 1);\n            c.unshift(p);\n        }\n        c.provisional++;\n        return p;\n    }\n    /**\n     * Call lstat() on this Path, and update all known information that can be\n     * determined.\n     *\n     * Note that unlike `fs.lstat()`, the returned value does not contain some\n     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n     * information is required, you will need to call `fs.lstat` yourself.\n     *\n     * If the Path refers to a nonexistent file, or if the lstat call fails for\n     * any reason, `undefined` is returned.  Otherwise the updated Path object is\n     * returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     */\n    async lstat() {\n        if ((this.#type & ENOENT) === 0) {\n            try {\n                this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));\n                return this;\n            }\n            catch (er) {\n                this.#lstatFail(er.code);\n            }\n        }\n    }\n    /**\n     * synchronous {@link PathBase.lstat}\n     */\n    lstatSync() {\n        if ((this.#type & ENOENT) === 0) {\n            try {\n                this.#applyStat(this.#fs.lstatSync(this.fullpath()));\n                return this;\n            }\n            catch (er) {\n                this.#lstatFail(er.code);\n            }\n        }\n    }\n    #applyStat(st) {\n        const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid, } = st;\n        this.#atime = atime;\n        this.#atimeMs = atimeMs;\n        this.#birthtime = birthtime;\n        this.#birthtimeMs = birthtimeMs;\n        this.#blksize = blksize;\n        this.#blocks = blocks;\n        this.#ctime = ctime;\n        this.#ctimeMs = ctimeMs;\n        this.#dev = dev;\n        this.#gid = gid;\n        this.#ino = ino;\n        this.#mode = mode;\n        this.#mtime = mtime;\n        this.#mtimeMs = mtimeMs;\n        this.#nlink = nlink;\n        this.#rdev = rdev;\n        this.#size = size;\n        this.#uid = uid;\n        const ifmt = entToType(st);\n        // retain any other flags, but set the ifmt\n        this.#type = (this.#type & IFMT_UNKNOWN) | ifmt | LSTAT_CALLED;\n        if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {\n            this.#type |= ENOTDIR;\n        }\n    }\n    #onReaddirCB = [];\n    #readdirCBInFlight = false;\n    #callOnReaddirCB(children) {\n        this.#readdirCBInFlight = false;\n        const cbs = this.#onReaddirCB.slice();\n        this.#onReaddirCB.length = 0;\n        cbs.forEach(cb => cb(null, children));\n    }\n    /**\n     * Standard node-style callback interface to get list of directory entries.\n     *\n     * If the Path cannot or does not contain any children, then an empty array\n     * is returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     *\n     * @param cb The callback called with (er, entries).  Note that the `er`\n     * param is somewhat extraneous, as all readdir() errors are handled and\n     * simply result in an empty set of entries being returned.\n     * @param allowZalgo Boolean indicating that immediately known results should\n     * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release\n     * zalgo at your peril, the dark pony lord is devious and unforgiving.\n     */\n    readdirCB(cb, allowZalgo = false) {\n        if (!this.canReaddir()) {\n            if (allowZalgo)\n                cb(null, []);\n            else\n                queueMicrotask(() => cb(null, []));\n            return;\n        }\n        const children = this.children();\n        if (this.calledReaddir()) {\n            const c = children.slice(0, children.provisional);\n            if (allowZalgo)\n                cb(null, c);\n            else\n                queueMicrotask(() => cb(null, c));\n            return;\n        }\n        // don't have to worry about zalgo at this point.\n        this.#onReaddirCB.push(cb);\n        if (this.#readdirCBInFlight) {\n            return;\n        }\n        this.#readdirCBInFlight = true;\n        // else read the directory, fill up children\n        // de-provisionalize any provisional children.\n        const fullpath = this.fullpath();\n        this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {\n            if (er) {\n                this.#readdirFail(er.code);\n                children.provisional = 0;\n            }\n            else {\n                // if we didn't get an error, we always get entries.\n                //@ts-ignore\n                for (const e of entries) {\n                    this.#readdirAddChild(e, children);\n                }\n                this.#readdirSuccess(children);\n            }\n            this.#callOnReaddirCB(children.slice(0, children.provisional));\n            return;\n        });\n    }\n    #asyncReaddirInFlight;\n    /**\n     * Return an array of known child entries.\n     *\n     * If the Path cannot or does not contain any children, then an empty array\n     * is returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     */\n    async readdir() {\n        if (!this.canReaddir()) {\n            return [];\n        }\n        const children = this.children();\n        if (this.calledReaddir()) {\n            return children.slice(0, children.provisional);\n        }\n        // else read the directory, fill up children\n        // de-provisionalize any provisional children.\n        const fullpath = this.fullpath();\n        if (this.#asyncReaddirInFlight) {\n            await this.#asyncReaddirInFlight;\n        }\n        else {\n            /* c8 ignore start */\n            let resolve = () => { };\n            /* c8 ignore stop */\n            this.#asyncReaddirInFlight = new Promise(res => (resolve = res));\n            try {\n                for (const e of await this.#fs.promises.readdir(fullpath, {\n                    withFileTypes: true,\n                })) {\n                    this.#readdirAddChild(e, children);\n                }\n                this.#readdirSuccess(children);\n            }\n            catch (er) {\n                this.#readdirFail(er.code);\n                children.provisional = 0;\n            }\n            this.#asyncReaddirInFlight = undefined;\n            resolve();\n        }\n        return children.slice(0, children.provisional);\n    }\n    /**\n     * synchronous {@link PathBase.readdir}\n     */\n    readdirSync() {\n        if (!this.canReaddir()) {\n            return [];\n        }\n        const children = this.children();\n        if (this.calledReaddir()) {\n            return children.slice(0, children.provisional);\n        }\n        // else read the directory, fill up children\n        // de-provisionalize any provisional children.\n        const fullpath = this.fullpath();\n        try {\n            for (const e of this.#fs.readdirSync(fullpath, {\n                withFileTypes: true,\n            })) {\n                this.#readdirAddChild(e, children);\n            }\n            this.#readdirSuccess(children);\n        }\n        catch (er) {\n            this.#readdirFail(er.code);\n            children.provisional = 0;\n        }\n        return children.slice(0, children.provisional);\n    }\n    canReaddir() {\n        if (this.#type & ENOCHILD)\n            return false;\n        const ifmt = IFMT & this.#type;\n        // we always set ENOTDIR when setting IFMT, so should be impossible\n        /* c8 ignore start */\n        if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {\n            return false;\n        }\n        /* c8 ignore stop */\n        return true;\n    }\n    shouldWalk(dirs, walkFilter) {\n        return ((this.#type & IFDIR) === IFDIR &&\n            !(this.#type & ENOCHILD) &&\n            !dirs.has(this) &&\n            (!walkFilter || walkFilter(this)));\n    }\n    /**\n     * Return the Path object corresponding to path as resolved\n     * by realpath(3).\n     *\n     * If the realpath call fails for any reason, `undefined` is returned.\n     *\n     * Result is cached, and thus may be outdated if the filesystem is mutated.\n     * On success, returns a Path object.\n     */\n    async realpath() {\n        if (this.#realpath)\n            return this.#realpath;\n        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)\n            return undefined;\n        try {\n            const rp = await this.#fs.promises.realpath(this.fullpath());\n            return (this.#realpath = this.resolve(rp));\n        }\n        catch (_) {\n            this.#markENOREALPATH();\n        }\n    }\n    /**\n     * Synchronous {@link realpath}\n     */\n    realpathSync() {\n        if (this.#realpath)\n            return this.#realpath;\n        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)\n            return undefined;\n        try {\n            const rp = this.#fs.realpathSync(this.fullpath());\n            return (this.#realpath = this.resolve(rp));\n        }\n        catch (_) {\n            this.#markENOREALPATH();\n        }\n    }\n    /**\n     * Internal method to mark this Path object as the scurry cwd,\n     * called by {@link PathScurry#chdir}\n     *\n     * @internal\n     */\n    [setAsCwd](oldCwd) {\n        if (oldCwd === this)\n            return;\n        const changed = new Set([]);\n        let rp = [];\n        let p = this;\n        while (p && p.parent) {\n            changed.add(p);\n            p.#relative = rp.join(this.sep);\n            p.#relativePosix = rp.join('/');\n            p = p.parent;\n            rp.push('..');\n        }\n        // now un-memoize parents of old cwd\n        p = oldCwd;\n        while (p && p.parent && !changed.has(p)) {\n            p.#relative = undefined;\n            p.#relativePosix = undefined;\n            p = p.parent;\n        }\n    }\n}\nexports.PathBase = PathBase;\n/**\n * Path class used on win32 systems\n *\n * Uses `'\\\\'` as the path separator for returned paths, either `'\\\\'` or `'/'`\n * as the path separator for parsing paths.\n */\nclass PathWin32 extends PathBase {\n    /**\n     * Separator for generating path strings.\n     */\n    sep = '\\\\';\n    /**\n     * Separator for parsing path strings.\n     */\n    splitSep = eitherSep;\n    /**\n     * Do not create new Path objects directly.  They should always be accessed\n     * via the PathScurry class or other methods on the Path class.\n     *\n     * @internal\n     */\n    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {\n        super(name, type, root, roots, nocase, children, opts);\n    }\n    /**\n     * @internal\n     */\n    newChild(name, type = UNKNOWN, opts = {}) {\n        return new PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);\n    }\n    /**\n     * @internal\n     */\n    getRootString(path) {\n        return path_1.win32.parse(path).root;\n    }\n    /**\n     * @internal\n     */\n    getRoot(rootPath) {\n        rootPath = uncToDrive(rootPath.toUpperCase());\n        if (rootPath === this.root.name) {\n            return this.root;\n        }\n        // ok, not that one, check if it matches another we know about\n        for (const [compare, root] of Object.entries(this.roots)) {\n            if (this.sameRoot(rootPath, compare)) {\n                return (this.roots[rootPath] = root);\n            }\n        }\n        // otherwise, have to create a new one.\n        return (this.roots[rootPath] = new PathScurryWin32(rootPath, this).root);\n    }\n    /**\n     * @internal\n     */\n    sameRoot(rootPath, compare = this.root.name) {\n        // windows can (rarely) have case-sensitive filesystem, but\n        // UNC and drive letters are always case-insensitive, and canonically\n        // represented uppercase.\n        rootPath = rootPath\n            .toUpperCase()\n            .replace(/\\//g, '\\\\')\n            .replace(uncDriveRegexp, '$1\\\\');\n        return rootPath === compare;\n    }\n}\nexports.PathWin32 = PathWin32;\n/**\n * Path class used on all posix systems.\n *\n * Uses `'/'` as the path separator.\n */\nclass PathPosix extends PathBase {\n    /**\n     * separator for parsing path strings\n     */\n    splitSep = '/';\n    /**\n     * separator for generating path strings\n     */\n    sep = '/';\n    /**\n     * Do not create new Path objects directly.  They should always be accessed\n     * via the PathScurry class or other methods on the Path class.\n     *\n     * @internal\n     */\n    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {\n        super(name, type, root, roots, nocase, children, opts);\n    }\n    /**\n     * @internal\n     */\n    getRootString(path) {\n        return path.startsWith('/') ? '/' : '';\n    }\n    /**\n     * @internal\n     */\n    getRoot(_rootPath) {\n        return this.root;\n    }\n    /**\n     * @internal\n     */\n    newChild(name, type = UNKNOWN, opts = {}) {\n        return new PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);\n    }\n}\nexports.PathPosix = PathPosix;\n/**\n * The base class for all PathScurry classes, providing the interface for path\n * resolution and filesystem operations.\n *\n * Typically, you should *not* instantiate this class directly, but rather one\n * of the platform-specific classes, or the exported {@link PathScurry} which\n * defaults to the current platform.\n */\nclass PathScurryBase {\n    /**\n     * The root Path entry for the current working directory of this Scurry\n     */\n    root;\n    /**\n     * The string path for the root of this Scurry's current working directory\n     */\n    rootPath;\n    /**\n     * A collection of all roots encountered, referenced by rootPath\n     */\n    roots;\n    /**\n     * The Path entry corresponding to this PathScurry's current working directory.\n     */\n    cwd;\n    #resolveCache;\n    #resolvePosixCache;\n    #children;\n    /**\n     * Perform path comparisons case-insensitively.\n     *\n     * Defaults true on Darwin and Windows systems, false elsewhere.\n     */\n    nocase;\n    #fs;\n    /**\n     * This class should not be instantiated directly.\n     *\n     * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry\n     *\n     * @internal\n     */\n    constructor(cwd = process.cwd(), pathImpl, sep, { nocase, childrenCacheSize = 16 * 1024, fs = defaultFS, } = {}) {\n        this.#fs = fsFromOption(fs);\n        if (cwd instanceof URL || cwd.startsWith('file://')) {\n            cwd = (0, url_1.fileURLToPath)(cwd);\n        }\n        // resolve and split root, and then add to the store.\n        // this is the only time we call path.resolve()\n        const cwdPath = pathImpl.resolve(cwd);\n        this.roots = Object.create(null);\n        this.rootPath = this.parseRootPath(cwdPath);\n        this.#resolveCache = new ResolveCache();\n        this.#resolvePosixCache = new ResolveCache();\n        this.#children = new ChildrenCache(childrenCacheSize);\n        const split = cwdPath.substring(this.rootPath.length).split(sep);\n        // resolve('/') leaves '', splits to [''], we don't want that.\n        if (split.length === 1 && !split[0]) {\n            split.pop();\n        }\n        /* c8 ignore start */\n        if (nocase === undefined) {\n            throw new TypeError('must provide nocase setting to PathScurryBase ctor');\n        }\n        /* c8 ignore stop */\n        this.nocase = nocase;\n        this.root = this.newRoot(this.#fs);\n        this.roots[this.rootPath] = this.root;\n        let prev = this.root;\n        let len = split.length - 1;\n        const joinSep = pathImpl.sep;\n        let abs = this.rootPath;\n        let sawFirst = false;\n        for (const part of split) {\n            const l = len--;\n            prev = prev.child(part, {\n                relative: new Array(l).fill('..').join(joinSep),\n                relativePosix: new Array(l).fill('..').join('/'),\n                fullpath: (abs += (sawFirst ? '' : joinSep) + part),\n            });\n            sawFirst = true;\n        }\n        this.cwd = prev;\n    }\n    /**\n     * Get the depth of a provided path, string, or the cwd\n     */\n    depth(path = this.cwd) {\n        if (typeof path === 'string') {\n            path = this.cwd.resolve(path);\n        }\n        return path.depth();\n    }\n    /**\n     * Return the cache of child entries.  Exposed so subclasses can create\n     * child Path objects in a platform-specific way.\n     *\n     * @internal\n     */\n    childrenCache() {\n        return this.#children;\n    }\n    /**\n     * Resolve one or more path strings to a resolved string\n     *\n     * Same interface as require('path').resolve.\n     *\n     * Much faster than path.resolve() when called multiple times for the same\n     * path, because the resolved Path objects are cached.  Much slower\n     * otherwise.\n     */\n    resolve(...paths) {\n        // first figure out the minimum number of paths we have to test\n        // we always start at cwd, but any absolutes will bump the start\n        let r = '';\n        for (let i = paths.length - 1; i >= 0; i--) {\n            const p = paths[i];\n            if (!p || p === '.')\n                continue;\n            r = r ? `${p}/${r}` : p;\n            if (this.isAbsolute(p)) {\n                break;\n            }\n        }\n        const cached = this.#resolveCache.get(r);\n        if (cached !== undefined) {\n            return cached;\n        }\n        const result = this.cwd.resolve(r).fullpath();\n        this.#resolveCache.set(r, result);\n        return result;\n    }\n    /**\n     * Resolve one or more path strings to a resolved string, returning\n     * the posix path.  Identical to .resolve() on posix systems, but on\n     * windows will return a forward-slash separated UNC path.\n     *\n     * Same interface as require('path').resolve.\n     *\n     * Much faster than path.resolve() when called multiple times for the same\n     * path, because the resolved Path objects are cached.  Much slower\n     * otherwise.\n     */\n    resolvePosix(...paths) {\n        // first figure out the minimum number of paths we have to test\n        // we always start at cwd, but any absolutes will bump the start\n        let r = '';\n        for (let i = paths.length - 1; i >= 0; i--) {\n            const p = paths[i];\n            if (!p || p === '.')\n                continue;\n            r = r ? `${p}/${r}` : p;\n            if (this.isAbsolute(p)) {\n                break;\n            }\n        }\n        const cached = this.#resolvePosixCache.get(r);\n        if (cached !== undefined) {\n            return cached;\n        }\n        const result = this.cwd.resolve(r).fullpathPosix();\n        this.#resolvePosixCache.set(r, result);\n        return result;\n    }\n    /**\n     * find the relative path from the cwd to the supplied path string or entry\n     */\n    relative(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.relative();\n    }\n    /**\n     * find the relative path from the cwd to the supplied path string or\n     * entry, using / as the path delimiter, even on Windows.\n     */\n    relativePosix(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.relativePosix();\n    }\n    /**\n     * Return the basename for the provided string or Path object\n     */\n    basename(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.name;\n    }\n    /**\n     * Return the dirname for the provided string or Path object\n     */\n    dirname(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return (entry.parent || entry).fullpath();\n    }\n    async readdir(entry = this.cwd, opts = {\n        withFileTypes: true,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes } = opts;\n        if (!entry.canReaddir()) {\n            return [];\n        }\n        else {\n            const p = await entry.readdir();\n            return withFileTypes ? p : p.map(e => e.name);\n        }\n    }\n    readdirSync(entry = this.cwd, opts = {\n        withFileTypes: true,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true } = opts;\n        if (!entry.canReaddir()) {\n            return [];\n        }\n        else if (withFileTypes) {\n            return entry.readdirSync();\n        }\n        else {\n            return entry.readdirSync().map(e => e.name);\n        }\n    }\n    /**\n     * Call lstat() on the string or Path object, and update all known\n     * information that can be determined.\n     *\n     * Note that unlike `fs.lstat()`, the returned value does not contain some\n     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n     * information is required, you will need to call `fs.lstat` yourself.\n     *\n     * If the Path refers to a nonexistent file, or if the lstat call fails for\n     * any reason, `undefined` is returned.  Otherwise the updated Path object is\n     * returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     */\n    async lstat(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.lstat();\n    }\n    /**\n     * synchronous {@link PathScurryBase.lstat}\n     */\n    lstatSync(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.lstatSync();\n    }\n    async readlink(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = await entry.readlink();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    readlinkSync(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = entry.readlinkSync();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    async realpath(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = await entry.realpath();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    realpathSync(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = entry.realpathSync();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    async walk(entry = this.cwd, opts = {}) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;\n        const results = [];\n        if (!filter || filter(entry)) {\n            results.push(withFileTypes ? entry : entry.fullpath());\n        }\n        const dirs = new Set();\n        const walk = (dir, cb) => {\n            dirs.add(dir);\n            dir.readdirCB((er, entries) => {\n                /* c8 ignore start */\n                if (er) {\n                    return cb(er);\n                }\n                /* c8 ignore stop */\n                let len = entries.length;\n                if (!len)\n                    return cb();\n                const next = () => {\n                    if (--len === 0) {\n                        cb();\n                    }\n                };\n                for (const e of entries) {\n                    if (!filter || filter(e)) {\n                        results.push(withFileTypes ? e : e.fullpath());\n                    }\n                    if (follow && e.isSymbolicLink()) {\n                        e.realpath()\n                            .then(r => (r?.isUnknown() ? r.lstat() : r))\n                            .then(r => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());\n                    }\n                    else {\n                        if (e.shouldWalk(dirs, walkFilter)) {\n                            walk(e, next);\n                        }\n                        else {\n                            next();\n                        }\n                    }\n                }\n            }, true); // zalgooooooo\n        };\n        const start = entry;\n        return new Promise((res, rej) => {\n            walk(start, er => {\n                /* c8 ignore start */\n                if (er)\n                    return rej(er);\n                /* c8 ignore stop */\n                res(results);\n            });\n        });\n    }\n    walkSync(entry = this.cwd, opts = {}) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;\n        const results = [];\n        if (!filter || filter(entry)) {\n            results.push(withFileTypes ? entry : entry.fullpath());\n        }\n        const dirs = new Set([entry]);\n        for (const dir of dirs) {\n            const entries = dir.readdirSync();\n            for (const e of entries) {\n                if (!filter || filter(e)) {\n                    results.push(withFileTypes ? e : e.fullpath());\n                }\n                let r = e;\n                if (e.isSymbolicLink()) {\n                    if (!(follow && (r = e.realpathSync())))\n                        continue;\n                    if (r.isUnknown())\n                        r.lstatSync();\n                }\n                if (r.shouldWalk(dirs, walkFilter)) {\n                    dirs.add(r);\n                }\n            }\n        }\n        return results;\n    }\n    /**\n     * Support for `for await`\n     *\n     * Alias for {@link PathScurryBase.iterate}\n     *\n     * Note: As of Node 19, this is very slow, compared to other methods of\n     * walking.  Consider using {@link PathScurryBase.stream} if memory overhead\n     * and backpressure are concerns, or {@link PathScurryBase.walk} if not.\n     */\n    [Symbol.asyncIterator]() {\n        return this.iterate();\n    }\n    iterate(entry = this.cwd, options = {}) {\n        // iterating async over the stream is significantly more performant,\n        // especially in the warm-cache scenario, because it buffers up directory\n        // entries in the background instead of waiting for a yield for each one.\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            options = entry;\n            entry = this.cwd;\n        }\n        return this.stream(entry, options)[Symbol.asyncIterator]();\n    }\n    /**\n     * Iterating over a PathScurry performs a synchronous walk.\n     *\n     * Alias for {@link PathScurryBase.iterateSync}\n     */\n    [Symbol.iterator]() {\n        return this.iterateSync();\n    }\n    *iterateSync(entry = this.cwd, opts = {}) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;\n        if (!filter || filter(entry)) {\n            yield withFileTypes ? entry : entry.fullpath();\n        }\n        const dirs = new Set([entry]);\n        for (const dir of dirs) {\n            const entries = dir.readdirSync();\n            for (const e of entries) {\n                if (!filter || filter(e)) {\n                    yield withFileTypes ? e : e.fullpath();\n                }\n                let r = e;\n                if (e.isSymbolicLink()) {\n                    if (!(follow && (r = e.realpathSync())))\n                        continue;\n                    if (r.isUnknown())\n                        r.lstatSync();\n                }\n                if (r.shouldWalk(dirs, walkFilter)) {\n                    dirs.add(r);\n                }\n            }\n        }\n    }\n    stream(entry = this.cwd, opts = {}) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;\n        const results = new minipass_1.Minipass({ objectMode: true });\n        if (!filter || filter(entry)) {\n            results.write(withFileTypes ? entry : entry.fullpath());\n        }\n        const dirs = new Set();\n        const queue = [entry];\n        let processing = 0;\n        const process = () => {\n            let paused = false;\n            while (!paused) {\n                const dir = queue.shift();\n                if (!dir) {\n                    if (processing === 0)\n                        results.end();\n                    return;\n                }\n                processing++;\n                dirs.add(dir);\n                const onReaddir = (er, entries, didRealpaths = false) => {\n                    /* c8 ignore start */\n                    if (er)\n                        return results.emit('error', er);\n                    /* c8 ignore stop */\n                    if (follow && !didRealpaths) {\n                        const promises = [];\n                        for (const e of entries) {\n                            if (e.isSymbolicLink()) {\n                                promises.push(e\n                                    .realpath()\n                                    .then((r) => r?.isUnknown() ? r.lstat() : r));\n                            }\n                        }\n                        if (promises.length) {\n                            Promise.all(promises).then(() => onReaddir(null, entries, true));\n                            return;\n                        }\n                    }\n                    for (const e of entries) {\n                        if (e && (!filter || filter(e))) {\n                            if (!results.write(withFileTypes ? e : e.fullpath())) {\n                                paused = true;\n                            }\n                        }\n                    }\n                    processing--;\n                    for (const e of entries) {\n                        const r = e.realpathCached() || e;\n                        if (r.shouldWalk(dirs, walkFilter)) {\n                            queue.push(r);\n                        }\n                    }\n                    if (paused && !results.flowing) {\n                        results.once('drain', process);\n                    }\n                    else if (!sync) {\n                        process();\n                    }\n                };\n                // zalgo containment\n                let sync = true;\n                dir.readdirCB(onReaddir, true);\n                sync = false;\n            }\n        };\n        process();\n        return results;\n    }\n    streamSync(entry = this.cwd, opts = {}) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;\n        const results = new minipass_1.Minipass({ objectMode: true });\n        const dirs = new Set();\n        if (!filter || filter(entry)) {\n            results.write(withFileTypes ? entry : entry.fullpath());\n        }\n        const queue = [entry];\n        let processing = 0;\n        const process = () => {\n            let paused = false;\n            while (!paused) {\n                const dir = queue.shift();\n                if (!dir) {\n                    if (processing === 0)\n                        results.end();\n                    return;\n                }\n                processing++;\n                dirs.add(dir);\n                const entries = dir.readdirSync();\n                for (const e of entries) {\n                    if (!filter || filter(e)) {\n                        if (!results.write(withFileTypes ? e : e.fullpath())) {\n                            paused = true;\n                        }\n                    }\n                }\n                processing--;\n                for (const e of entries) {\n                    let r = e;\n                    if (e.isSymbolicLink()) {\n                        if (!(follow && (r = e.realpathSync())))\n                            continue;\n                        if (r.isUnknown())\n                            r.lstatSync();\n                    }\n                    if (r.shouldWalk(dirs, walkFilter)) {\n                        queue.push(r);\n                    }\n                }\n            }\n            if (paused && !results.flowing)\n                results.once('drain', process);\n        };\n        process();\n        return results;\n    }\n    chdir(path = this.cwd) {\n        const oldCwd = this.cwd;\n        this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path;\n        this.cwd[setAsCwd](oldCwd);\n    }\n}\nexports.PathScurryBase = PathScurryBase;\n/**\n * Windows implementation of {@link PathScurryBase}\n *\n * Defaults to case insensitve, uses `'\\\\'` to generate path strings.  Uses\n * {@link PathWin32} for Path objects.\n */\nclass PathScurryWin32 extends PathScurryBase {\n    /**\n     * separator for generating path strings\n     */\n    sep = '\\\\';\n    constructor(cwd = process.cwd(), opts = {}) {\n        const { nocase = true } = opts;\n        super(cwd, path_1.win32, '\\\\', { ...opts, nocase });\n        this.nocase = nocase;\n        for (let p = this.cwd; p; p = p.parent) {\n            p.nocase = this.nocase;\n        }\n    }\n    /**\n     * @internal\n     */\n    parseRootPath(dir) {\n        // if the path starts with a single separator, it's not a UNC, and we'll\n        // just get separator as the root, and driveFromUNC will return \\\n        // In that case, mount \\ on the root from the cwd.\n        return path_1.win32.parse(dir).root.toUpperCase();\n    }\n    /**\n     * @internal\n     */\n    newRoot(fs) {\n        return new PathWin32(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });\n    }\n    /**\n     * Return true if the provided path string is an absolute path\n     */\n    isAbsolute(p) {\n        return (p.startsWith('/') || p.startsWith('\\\\') || /^[a-z]:(\\/|\\\\)/i.test(p));\n    }\n}\nexports.PathScurryWin32 = PathScurryWin32;\n/**\n * {@link PathScurryBase} implementation for all posix systems other than Darwin.\n *\n * Defaults to case-sensitive matching, uses `'/'` to generate path strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nclass PathScurryPosix extends PathScurryBase {\n    /**\n     * separator for generating path strings\n     */\n    sep = '/';\n    constructor(cwd = process.cwd(), opts = {}) {\n        const { nocase = false } = opts;\n        super(cwd, path_1.posix, '/', { ...opts, nocase });\n        this.nocase = nocase;\n    }\n    /**\n     * @internal\n     */\n    parseRootPath(_dir) {\n        return '/';\n    }\n    /**\n     * @internal\n     */\n    newRoot(fs) {\n        return new PathPosix(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });\n    }\n    /**\n     * Return true if the provided path string is an absolute path\n     */\n    isAbsolute(p) {\n        return p.startsWith('/');\n    }\n}\nexports.PathScurryPosix = PathScurryPosix;\n/**\n * {@link PathScurryBase} implementation for Darwin (macOS) systems.\n *\n * Defaults to case-insensitive matching, uses `'/'` for generating path\n * strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nclass PathScurryDarwin extends PathScurryPosix {\n    constructor(cwd = process.cwd(), opts = {}) {\n        const { nocase = true } = opts;\n        super(cwd, { ...opts, nocase });\n    }\n}\nexports.PathScurryDarwin = PathScurryDarwin;\n/**\n * Default {@link PathBase} implementation for the current platform.\n *\n * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.\n */\nexports.Path = process.platform === 'win32' ? PathWin32 : PathPosix;\n/**\n * Default {@link PathScurryBase} implementation for the current platform.\n *\n * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on\n * Darwin (macOS) systems, {@link PathScurryPosix} on all others.\n */\nexports.PathScurry = process.platform === 'win32'\n    ? PathScurryWin32\n    : process.platform === 'darwin'\n        ? PathScurryDarwin\n        : PathScurryPosix;\n"],"mappings":"AAAA,YAAY;;AAAC;AACb,IAAIA,eAAe,GAAI,IAAI,IAAI,IAAI,CAACA,eAAe,KAAMC,MAAM,CAACC,MAAM,GAAI,UAASC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,EAAE,EAAE;EAC5F,IAAIA,EAAE,KAAKC,SAAS,EAAED,EAAE,GAAGD,CAAC;EAC5B,IAAIG,IAAI,GAAGP,MAAM,CAACQ,wBAAwB,CAACL,CAAC,EAAEC,CAAC,CAAC;EAChD,IAAI,CAACG,IAAI,KAAK,KAAK,IAAIA,IAAI,GAAG,CAACJ,CAAC,CAACM,UAAU,GAAGF,IAAI,CAACG,QAAQ,IAAIH,IAAI,CAACI,YAAY,CAAC,EAAE;IACjFJ,IAAI,GAAG;MAAEK,UAAU,EAAE,IAAI;MAAEC,GAAG,EAAE,YAAW;QAAE,OAAOV,CAAC,CAACC,CAAC,CAAC;MAAE;IAAE,CAAC;EAC/D;EACAJ,MAAM,CAACc,cAAc,CAACZ,CAAC,EAAEG,EAAE,EAAEE,IAAI,CAAC;AACtC,CAAC,GAAK,UAASL,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,EAAE,EAAE;EACxB,IAAIA,EAAE,KAAKC,SAAS,EAAED,EAAE,GAAGD,CAAC;EAC5BF,CAAC,CAACG,EAAE,CAAC,GAAGF,CAAC,CAACC,CAAC,CAAC;AAChB,CAAE,CAAC;AACH,IAAIW,kBAAkB,GAAI,IAAI,IAAI,IAAI,CAACA,kBAAkB,KAAMf,MAAM,CAACC,MAAM,GAAI,UAASC,CAAC,EAAEc,CAAC,EAAE;EAC3FhB,MAAM,CAACc,cAAc,CAACZ,CAAC,EAAE,SAAS,EAAE;IAAEU,UAAU,EAAE,IAAI;IAAEK,KAAK,EAAED;EAAE,CAAC,CAAC;AACvE,CAAC,GAAI,UAASd,CAAC,EAAEc,CAAC,EAAE;EAChBd,CAAC,CAAC,SAAS,CAAC,GAAGc,CAAC;AACpB,CAAC,CAAC;AACF,IAAIE,YAAY,GAAI,IAAI,IAAI,IAAI,CAACA,YAAY,IAAK,UAAUC,GAAG,EAAE;EAC7D,IAAIA,GAAG,IAAIA,GAAG,CAACV,UAAU,EAAE,OAAOU,GAAG;EACrC,IAAIC,MAAM,GAAG,CAAC,CAAC;EACf,IAAID,GAAG,IAAI,IAAI,EAAE,KAAK,IAAIf,CAAC,IAAIe,GAAG,EAAE,IAAIf,CAAC,KAAK,SAAS,IAAIJ,MAAM,CAACqB,SAAS,CAACC,cAAc,CAACC,IAAI,CAACJ,GAAG,EAAEf,CAAC,CAAC,EAAEL,eAAe,CAACqB,MAAM,EAAED,GAAG,EAAEf,CAAC,CAAC;EACxIW,kBAAkB,CAACK,MAAM,EAAED,GAAG,CAAC;EAC/B,OAAOC,MAAM;AACjB,CAAC;AACDpB,MAAM,CAACc,cAAc,CAACU,OAAO,EAAE,YAAY,EAAE;EAAEP,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DO,OAAO,CAACC,UAAU,GAAGD,OAAO,CAACE,IAAI,GAAGF,OAAO,CAACG,gBAAgB,GAAGH,OAAO,CAACI,eAAe,GAAGJ,OAAO,CAACK,eAAe,GAAGL,OAAO,CAACM,cAAc,GAAGN,OAAO,CAACO,SAAS,GAAGP,OAAO,CAACQ,SAAS,GAAGR,OAAO,CAACS,QAAQ,GAAGT,OAAO,CAACU,aAAa,GAAGV,OAAO,CAACW,YAAY,GAAG,KAAK,CAAC;AAC5P,MAAMC,WAAW,GAAGC,OAAO,CAAC,WAAW,CAAC;AACxC,MAAMC,MAAM,GAAGD,OAAO,CAAC,MAAM,CAAC;AAC9B,MAAME,KAAK,GAAGF,OAAO,CAAC,KAAK,CAAC;AAC5B,MAAMG,QAAQ,GAAGtB,YAAY,CAACmB,OAAO,CAAC,IAAI,CAAC,CAAC;AAC5C,MAAMI,IAAI,GAAGJ,OAAO,CAAC,IAAI,CAAC;AAC1B,MAAMK,YAAY,GAAGD,IAAI,CAACC,YAAY,CAACC,MAAM;AAC7C;AACA;AACA,MAAMC,UAAU,GAAGP,OAAO,CAAC,aAAa,CAAC;AACzC,MAAMQ,UAAU,GAAGR,OAAO,CAAC,UAAU,CAAC;AACtC,MAAMS,SAAS,GAAG;EACdC,SAAS,EAAEN,IAAI,CAACM,SAAS;EACzBC,OAAO,EAAEP,IAAI,CAACO,OAAO;EACrBC,WAAW,EAAER,IAAI,CAACQ,WAAW;EAC7BC,YAAY,EAAET,IAAI,CAACS,YAAY;EAC/BR,YAAY;EACZS,QAAQ,EAAE;IACNC,KAAK,EAAER,UAAU,CAACQ,KAAK;IACvBJ,OAAO,EAAEJ,UAAU,CAACI,OAAO;IAC3BK,QAAQ,EAAET,UAAU,CAACS,QAAQ;IAC7BC,QAAQ,EAAEV,UAAU,CAACU;EACzB;AACJ,CAAC;AACD;AACA,MAAMC,YAAY,GAAIC,QAAQ,IAAK,CAACA,QAAQ,IAAIA,QAAQ,KAAKV,SAAS,IAAIU,QAAQ,KAAKhB,QAAQ,GACzFM,SAAS,GACT;EACE,GAAGA,SAAS;EACZ,GAAGU,QAAQ;EACXL,QAAQ,EAAE;IACN,GAAGL,SAAS,CAACK,QAAQ;IACrB,IAAIK,QAAQ,CAACL,QAAQ,IAAI,CAAC,CAAC;EAC/B;AACJ,CAAC;AACL;AACA,MAAMM,cAAc,GAAG,wBAAwB;AAC/C,MAAMC,UAAU,GAAIC,QAAQ,IAAKA,QAAQ,CAACC,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,CAACA,OAAO,CAACH,cAAc,EAAE,MAAM,CAAC;AAC9F;AACA,MAAMI,SAAS,GAAG,QAAQ;AAC1B,MAAMC,OAAO,GAAG,CAAC,CAAC,CAAC;AACnB,MAAMC,KAAK,GAAG,MAAM;AACpB,MAAMC,KAAK,GAAG,MAAM;AACpB,MAAMC,KAAK,GAAG,MAAM;AACpB,MAAMC,KAAK,GAAG,MAAM;AACpB,MAAMC,KAAK,GAAG,MAAM;AACpB,MAAMC,KAAK,GAAG,MAAM;AACpB,MAAMC,MAAM,GAAG,MAAM;AACrB,MAAMC,IAAI,GAAG,MAAM;AACnB;AACA,MAAMC,YAAY,GAAG,CAACD,IAAI;AAC1B;AACA,MAAME,cAAc,GAAG,EAAE;AACzB;AACA,MAAMC,YAAY,GAAG,EAAE;AACvB;AACA,MAAMC,OAAO,GAAG,EAAE;AAClB;AACA;AACA,MAAMC,MAAM,GAAG,GAAG;AAClB;AACA;AACA,MAAMC,WAAW,GAAG,GAAG;AACvB;AACA,MAAMC,WAAW,GAAG,GAAG;AACvB,MAAMC,QAAQ,GAAGJ,OAAO,GAAGC,MAAM,GAAGE,WAAW;AAC/C,MAAME,QAAQ,GAAG,IAAI;AACrB,MAAMC,SAAS,GAAIC,CAAC,IAAKA,CAAC,CAACC,MAAM,EAAE,GAC7Bf,KAAK,GACLc,CAAC,CAACE,WAAW,EAAE,GACXlB,KAAK,GACLgB,CAAC,CAACG,cAAc,EAAE,GACdhB,KAAK,GACLa,CAAC,CAACI,iBAAiB,EAAE,GACjBrB,KAAK,GACLiB,CAAC,CAACK,aAAa,EAAE,GACbpB,KAAK,GACLe,CAAC,CAACM,QAAQ,EAAE,GACRlB,MAAM,GACNY,CAAC,CAACO,MAAM,EAAE,GACNzB,KAAK,GACLD,OAAO;AACrC;AACA,MAAM2B,cAAc,GAAG,IAAIC,GAAG,EAAE;AAChC,MAAMC,SAAS,GAAIV,CAAC,IAAK;EACrB,MAAMW,CAAC,GAAGH,cAAc,CAAC5E,GAAG,CAACoE,CAAC,CAAC;EAC/B,IAAIW,CAAC,EACD,OAAOA,CAAC;EACZ,MAAMC,CAAC,GAAGZ,CAAC,CAACU,SAAS,CAAC,MAAM,CAAC;EAC7BF,cAAc,CAACK,GAAG,CAACb,CAAC,EAAEY,CAAC,CAAC;EACxB,OAAOA,CAAC;AACZ,CAAC;AACD,MAAME,oBAAoB,GAAG,IAAIL,GAAG,EAAE;AACtC,MAAMM,eAAe,GAAIf,CAAC,IAAK;EAC3B,MAAMW,CAAC,GAAGG,oBAAoB,CAAClF,GAAG,CAACoE,CAAC,CAAC;EACrC,IAAIW,CAAC,EACD,OAAOA,CAAC;EACZ,MAAMC,CAAC,GAAGF,SAAS,CAACV,CAAC,CAACgB,WAAW,EAAE,CAAC;EACpCF,oBAAoB,CAACD,GAAG,CAACb,CAAC,EAAEY,CAAC,CAAC;EAC9B,OAAOA,CAAC;AACZ,CAAC;AACD;AACA;AACA;AACA;AACA,MAAM1D,YAAY,SAASC,WAAW,CAAC8D,QAAQ,CAAC;EAC5CC,WAAW,GAAG;IACV,KAAK,CAAC;MAAEC,GAAG,EAAE;IAAI,CAAC,CAAC;EACvB;AACJ;AACA5E,OAAO,CAACW,YAAY,GAAGA,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMD,aAAa,SAASE,WAAW,CAAC8D,QAAQ,CAAC;EAC7CC,WAAW,CAACE,OAAO,GAAG,EAAE,GAAG,IAAI,EAAE;IAC7B,KAAK,CAAC;MACFA,OAAO;MACP;MACAC,eAAe,EAAEC,CAAC,IAAIA,CAAC,CAACC,MAAM,GAAG;IACrC,CAAC,CAAC;EACN;AACJ;AACAhF,OAAO,CAACU,aAAa,GAAGA,aAAa;AACrC,MAAMuE,QAAQ,GAAGC,MAAM,CAAC,qBAAqB,CAAC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMzE,QAAQ,CAAC;EACX;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI0E,IAAI;EACJ;AACJ;AACA;AACA;AACA;EACIC,IAAI;EACJ;AACJ;AACA;AACA;AACA;EACIC,KAAK;EACL;AACJ;AACA;AACA;AACA;EACIC,MAAM;EACN;AACJ;AACA;AACA;EACIC,MAAM;EACN;EACA,CAACC,EAAE;EACH;EACA,CAACC,GAAG;EACJ,IAAIA,GAAG,GAAG;IACN,OAAO,IAAI,CAAC,CAACA,GAAG;EACpB;EACA,CAACC,IAAI;EACL,IAAIA,IAAI,GAAG;IACP,OAAO,IAAI,CAAC,CAACA,IAAI;EACrB;EACA,CAACC,KAAK;EACN,IAAIA,KAAK,GAAG;IACR,OAAO,IAAI,CAAC,CAACA,KAAK;EACtB;EACA,CAACC,GAAG;EACJ,IAAIA,GAAG,GAAG;IACN,OAAO,IAAI,CAAC,CAACA,GAAG;EACpB;EACA,CAACC,GAAG;EACJ,IAAIA,GAAG,GAAG;IACN,OAAO,IAAI,CAAC,CAACA,GAAG;EACpB;EACA,CAACC,IAAI;EACL,IAAIA,IAAI,GAAG;IACP,OAAO,IAAI,CAAC,CAACA,IAAI;EACrB;EACA,CAACC,OAAO;EACR,IAAIA,OAAO,GAAG;IACV,OAAO,IAAI,CAAC,CAACA,OAAO;EACxB;EACA,CAACC,GAAG;EACJ,IAAIA,GAAG,GAAG;IACN,OAAO,IAAI,CAAC,CAACA,GAAG;EACpB;EACA,CAACC,IAAI;EACL,IAAIA,IAAI,GAAG;IACP,OAAO,IAAI,CAAC,CAACA,IAAI;EACrB;EACA,CAACC,MAAM;EACP,IAAIA,MAAM,GAAG;IACT,OAAO,IAAI,CAAC,CAACA,MAAM;EACvB;EACA,CAACC,OAAO;EACR,IAAIA,OAAO,GAAG;IACV,OAAO,IAAI,CAAC,CAACA,OAAO;EACxB;EACA,CAACC,OAAO;EACR,IAAIA,OAAO,GAAG;IACV,OAAO,IAAI,CAAC,CAACA,OAAO;EACxB;EACA,CAACC,OAAO;EACR,IAAIA,OAAO,GAAG;IACV,OAAO,IAAI,CAAC,CAACA,OAAO;EACxB;EACA,CAACC,WAAW;EACZ,IAAIA,WAAW,GAAG;IACd,OAAO,IAAI,CAAC,CAACA,WAAW;EAC5B;EACA,CAACC,KAAK;EACN,IAAIA,KAAK,GAAG;IACR,OAAO,IAAI,CAAC,CAACA,KAAK;EACtB;EACA,CAACC,KAAK;EACN,IAAIA,KAAK,GAAG;IACR,OAAO,IAAI,CAAC,CAACA,KAAK;EACtB;EACA,CAACC,KAAK;EACN,IAAIA,KAAK,GAAG;IACR,OAAO,IAAI,CAAC,CAACA,KAAK;EACtB;EACA,CAACC,SAAS;EACV,IAAIA,SAAS,GAAG;IACZ,OAAO,IAAI,CAAC,CAACA,SAAS;EAC1B;EACA,CAACC,SAAS;EACV,CAACC,KAAK;EACN,CAACC,QAAQ;EACT,CAACC,aAAa;EACd,CAACC,QAAQ;EACT,CAACC,aAAa;EACd,CAACC,IAAI;EACL,CAACC,QAAQ;EACT,CAACC,UAAU;EACX,CAACrF,QAAQ;EACT;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,IAAIsF,IAAI,GAAG;IACP,OAAO,CAAC,IAAI,CAAC9B,MAAM,IAAI,IAAI,EAAEuB,QAAQ,EAAE;EAC3C;EACA;AACJ;AACA;AACA;AACA;AACA;EACIlC,WAAW,CAACQ,IAAI,EAAE8B,IAAI,GAAG3E,OAAO,EAAE8C,IAAI,EAAEC,KAAK,EAAEE,MAAM,EAAE2B,QAAQ,EAAEG,IAAI,EAAE;IACnE,IAAI,CAAClC,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC,CAACwB,SAAS,GAAGpB,MAAM,GAAGf,eAAe,CAACW,IAAI,CAAC,GAAGhB,SAAS,CAACgB,IAAI,CAAC;IAClE,IAAI,CAAC,CAAC8B,IAAI,GAAGA,IAAI,GAAG1D,QAAQ;IAC5B,IAAI,CAACgC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACF,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACD,IAAI,GAAGA,IAAI,IAAI,IAAI;IACxB,IAAI,CAAC,CAAC8B,QAAQ,GAAGA,QAAQ;IACzB,IAAI,CAAC,CAACL,QAAQ,GAAGQ,IAAI,CAACR,QAAQ;IAC9B,IAAI,CAAC,CAACE,QAAQ,GAAGM,IAAI,CAACN,QAAQ;IAC9B,IAAI,CAAC,CAACC,aAAa,GAAGK,IAAI,CAACL,aAAa;IACxC,IAAI,CAAC1B,MAAM,GAAG+B,IAAI,CAAC/B,MAAM;IACzB,IAAI,IAAI,CAACA,MAAM,EAAE;MACb,IAAI,CAAC,CAACE,EAAE,GAAG,IAAI,CAACF,MAAM,CAAC,CAACE,EAAE;IAC9B,CAAC,MACI;MACD,IAAI,CAAC,CAACA,EAAE,GAAGzD,YAAY,CAACsF,IAAI,CAAC7B,EAAE,CAAC;IACpC;EACJ;EACA;AACJ;AACA;AACA;AACA;EACIoB,KAAK,GAAG;IACJ,IAAI,IAAI,CAAC,CAACA,KAAK,KAAK9H,SAAS,EACzB,OAAO,IAAI,CAAC,CAAC8H,KAAK;IACtB,IAAI,CAAC,IAAI,CAACtB,MAAM,EACZ,OAAQ,IAAI,CAAC,CAACsB,KAAK,GAAG,CAAC;IAC3B,OAAQ,IAAI,CAAC,CAACA,KAAK,GAAG,IAAI,CAACtB,MAAM,CAACsB,KAAK,EAAE,GAAG,CAAC;EACjD;EACA;AACJ;AACA;EACIU,aAAa,GAAG;IACZ,OAAO,IAAI,CAAC,CAACJ,QAAQ;EACzB;EACA;AACJ;AACA;EACIK,OAAO,CAACH,IAAI,EAAE;IACV,IAAI,CAACA,IAAI,EAAE;MACP,OAAO,IAAI;IACf;IACA,MAAMjF,QAAQ,GAAG,IAAI,CAACqF,aAAa,CAACJ,IAAI,CAAC;IACzC,MAAMK,GAAG,GAAGL,IAAI,CAACM,SAAS,CAACvF,QAAQ,CAAC6C,MAAM,CAAC;IAC3C,MAAM2C,QAAQ,GAAGF,GAAG,CAACG,KAAK,CAAC,IAAI,CAACC,QAAQ,CAAC;IACzC,MAAMjI,MAAM,GAAGuC,QAAQ,GACjB,IAAI,CAAC2F,OAAO,CAAC3F,QAAQ,CAAC,CAAC,CAAC4F,YAAY,CAACJ,QAAQ,CAAC,GAC9C,IAAI,CAAC,CAACI,YAAY,CAACJ,QAAQ,CAAC;IAClC,OAAO/H,MAAM;EACjB;EACA,CAACmI,YAAY,CAACJ,QAAQ,EAAE;IACpB,IAAIK,CAAC,GAAG,IAAI;IACZ,KAAK,MAAMC,IAAI,IAAIN,QAAQ,EAAE;MACzBK,CAAC,GAAGA,CAAC,CAACE,KAAK,CAACD,IAAI,CAAC;IACrB;IACA,OAAOD,CAAC;EACZ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACId,QAAQ,GAAG;IACP,MAAMiB,MAAM,GAAG,IAAI,CAAC,CAACjB,QAAQ,CAAC7H,GAAG,CAAC,IAAI,CAAC;IACvC,IAAI8I,MAAM,EAAE;MACR,OAAOA,MAAM;IACjB;IACA,MAAMjB,QAAQ,GAAG1I,MAAM,CAAC4J,MAAM,CAAC,EAAE,EAAE;MAAEC,WAAW,EAAE;IAAE,CAAC,CAAC;IACtD,IAAI,CAAC,CAACnB,QAAQ,CAAC5C,GAAG,CAAC,IAAI,EAAE4C,QAAQ,CAAC;IAClC,IAAI,CAAC,CAACD,IAAI,IAAI,CAACjE,cAAc;IAC7B,OAAOkE,QAAQ;EACnB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIgB,KAAK,CAACI,QAAQ,EAAEjB,IAAI,EAAE;IAClB,IAAIiB,QAAQ,KAAK,EAAE,IAAIA,QAAQ,KAAK,GAAG,EAAE;MACrC,OAAO,IAAI;IACf;IACA,IAAIA,QAAQ,KAAK,IAAI,EAAE;MACnB,OAAO,IAAI,CAAChD,MAAM,IAAI,IAAI;IAC9B;IACA;IACA,MAAM4B,QAAQ,GAAG,IAAI,CAACA,QAAQ,EAAE;IAChC,MAAM/B,IAAI,GAAG,IAAI,CAACI,MAAM,GAClBf,eAAe,CAAC8D,QAAQ,CAAC,GACzBnE,SAAS,CAACmE,QAAQ,CAAC;IACzB,KAAK,MAAMN,CAAC,IAAId,QAAQ,EAAE;MACtB,IAAIc,CAAC,CAAC,CAACrB,SAAS,KAAKxB,IAAI,EAAE;QACvB,OAAO6C,CAAC;MACZ;IACJ;IACA;IACA;IACA;IACA,MAAMvE,CAAC,GAAG,IAAI,CAAC6B,MAAM,GAAG,IAAI,CAACiD,GAAG,GAAG,EAAE;IACrC,MAAM1B,QAAQ,GAAG,IAAI,CAAC,CAACA,QAAQ,GACzB,IAAI,CAAC,CAACA,QAAQ,GAAGpD,CAAC,GAAG6E,QAAQ,GAC7BxJ,SAAS;IACf,MAAM0J,MAAM,GAAG,IAAI,CAACC,QAAQ,CAACH,QAAQ,EAAEhG,OAAO,EAAE;MAC5C,GAAG+E,IAAI;MACP/B,MAAM,EAAE,IAAI;MACZuB;IACJ,CAAC,CAAC;IACF,IAAI,CAAC,IAAI,CAAC6B,UAAU,EAAE,EAAE;MACpBF,MAAM,CAAC,CAACvB,IAAI,IAAI9D,MAAM;IAC1B;IACA;IACA;IACA+D,QAAQ,CAACyB,IAAI,CAACH,MAAM,CAAC;IACrB,OAAOA,MAAM;EACjB;EACA;AACJ;AACA;AACA;EACIzB,QAAQ,GAAG;IACP,IAAI,IAAI,CAAC,CAACA,QAAQ,KAAKjI,SAAS,EAAE;MAC9B,OAAO,IAAI,CAAC,CAACiI,QAAQ;IACzB;IACA,MAAM5B,IAAI,GAAG,IAAI,CAACA,IAAI;IACtB,MAAM6C,CAAC,GAAG,IAAI,CAAC1C,MAAM;IACrB,IAAI,CAAC0C,CAAC,EAAE;MACJ,OAAQ,IAAI,CAAC,CAACjB,QAAQ,GAAG,IAAI,CAAC5B,IAAI;IACtC;IACA,MAAMyD,EAAE,GAAGZ,CAAC,CAACjB,QAAQ,EAAE;IACvB,OAAO6B,EAAE,IAAI,CAACA,EAAE,IAAI,CAACZ,CAAC,CAAC1C,MAAM,GAAG,EAAE,GAAG,IAAI,CAACiD,GAAG,CAAC,GAAGpD,IAAI;EACzD;EACA;AACJ;AACA;AACA;AACA;AACA;EACI6B,aAAa,GAAG;IACZ,IAAI,IAAI,CAACuB,GAAG,KAAK,GAAG,EAChB,OAAO,IAAI,CAACxB,QAAQ,EAAE;IAC1B,IAAI,IAAI,CAAC,CAACC,aAAa,KAAKlI,SAAS,EACjC,OAAO,IAAI,CAAC,CAACkI,aAAa;IAC9B,MAAM7B,IAAI,GAAG,IAAI,CAACA,IAAI;IACtB,MAAM6C,CAAC,GAAG,IAAI,CAAC1C,MAAM;IACrB,IAAI,CAAC0C,CAAC,EAAE;MACJ,OAAQ,IAAI,CAAC,CAAChB,aAAa,GAAG,IAAI,CAACF,aAAa,EAAE;IACtD;IACA,MAAM8B,EAAE,GAAGZ,CAAC,CAAChB,aAAa,EAAE;IAC5B,OAAO4B,EAAE,IAAI,CAACA,EAAE,IAAI,CAACZ,CAAC,CAAC1C,MAAM,GAAG,EAAE,GAAG,GAAG,CAAC,GAAGH,IAAI;EACpD;EACA;AACJ;AACA;EACI0B,QAAQ,GAAG;IACP,IAAI,IAAI,CAAC,CAACA,QAAQ,KAAK/H,SAAS,EAAE;MAC9B,OAAO,IAAI,CAAC,CAAC+H,QAAQ;IACzB;IACA,MAAM1B,IAAI,GAAG,IAAI,CAACA,IAAI;IACtB,MAAM6C,CAAC,GAAG,IAAI,CAAC1C,MAAM;IACrB,IAAI,CAAC0C,CAAC,EAAE;MACJ,OAAQ,IAAI,CAAC,CAACnB,QAAQ,GAAG,IAAI,CAAC1B,IAAI;IACtC;IACA,MAAMyD,EAAE,GAAGZ,CAAC,CAACnB,QAAQ,EAAE;IACvB,MAAMgC,EAAE,GAAGD,EAAE,IAAI,CAACZ,CAAC,CAAC1C,MAAM,GAAG,EAAE,GAAG,IAAI,CAACiD,GAAG,CAAC,GAAGpD,IAAI;IAClD,OAAQ,IAAI,CAAC,CAAC0B,QAAQ,GAAGgC,EAAE;EAC/B;EACA;AACJ;AACA;AACA;AACA;AACA;EACI/B,aAAa,GAAG;IACZ,IAAI,IAAI,CAAC,CAACA,aAAa,KAAKhI,SAAS,EACjC,OAAO,IAAI,CAAC,CAACgI,aAAa;IAC9B,IAAI,IAAI,CAACyB,GAAG,KAAK,GAAG,EAChB,OAAQ,IAAI,CAAC,CAACzB,aAAa,GAAG,IAAI,CAACD,QAAQ,EAAE;IACjD,IAAI,CAAC,IAAI,CAACvB,MAAM,EAAE;MACd,MAAM0C,CAAC,GAAG,IAAI,CAACnB,QAAQ,EAAE,CAACzE,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC;MAC7C,IAAI,YAAY,CAAC0G,IAAI,CAACd,CAAC,CAAC,EAAE;QACtB,OAAQ,IAAI,CAAC,CAAClB,aAAa,GAAI,OAAMkB,CAAE,EAAC;MAC5C,CAAC,MACI;QACD,OAAQ,IAAI,CAAC,CAAClB,aAAa,GAAGkB,CAAC;MACnC;IACJ;IACA,MAAMA,CAAC,GAAG,IAAI,CAAC1C,MAAM;IACrB,MAAMyD,IAAI,GAAGf,CAAC,CAAClB,aAAa,EAAE;IAC9B,MAAMkC,GAAG,GAAGD,IAAI,IAAI,CAACA,IAAI,IAAI,CAACf,CAAC,CAAC1C,MAAM,GAAG,EAAE,GAAG,GAAG,CAAC,GAAG,IAAI,CAACH,IAAI;IAC9D,OAAQ,IAAI,CAAC,CAAC2B,aAAa,GAAGkC,GAAG;EACrC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIC,SAAS,GAAG;IACR,OAAO,CAAC,IAAI,CAAC,CAAChC,IAAI,GAAGnE,IAAI,MAAMR,OAAO;EAC1C;EACA4G,MAAM,CAACjC,IAAI,EAAE;IACT,OAAO,IAAI,CAAE,KAAIA,IAAK,EAAC,CAAC,EAAE;EAC9B;EACAkC,OAAO,GAAG;IACN,OAAO,IAAI,CAACF,SAAS,EAAE,GACjB,SAAS,GACT,IAAI,CAACtF,WAAW,EAAE,GACd,WAAW,GACX,IAAI,CAACD,MAAM,EAAE,GACT,MAAM,GACN,IAAI,CAACE,cAAc,EAAE,GACjB,cAAc,GACd,IAAI,CAACI,MAAM,EAAE,GACT,MAAM,GACN,IAAI,CAACH,iBAAiB,EAAE,GACpB,iBAAiB,GACjB,IAAI,CAACC,aAAa,EAAE,GAChB,aAAa,GACb,qBAAsB,IAAI,CAACC,QAAQ,EAAE,GACjC,QAAQ,GACR,SAAS;IAC3C;EACJ;EACA;AACJ;AACA;EACIL,MAAM,GAAG;IACL,OAAO,CAAC,IAAI,CAAC,CAACuD,IAAI,GAAGnE,IAAI,MAAMH,KAAK;EACxC;EACA;AACJ;AACA;EACIgB,WAAW,GAAG;IACV,OAAO,CAAC,IAAI,CAAC,CAACsD,IAAI,GAAGnE,IAAI,MAAML,KAAK;EACxC;EACA;AACJ;AACA;EACIoB,iBAAiB,GAAG;IAChB,OAAO,CAAC,IAAI,CAAC,CAACoD,IAAI,GAAGnE,IAAI,MAAMN,KAAK;EACxC;EACA;AACJ;AACA;EACIsB,aAAa,GAAG;IACZ,OAAO,CAAC,IAAI,CAAC,CAACmD,IAAI,GAAGnE,IAAI,MAAMJ,KAAK;EACxC;EACA;AACJ;AACA;EACIsB,MAAM,GAAG;IACL,OAAO,CAAC,IAAI,CAAC,CAACiD,IAAI,GAAGnE,IAAI,MAAMP,KAAK;EACxC;EACA;AACJ;AACA;EACIwB,QAAQ,GAAG;IACP,OAAO,CAAC,IAAI,CAAC,CAACkD,IAAI,GAAGnE,IAAI,MAAMD,MAAM;EACzC;EACA;AACJ;AACA;EACIe,cAAc,GAAG;IACb,OAAO,CAAC,IAAI,CAAC,CAACqD,IAAI,GAAGrE,KAAK,MAAMA,KAAK;EACzC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIwG,WAAW,GAAG;IACV,OAAO,IAAI,CAAC,CAACnC,IAAI,GAAGhE,YAAY,GAAG,IAAI,GAAGnE,SAAS;EACvD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIuK,cAAc,GAAG;IACb,OAAO,IAAI,CAAC,CAAClC,UAAU;EAC3B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACImC,cAAc,GAAG;IACb,OAAO,IAAI,CAAC,CAACxH,QAAQ;EACzB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIyH,aAAa,GAAG;IACZ,MAAMrC,QAAQ,GAAG,IAAI,CAACA,QAAQ,EAAE;IAChC,OAAOA,QAAQ,CAACsC,KAAK,CAAC,CAAC,EAAEtC,QAAQ,CAACmB,WAAW,CAAC;EAClD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIoB,WAAW,GAAG;IACV,IAAI,IAAI,CAAC,CAACtC,UAAU,EAChB,OAAO,IAAI;IACf,IAAI,CAAC,IAAI,CAAC7B,MAAM,EACZ,OAAO,KAAK;IAChB;IACA,MAAMoE,IAAI,GAAG,IAAI,CAAC,CAACzC,IAAI,GAAGnE,IAAI;IAC9B,OAAO,EAAG4G,IAAI,KAAKpH,OAAO,IAAIoH,IAAI,KAAK9G,KAAK,IACxC,IAAI,CAAC,CAACqE,IAAI,GAAG7D,WAAW,IACxB,IAAI,CAAC,CAAC6D,IAAI,GAAG9D,MAAM,CAAC;EAC5B;EACA;AACJ;AACA;AACA;EACIwG,aAAa,GAAG;IACZ,OAAO,CAAC,EAAE,IAAI,CAAC,CAAC1C,IAAI,GAAGjE,cAAc,CAAC;EAC1C;EACA;AACJ;AACA;AACA;AACA;EACI4G,QAAQ,GAAG;IACP,OAAO,CAAC,EAAE,IAAI,CAAC,CAAC3C,IAAI,GAAG9D,MAAM,CAAC;EAClC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI0G,OAAO,CAACxF,CAAC,EAAE;IACP,OAAO,CAAC,IAAI,CAACkB,MAAM,GACb,IAAI,CAAC,CAACoB,SAAS,KAAKxC,SAAS,CAACE,CAAC,CAAC,GAChC,IAAI,CAAC,CAACsC,SAAS,KAAKnC,eAAe,CAACH,CAAC,CAAC;EAChD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACUxC,QAAQ,GAAG;IAAA;IAAA;MACb,MAAMiI,MAAM,GAAG,KAAI,CAAC,CAAC3C,UAAU;MAC/B,IAAI2C,MAAM,EAAE;QACR,OAAOA,MAAM;MACjB;MACA,IAAI,CAAC,KAAI,CAACL,WAAW,EAAE,EAAE;QACrB,OAAO3K,SAAS;MACpB;MACA;MACA;MACA,IAAI,CAAC,KAAI,CAACwG,MAAM,EAAE;QACd,OAAOxG,SAAS;MACpB;MACA;MACA,IAAI;QACA,MAAMiL,IAAI,SAAS,KAAI,CAAC,CAACvE,EAAE,CAAC7D,QAAQ,CAACE,QAAQ,CAAC,KAAI,CAACgF,QAAQ,EAAE,CAAC;QAC9D,MAAMM,UAAU,GAAG,KAAI,CAAC7B,MAAM,CAACiC,OAAO,CAACwC,IAAI,CAAC;QAC5C,IAAI5C,UAAU,EAAE;UACZ,OAAQ,KAAI,CAAC,CAACA,UAAU,GAAGA,UAAU;QACzC;MACJ,CAAC,CACD,OAAO6C,EAAE,EAAE;QACP,KAAI,CAAC,CAACC,YAAY,CAACD,EAAE,CAACE,IAAI,CAAC;QAC3B,OAAOpL,SAAS;MACpB;IAAC;EACL;EACA;AACJ;AACA;EACI4C,YAAY,GAAG;IACX,MAAMoI,MAAM,GAAG,IAAI,CAAC,CAAC3C,UAAU;IAC/B,IAAI2C,MAAM,EAAE;MACR,OAAOA,MAAM;IACjB;IACA,IAAI,CAAC,IAAI,CAACL,WAAW,EAAE,EAAE;MACrB,OAAO3K,SAAS;IACpB;IACA;IACA;IACA,IAAI,CAAC,IAAI,CAACwG,MAAM,EAAE;MACd,OAAOxG,SAAS;IACpB;IACA;IACA,IAAI;MACA,MAAMiL,IAAI,GAAG,IAAI,CAAC,CAACvE,EAAE,CAAC9D,YAAY,CAAC,IAAI,CAACmF,QAAQ,EAAE,CAAC;MACnD,MAAMM,UAAU,GAAG,IAAI,CAAC7B,MAAM,CAACiC,OAAO,CAACwC,IAAI,CAAC;MAC5C,IAAI5C,UAAU,EAAE;QACZ,OAAQ,IAAI,CAAC,CAACA,UAAU,GAAGA,UAAU;MACzC;IACJ,CAAC,CACD,OAAO6C,EAAE,EAAE;MACP,IAAI,CAAC,CAACC,YAAY,CAACD,EAAE,CAACE,IAAI,CAAC;MAC3B,OAAOpL,SAAS;IACpB;EACJ;EACA,CAACqL,cAAc,CAACjD,QAAQ,EAAE;IACtB;IACA,IAAI,CAAC,CAACD,IAAI,IAAIjE,cAAc;IAC5B;IACA,KAAK,IAAIgF,CAAC,GAAGd,QAAQ,CAACmB,WAAW,EAAEL,CAAC,GAAGd,QAAQ,CAAClC,MAAM,EAAEgD,CAAC,EAAE,EAAE;MACzDd,QAAQ,CAACc,CAAC,CAAC,CAAC,CAACoC,UAAU,EAAE;IAC7B;EACJ;EACA,CAACA,UAAU,GAAG;IACV;IACA,IAAI,IAAI,CAAC,CAACnD,IAAI,GAAG9D,MAAM,EACnB;IACJ,IAAI,CAAC,CAAC8D,IAAI,GAAG,CAAC,IAAI,CAAC,CAACA,IAAI,GAAG9D,MAAM,IAAIJ,YAAY;IACjD,IAAI,CAAC,CAACsH,kBAAkB,EAAE;EAC9B;EACA,CAACA,kBAAkB,GAAG;IAClB;IACA,MAAMnD,QAAQ,GAAG,IAAI,CAACA,QAAQ,EAAE;IAChCA,QAAQ,CAACmB,WAAW,GAAG,CAAC;IACxB,KAAK,MAAML,CAAC,IAAId,QAAQ,EAAE;MACtBc,CAAC,CAAC,CAACoC,UAAU,EAAE;IACnB;EACJ;EACA,CAACE,eAAe,GAAG;IACf,IAAI,CAAC,CAACrD,IAAI,IAAI5D,WAAW;IACzB,IAAI,CAAC,CAACkH,WAAW,EAAE;EACvB;EACA;EACA,CAACA,WAAW,GAAG;IACX;IACA;IACA;IACA;IACA;IACA,IAAI,IAAI,CAAC,CAACtD,IAAI,GAAG/D,OAAO,EACpB;IACJ;IACA,IAAIsH,CAAC,GAAG,IAAI,CAAC,CAACvD,IAAI;IAClB;IACA;IACA,IAAI,CAACuD,CAAC,GAAG1H,IAAI,MAAML,KAAK,EACpB+H,CAAC,IAAIzH,YAAY;IACrB,IAAI,CAAC,CAACkE,IAAI,GAAGuD,CAAC,GAAGtH,OAAO;IACxB,IAAI,CAAC,CAACmH,kBAAkB,EAAE;EAC9B;EACA,CAACI,WAAW,CAACP,IAAI,GAAG,EAAE,EAAE;IACpB;IACA,IAAIA,IAAI,KAAK,SAAS,IAAIA,IAAI,KAAK,OAAO,EAAE;MACxC,IAAI,CAAC,CAACK,WAAW,EAAE;IACvB,CAAC,MACI,IAAIL,IAAI,KAAK,QAAQ,EAAE;MACxB,IAAI,CAAC,CAACE,UAAU,EAAE;IACtB,CAAC,MACI;MACD,IAAI,CAAClD,QAAQ,EAAE,CAACmB,WAAW,GAAG,CAAC;IACnC;EACJ;EACA,CAACqC,SAAS,CAACR,IAAI,GAAG,EAAE,EAAE;IAClB;IACA;IACA,IAAIA,IAAI,KAAK,SAAS,EAAE;MACpB;MACA,MAAMlC,CAAC,GAAG,IAAI,CAAC1C,MAAM;MACrB0C,CAAC,CAAC,CAACuC,WAAW,EAAE;IACpB,CAAC,MACI,IAAIL,IAAI,KAAK,QAAQ,EAAE;MACxB;MACA,IAAI,CAAC,CAACE,UAAU,EAAE;IACtB;EACJ;EACA,CAACH,YAAY,CAACC,IAAI,GAAG,EAAE,EAAE;IACrB,IAAIS,GAAG,GAAG,IAAI,CAAC,CAAC1D,IAAI;IACpB0D,GAAG,IAAIvH,WAAW;IAClB,IAAI8G,IAAI,KAAK,QAAQ,EACjBS,GAAG,IAAIxH,MAAM;IACjB;IACA,IAAI+G,IAAI,KAAK,QAAQ,IAAIA,IAAI,KAAK,SAAS,EAAE;MACzC;MACA;MACAS,GAAG,IAAI5H,YAAY;IACvB;IACA,IAAI,CAAC,CAACkE,IAAI,GAAG0D,GAAG;IAChB;IACA;IACA;IACA,IAAIT,IAAI,KAAK,SAAS,IAAI,IAAI,CAAC5E,MAAM,EAAE;MACnC,IAAI,CAACA,MAAM,CAAC,CAACiF,WAAW,EAAE;IAC9B;IACA;EACJ;;EACA,CAACK,eAAe,CAACC,CAAC,EAAEzG,CAAC,EAAE;IACnB,OAAQ,IAAI,CAAC,CAAC0G,wBAAwB,CAACD,CAAC,EAAEzG,CAAC,CAAC,IACxC,IAAI,CAAC,CAAC2G,kBAAkB,CAACF,CAAC,EAAEzG,CAAC,CAAC;EACtC;EACA,CAAC2G,kBAAkB,CAACF,CAAC,EAAEzG,CAAC,EAAE;IACtB;IACA,MAAM6C,IAAI,GAAGzD,SAAS,CAACqH,CAAC,CAAC;IACzB,MAAM3C,KAAK,GAAG,IAAI,CAACO,QAAQ,CAACoC,CAAC,CAAC1F,IAAI,EAAE8B,IAAI,EAAE;MAAE3B,MAAM,EAAE;IAAK,CAAC,CAAC;IAC3D,MAAMoE,IAAI,GAAGxB,KAAK,CAAC,CAACjB,IAAI,GAAGnE,IAAI;IAC/B,IAAI4G,IAAI,KAAKjH,KAAK,IAAIiH,IAAI,KAAK9G,KAAK,IAAI8G,IAAI,KAAKpH,OAAO,EAAE;MACtD4F,KAAK,CAAC,CAACjB,IAAI,IAAI/D,OAAO;IAC1B;IACAkB,CAAC,CAAC4G,OAAO,CAAC9C,KAAK,CAAC;IAChB9D,CAAC,CAACiE,WAAW,EAAE;IACf,OAAOH,KAAK;EAChB;EACA,CAAC4C,wBAAwB,CAACD,CAAC,EAAEzG,CAAC,EAAE;IAC5B,KAAK,IAAI4D,CAAC,GAAG5D,CAAC,CAACiE,WAAW,EAAEL,CAAC,GAAG5D,CAAC,CAACY,MAAM,EAAEgD,CAAC,EAAE,EAAE;MAC3C,MAAMQ,MAAM,GAAGpE,CAAC,CAAC4D,CAAC,CAAC;MACnB,MAAM7C,IAAI,GAAG,IAAI,CAACI,MAAM,GAClBf,eAAe,CAACqG,CAAC,CAAC1F,IAAI,CAAC,GACvBhB,SAAS,CAAC0G,CAAC,CAAC1F,IAAI,CAAC;MACvB,IAAIA,IAAI,KAAKqD,MAAM,CAAC,CAAC7B,SAAS,EAAE;QAC5B;MACJ;MACA,OAAO,IAAI,CAAC,CAACsE,mBAAmB,CAACJ,CAAC,EAAErC,MAAM,EAAER,CAAC,EAAE5D,CAAC,CAAC;IACrD;EACJ;EACA,CAAC6G,mBAAmB,CAACJ,CAAC,EAAE7C,CAAC,EAAEkD,KAAK,EAAE9G,CAAC,EAAE;IACjC,MAAM5E,CAAC,GAAGwI,CAAC,CAAC7C,IAAI;IAChB;IACA6C,CAAC,CAAC,CAACf,IAAI,GAAIe,CAAC,CAAC,CAACf,IAAI,GAAGlE,YAAY,GAAIS,SAAS,CAACqH,CAAC,CAAC;IACjD;IACA,IAAIrL,CAAC,KAAKqL,CAAC,CAAC1F,IAAI,EACZ6C,CAAC,CAAC7C,IAAI,GAAG0F,CAAC,CAAC1F,IAAI;IACnB;IACA;IACA,IAAI+F,KAAK,KAAK9G,CAAC,CAACiE,WAAW,EAAE;MACzB,IAAI6C,KAAK,KAAK9G,CAAC,CAACY,MAAM,GAAG,CAAC,EACtBZ,CAAC,CAAC+G,GAAG,EAAE,CAAC,KAER/G,CAAC,CAACgH,MAAM,CAACF,KAAK,EAAE,CAAC,CAAC;MACtB9G,CAAC,CAAC4G,OAAO,CAAChD,CAAC,CAAC;IAChB;IACA5D,CAAC,CAACiE,WAAW,EAAE;IACf,OAAOL,CAAC;EACZ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACUpG,KAAK,GAAG;IAAA;IAAA;MACV,IAAI,CAAC,MAAI,CAAC,CAACqF,IAAI,GAAG9D,MAAM,MAAM,CAAC,EAAE;QAC7B,IAAI;UACA,MAAI,CAAC,CAACkI,SAAS,OAAO,MAAI,CAAC,CAAC7F,EAAE,CAAC7D,QAAQ,CAACC,KAAK,CAAC,MAAI,CAACiF,QAAQ,EAAE,CAAC,CAAC;UAC/D,OAAO,MAAI;QACf,CAAC,CACD,OAAOmD,EAAE,EAAE;UACP,MAAI,CAAC,CAACU,SAAS,CAACV,EAAE,CAACE,IAAI,CAAC;QAC5B;MACJ;IAAC;EACL;EACA;AACJ;AACA;EACI3I,SAAS,GAAG;IACR,IAAI,CAAC,IAAI,CAAC,CAAC0F,IAAI,GAAG9D,MAAM,MAAM,CAAC,EAAE;MAC7B,IAAI;QACA,IAAI,CAAC,CAACkI,SAAS,CAAC,IAAI,CAAC,CAAC7F,EAAE,CAACjE,SAAS,CAAC,IAAI,CAACsF,QAAQ,EAAE,CAAC,CAAC;QACpD,OAAO,IAAI;MACf,CAAC,CACD,OAAOmD,EAAE,EAAE;QACP,IAAI,CAAC,CAACU,SAAS,CAACV,EAAE,CAACE,IAAI,CAAC;MAC5B;IACJ;EACJ;EACA,CAACmB,SAAS,CAACC,EAAE,EAAE;IACX,MAAM;MAAE/E,KAAK;MAAEJ,OAAO;MAAEO,SAAS;MAAEJ,WAAW;MAAEP,OAAO;MAAEG,MAAM;MAAEO,KAAK;MAAEJ,OAAO;MAAEZ,GAAG;MAAEI,GAAG;MAAEG,GAAG;MAAEN,IAAI;MAAEc,KAAK;MAAEJ,OAAO;MAAET,KAAK;MAAEG,IAAI;MAAEG,IAAI;MAAEL;IAAK,CAAC,GAAG0F,EAAE;IACpJ,IAAI,CAAC,CAAC/E,KAAK,GAAGA,KAAK;IACnB,IAAI,CAAC,CAACJ,OAAO,GAAGA,OAAO;IACvB,IAAI,CAAC,CAACO,SAAS,GAAGA,SAAS;IAC3B,IAAI,CAAC,CAACJ,WAAW,GAAGA,WAAW;IAC/B,IAAI,CAAC,CAACP,OAAO,GAAGA,OAAO;IACvB,IAAI,CAAC,CAACG,MAAM,GAAGA,MAAM;IACrB,IAAI,CAAC,CAACO,KAAK,GAAGA,KAAK;IACnB,IAAI,CAAC,CAACJ,OAAO,GAAGA,OAAO;IACvB,IAAI,CAAC,CAACZ,GAAG,GAAGA,GAAG;IACf,IAAI,CAAC,CAACI,GAAG,GAAGA,GAAG;IACf,IAAI,CAAC,CAACG,GAAG,GAAGA,GAAG;IACf,IAAI,CAAC,CAACN,IAAI,GAAGA,IAAI;IACjB,IAAI,CAAC,CAACc,KAAK,GAAGA,KAAK;IACnB,IAAI,CAAC,CAACJ,OAAO,GAAGA,OAAO;IACvB,IAAI,CAAC,CAACT,KAAK,GAAGA,KAAK;IACnB,IAAI,CAAC,CAACG,IAAI,GAAGA,IAAI;IACjB,IAAI,CAAC,CAACG,IAAI,GAAGA,IAAI;IACjB,IAAI,CAAC,CAACL,GAAG,GAAGA,GAAG;IACf,MAAM8D,IAAI,GAAGlG,SAAS,CAAC8H,EAAE,CAAC;IAC1B;IACA,IAAI,CAAC,CAACrE,IAAI,GAAI,IAAI,CAAC,CAACA,IAAI,GAAGlE,YAAY,GAAI2G,IAAI,GAAGzG,YAAY;IAC9D,IAAIyG,IAAI,KAAKpH,OAAO,IAAIoH,IAAI,KAAKjH,KAAK,IAAIiH,IAAI,KAAK9G,KAAK,EAAE;MACtD,IAAI,CAAC,CAACqE,IAAI,IAAI/D,OAAO;IACzB;EACJ;EACA,CAACqI,WAAW,GAAG,EAAE;EACjB,CAACC,iBAAiB,GAAG,KAAK;EAC1B,CAACC,eAAe,CAACvE,QAAQ,EAAE;IACvB,IAAI,CAAC,CAACsE,iBAAiB,GAAG,KAAK;IAC/B,MAAME,GAAG,GAAG,IAAI,CAAC,CAACH,WAAW,CAAC/B,KAAK,EAAE;IACrC,IAAI,CAAC,CAAC+B,WAAW,CAACvG,MAAM,GAAG,CAAC;IAC5B0G,GAAG,CAACC,OAAO,CAACC,EAAE,IAAIA,EAAE,CAAC,IAAI,EAAE1E,QAAQ,CAAC,CAAC;EACzC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI2E,SAAS,CAACD,EAAE,EAAEE,UAAU,GAAG,KAAK,EAAE;IAC9B,IAAI,CAAC,IAAI,CAACpD,UAAU,EAAE,EAAE;MACpB,IAAIoD,UAAU,EACVF,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,KAEbG,cAAc,CAAC,MAAMH,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;MACtC;IACJ;IACA,MAAM1E,QAAQ,GAAG,IAAI,CAACA,QAAQ,EAAE;IAChC,IAAI,IAAI,CAACyC,aAAa,EAAE,EAAE;MACtB,MAAMvF,CAAC,GAAG8C,QAAQ,CAACsC,KAAK,CAAC,CAAC,EAAEtC,QAAQ,CAACmB,WAAW,CAAC;MACjD,IAAIyD,UAAU,EACVF,EAAE,CAAC,IAAI,EAAExH,CAAC,CAAC,CAAC,KAEZ2H,cAAc,CAAC,MAAMH,EAAE,CAAC,IAAI,EAAExH,CAAC,CAAC,CAAC;MACrC;IACJ;IACA;IACA,IAAI,CAAC,CAACmH,WAAW,CAAC5C,IAAI,CAACiD,EAAE,CAAC;IAC1B,IAAI,IAAI,CAAC,CAACJ,iBAAiB,EAAE;MACzB;IACJ;IACA,IAAI,CAAC,CAACA,iBAAiB,GAAG,IAAI;IAC9B;IACA;IACA,MAAM3E,QAAQ,GAAG,IAAI,CAACA,QAAQ,EAAE;IAChC,IAAI,CAAC,CAACrB,EAAE,CAAChE,OAAO,CAACqF,QAAQ,EAAE;MAAEmF,aAAa,EAAE;IAAK,CAAC,EAAE,CAAChC,EAAE,EAAEiC,OAAO,KAAK;MACjE,IAAIjC,EAAE,EAAE;QACJ,IAAI,CAAC,CAACS,WAAW,CAACT,EAAE,CAACE,IAAI,CAAC;QAC1BhD,QAAQ,CAACmB,WAAW,GAAG,CAAC;MAC5B,CAAC,MACI;QACD;QACA;QACA,KAAK,MAAMwC,CAAC,IAAIoB,OAAO,EAAE;UACrB,IAAI,CAAC,CAACrB,eAAe,CAACC,CAAC,EAAE3D,QAAQ,CAAC;QACtC;QACA,IAAI,CAAC,CAACiD,cAAc,CAACjD,QAAQ,CAAC;MAClC;MACA,IAAI,CAAC,CAACuE,eAAe,CAACvE,QAAQ,CAACsC,KAAK,CAAC,CAAC,EAAEtC,QAAQ,CAACmB,WAAW,CAAC,CAAC;MAC9D;IACJ,CAAC,CAAC;EACN;EACA,CAAC6D,oBAAoB;EACrB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACU1K,OAAO,GAAG;IAAA;IAAA;MACZ,IAAI,CAAC,MAAI,CAACkH,UAAU,EAAE,EAAE;QACpB,OAAO,EAAE;MACb;MACA,MAAMxB,QAAQ,GAAG,MAAI,CAACA,QAAQ,EAAE;MAChC,IAAI,MAAI,CAACyC,aAAa,EAAE,EAAE;QACtB,OAAOzC,QAAQ,CAACsC,KAAK,CAAC,CAAC,EAAEtC,QAAQ,CAACmB,WAAW,CAAC;MAClD;MACA;MACA;MACA,MAAMxB,QAAQ,GAAG,MAAI,CAACA,QAAQ,EAAE;MAChC,IAAI,MAAI,CAAC,CAACqF,oBAAoB,EAAE;QAC5B,MAAM,MAAI,CAAC,CAACA,oBAAoB;MACpC,CAAC,MACI;QACD;QACA,IAAI3E,OAAO,GAAG,MAAM,CAAE,CAAC;QACvB;QACA,MAAI,CAAC,CAAC2E,oBAAoB,GAAG,IAAIC,OAAO,CAACC,GAAG,IAAK7E,OAAO,GAAG6E,GAAI,CAAC;QAChE,IAAI;UACA,KAAK,MAAMvB,CAAC,UAAU,MAAI,CAAC,CAACrF,EAAE,CAAC7D,QAAQ,CAACH,OAAO,CAACqF,QAAQ,EAAE;YACtDmF,aAAa,EAAE;UACnB,CAAC,CAAC,EAAE;YACA,MAAI,CAAC,CAACpB,eAAe,CAACC,CAAC,EAAE3D,QAAQ,CAAC;UACtC;UACA,MAAI,CAAC,CAACiD,cAAc,CAACjD,QAAQ,CAAC;QAClC,CAAC,CACD,OAAO8C,EAAE,EAAE;UACP,MAAI,CAAC,CAACS,WAAW,CAACT,EAAE,CAACE,IAAI,CAAC;UAC1BhD,QAAQ,CAACmB,WAAW,GAAG,CAAC;QAC5B;QACA,MAAI,CAAC,CAAC6D,oBAAoB,GAAGpN,SAAS;QACtCyI,OAAO,EAAE;MACb;MACA,OAAOL,QAAQ,CAACsC,KAAK,CAAC,CAAC,EAAEtC,QAAQ,CAACmB,WAAW,CAAC;IAAC;EACnD;EACA;AACJ;AACA;EACI5G,WAAW,GAAG;IACV,IAAI,CAAC,IAAI,CAACiH,UAAU,EAAE,EAAE;MACpB,OAAO,EAAE;IACb;IACA,MAAMxB,QAAQ,GAAG,IAAI,CAACA,QAAQ,EAAE;IAChC,IAAI,IAAI,CAACyC,aAAa,EAAE,EAAE;MACtB,OAAOzC,QAAQ,CAACsC,KAAK,CAAC,CAAC,EAAEtC,QAAQ,CAACmB,WAAW,CAAC;IAClD;IACA;IACA;IACA,MAAMxB,QAAQ,GAAG,IAAI,CAACA,QAAQ,EAAE;IAChC,IAAI;MACA,KAAK,MAAMgE,CAAC,IAAI,IAAI,CAAC,CAACrF,EAAE,CAAC/D,WAAW,CAACoF,QAAQ,EAAE;QAC3CmF,aAAa,EAAE;MACnB,CAAC,CAAC,EAAE;QACA,IAAI,CAAC,CAACpB,eAAe,CAACC,CAAC,EAAE3D,QAAQ,CAAC;MACtC;MACA,IAAI,CAAC,CAACiD,cAAc,CAACjD,QAAQ,CAAC;IAClC,CAAC,CACD,OAAO8C,EAAE,EAAE;MACP,IAAI,CAAC,CAACS,WAAW,CAACT,EAAE,CAACE,IAAI,CAAC;MAC1BhD,QAAQ,CAACmB,WAAW,GAAG,CAAC;IAC5B;IACA,OAAOnB,QAAQ,CAACsC,KAAK,CAAC,CAAC,EAAEtC,QAAQ,CAACmB,WAAW,CAAC;EAClD;EACAK,UAAU,GAAG;IACT,IAAI,IAAI,CAAC,CAACzB,IAAI,GAAG3D,QAAQ,EACrB,OAAO,KAAK;IAChB,MAAMoG,IAAI,GAAG5G,IAAI,GAAG,IAAI,CAAC,CAACmE,IAAI;IAC9B;IACA;IACA,IAAI,EAAEyC,IAAI,KAAKpH,OAAO,IAAIoH,IAAI,KAAKjH,KAAK,IAAIiH,IAAI,KAAK9G,KAAK,CAAC,EAAE;MACzD,OAAO,KAAK;IAChB;IACA;IACA,OAAO,IAAI;EACf;EACAyJ,UAAU,CAACC,IAAI,EAAEC,UAAU,EAAE;IACzB,OAAQ,CAAC,IAAI,CAAC,CAACtF,IAAI,GAAGxE,KAAK,MAAMA,KAAK,IAClC,EAAE,IAAI,CAAC,CAACwE,IAAI,GAAG3D,QAAQ,CAAC,IACxB,CAACgJ,IAAI,CAACE,GAAG,CAAC,IAAI,CAAC,KACd,CAACD,UAAU,IAAIA,UAAU,CAAC,IAAI,CAAC,CAAC;EACzC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACUzK,QAAQ,GAAG;IAAA;IAAA;MACb,IAAI,MAAI,CAAC,CAACA,QAAQ,EACd,OAAO,MAAI,CAAC,CAACA,QAAQ;MACzB,IAAI,CAACuB,WAAW,GAAGD,WAAW,GAAGD,MAAM,IAAI,MAAI,CAAC,CAAC8D,IAAI,EACjD,OAAOnI,SAAS;MACpB,IAAI;QACA,MAAM2N,EAAE,SAAS,MAAI,CAAC,CAACjH,EAAE,CAAC7D,QAAQ,CAACG,QAAQ,CAAC,MAAI,CAAC+E,QAAQ,EAAE,CAAC;QAC5D,OAAQ,MAAI,CAAC,CAAC/E,QAAQ,GAAG,MAAI,CAACyF,OAAO,CAACkF,EAAE,CAAC;MAC7C,CAAC,CACD,OAAOC,CAAC,EAAE;QACN,MAAI,CAAC,CAACpC,eAAe,EAAE;MAC3B;IAAC;EACL;EACA;AACJ;AACA;EACIpJ,YAAY,GAAG;IACX,IAAI,IAAI,CAAC,CAACY,QAAQ,EACd,OAAO,IAAI,CAAC,CAACA,QAAQ;IACzB,IAAI,CAACuB,WAAW,GAAGD,WAAW,GAAGD,MAAM,IAAI,IAAI,CAAC,CAAC8D,IAAI,EACjD,OAAOnI,SAAS;IACpB,IAAI;MACA,MAAM2N,EAAE,GAAG,IAAI,CAAC,CAACjH,EAAE,CAACtE,YAAY,CAAC,IAAI,CAAC2F,QAAQ,EAAE,CAAC;MACjD,OAAQ,IAAI,CAAC,CAAC/E,QAAQ,GAAG,IAAI,CAACyF,OAAO,CAACkF,EAAE,CAAC;IAC7C,CAAC,CACD,OAAOC,CAAC,EAAE;MACN,IAAI,CAAC,CAACpC,eAAe,EAAE;IAC3B;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,CAACrF,QAAQ,EAAE0H,MAAM,EAAE;IACf,IAAIA,MAAM,KAAK,IAAI,EACf;IACJ,MAAMC,OAAO,GAAG,IAAIC,GAAG,CAAC,EAAE,CAAC;IAC3B,IAAIJ,EAAE,GAAG,EAAE;IACX,IAAIzE,CAAC,GAAG,IAAI;IACZ,OAAOA,CAAC,IAAIA,CAAC,CAAC1C,MAAM,EAAE;MAClBsH,OAAO,CAACE,GAAG,CAAC9E,CAAC,CAAC;MACdA,CAAC,CAAC,CAACjB,QAAQ,GAAG0F,EAAE,CAACM,IAAI,CAAC,IAAI,CAACxE,GAAG,CAAC;MAC/BP,CAAC,CAAC,CAAChB,aAAa,GAAGyF,EAAE,CAACM,IAAI,CAAC,GAAG,CAAC;MAC/B/E,CAAC,GAAGA,CAAC,CAAC1C,MAAM;MACZmH,EAAE,CAAC9D,IAAI,CAAC,IAAI,CAAC;IACjB;IACA;IACAX,CAAC,GAAG2E,MAAM;IACV,OAAO3E,CAAC,IAAIA,CAAC,CAAC1C,MAAM,IAAI,CAACsH,OAAO,CAACJ,GAAG,CAACxE,CAAC,CAAC,EAAE;MACrCA,CAAC,CAAC,CAACjB,QAAQ,GAAGjI,SAAS;MACvBkJ,CAAC,CAAC,CAAChB,aAAa,GAAGlI,SAAS;MAC5BkJ,CAAC,GAAGA,CAAC,CAAC1C,MAAM;IAChB;EACJ;AACJ;AACAtF,OAAO,CAACS,QAAQ,GAAGA,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,MAAMD,SAAS,SAASC,QAAQ,CAAC;EAC7B;AACJ;AACA;EACI8H,GAAG,GAAG,IAAI;EACV;AACJ;AACA;EACIV,QAAQ,GAAGxF,SAAS;EACpB;AACJ;AACA;AACA;AACA;AACA;EACIsC,WAAW,CAACQ,IAAI,EAAE8B,IAAI,GAAG3E,OAAO,EAAE8C,IAAI,EAAEC,KAAK,EAAEE,MAAM,EAAE2B,QAAQ,EAAEG,IAAI,EAAE;IACnE,KAAK,CAAClC,IAAI,EAAE8B,IAAI,EAAE7B,IAAI,EAAEC,KAAK,EAAEE,MAAM,EAAE2B,QAAQ,EAAEG,IAAI,CAAC;EAC1D;EACA;AACJ;AACA;EACIoB,QAAQ,CAACtD,IAAI,EAAE8B,IAAI,GAAG3E,OAAO,EAAE+E,IAAI,GAAG,CAAC,CAAC,EAAE;IACtC,OAAO,IAAI7G,SAAS,CAAC2E,IAAI,EAAE8B,IAAI,EAAE,IAAI,CAAC7B,IAAI,EAAE,IAAI,CAACC,KAAK,EAAE,IAAI,CAACE,MAAM,EAAE,IAAI,CAAC+B,aAAa,EAAE,EAAED,IAAI,CAAC;EACpG;EACA;AACJ;AACA;EACIG,aAAa,CAACJ,IAAI,EAAE;IAChB,OAAOtG,MAAM,CAACkM,KAAK,CAACC,KAAK,CAAC7F,IAAI,CAAC,CAAChC,IAAI;EACxC;EACA;AACJ;AACA;EACI0C,OAAO,CAAC3F,QAAQ,EAAE;IACdA,QAAQ,GAAGD,UAAU,CAACC,QAAQ,CAAC+K,WAAW,EAAE,CAAC;IAC7C,IAAI/K,QAAQ,KAAK,IAAI,CAACiD,IAAI,CAACD,IAAI,EAAE;MAC7B,OAAO,IAAI,CAACC,IAAI;IACpB;IACA;IACA,KAAK,MAAM,CAAC+H,OAAO,EAAE/H,IAAI,CAAC,IAAI5G,MAAM,CAACyN,OAAO,CAAC,IAAI,CAAC5G,KAAK,CAAC,EAAE;MACtD,IAAI,IAAI,CAAC+H,QAAQ,CAACjL,QAAQ,EAAEgL,OAAO,CAAC,EAAE;QAClC,OAAQ,IAAI,CAAC9H,KAAK,CAAClD,QAAQ,CAAC,GAAGiD,IAAI;MACvC;IACJ;IACA;IACA,OAAQ,IAAI,CAACC,KAAK,CAAClD,QAAQ,CAAC,GAAG,IAAI9B,eAAe,CAAC8B,QAAQ,EAAE,IAAI,CAAC,CAACiD,IAAI;EAC3E;EACA;AACJ;AACA;EACIgI,QAAQ,CAACjL,QAAQ,EAAEgL,OAAO,GAAG,IAAI,CAAC/H,IAAI,CAACD,IAAI,EAAE;IACzC;IACA;IACA;IACAhD,QAAQ,GAAGA,QAAQ,CACd+K,WAAW,EAAE,CACb9K,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,CACpBA,OAAO,CAACH,cAAc,EAAE,MAAM,CAAC;IACpC,OAAOE,QAAQ,KAAKgL,OAAO;EAC/B;AACJ;AACAnN,OAAO,CAACQ,SAAS,GAAGA,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA,MAAMD,SAAS,SAASE,QAAQ,CAAC;EAC7B;AACJ;AACA;EACIoH,QAAQ,GAAG,GAAG;EACd;AACJ;AACA;EACIU,GAAG,GAAG,GAAG;EACT;AACJ;AACA;AACA;AACA;AACA;EACI5D,WAAW,CAACQ,IAAI,EAAE8B,IAAI,GAAG3E,OAAO,EAAE8C,IAAI,EAAEC,KAAK,EAAEE,MAAM,EAAE2B,QAAQ,EAAEG,IAAI,EAAE;IACnE,KAAK,CAAClC,IAAI,EAAE8B,IAAI,EAAE7B,IAAI,EAAEC,KAAK,EAAEE,MAAM,EAAE2B,QAAQ,EAAEG,IAAI,CAAC;EAC1D;EACA;AACJ;AACA;EACIG,aAAa,CAACJ,IAAI,EAAE;IAChB,OAAOA,IAAI,CAACiG,UAAU,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,EAAE;EAC1C;EACA;AACJ;AACA;EACIvF,OAAO,CAACwF,SAAS,EAAE;IACf,OAAO,IAAI,CAAClI,IAAI;EACpB;EACA;AACJ;AACA;EACIqD,QAAQ,CAACtD,IAAI,EAAE8B,IAAI,GAAG3E,OAAO,EAAE+E,IAAI,GAAG,CAAC,CAAC,EAAE;IACtC,OAAO,IAAI9G,SAAS,CAAC4E,IAAI,EAAE8B,IAAI,EAAE,IAAI,CAAC7B,IAAI,EAAE,IAAI,CAACC,KAAK,EAAE,IAAI,CAACE,MAAM,EAAE,IAAI,CAAC+B,aAAa,EAAE,EAAED,IAAI,CAAC;EACpG;AACJ;AACArH,OAAO,CAACO,SAAS,GAAGA,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMD,cAAc,CAAC;EACjB;AACJ;AACA;EACI8E,IAAI;EACJ;AACJ;AACA;EACIjD,QAAQ;EACR;AACJ;AACA;EACIkD,KAAK;EACL;AACJ;AACA;EACIkI,GAAG;EACH,CAACC,YAAY;EACb,CAACC,iBAAiB;EAClB,CAACvG,QAAQ;EACT;AACJ;AACA;AACA;AACA;EACI3B,MAAM;EACN,CAACC,EAAE;EACH;AACJ;AACA;AACA;AACA;AACA;AACA;EACIb,WAAW,CAAC4I,GAAG,GAAGG,OAAO,CAACH,GAAG,EAAE,EAAEI,QAAQ,EAAEpF,GAAG,EAAE;IAAEhD,MAAM;IAAEqI,iBAAiB,GAAG,EAAE,GAAG,IAAI;IAAEpI,EAAE,GAAGlE;EAAW,CAAC,GAAG,CAAC,CAAC,EAAE;IAC7G,IAAI,CAAC,CAACkE,EAAE,GAAGzD,YAAY,CAACyD,EAAE,CAAC;IAC3B,IAAI+H,GAAG,YAAYM,GAAG,IAAIN,GAAG,CAACF,UAAU,CAAC,SAAS,CAAC,EAAE;MACjDE,GAAG,GAAG,CAAC,CAAC,EAAExM,KAAK,CAAC+M,aAAa,EAAEP,GAAG,CAAC;IACvC;IACA;IACA;IACA,MAAMQ,OAAO,GAAGJ,QAAQ,CAACpG,OAAO,CAACgG,GAAG,CAAC;IACrC,IAAI,CAAClI,KAAK,GAAG7G,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;IAChC,IAAI,CAAC0D,QAAQ,GAAG,IAAI,CAAC6L,aAAa,CAACD,OAAO,CAAC;IAC3C,IAAI,CAAC,CAACP,YAAY,GAAG,IAAI7M,YAAY,EAAE;IACvC,IAAI,CAAC,CAAC8M,iBAAiB,GAAG,IAAI9M,YAAY,EAAE;IAC5C,IAAI,CAAC,CAACuG,QAAQ,GAAG,IAAIxG,aAAa,CAACkN,iBAAiB,CAAC;IACrD,MAAMhG,KAAK,GAAGmG,OAAO,CAACrG,SAAS,CAAC,IAAI,CAACvF,QAAQ,CAAC6C,MAAM,CAAC,CAAC4C,KAAK,CAACW,GAAG,CAAC;IAChE;IACA,IAAIX,KAAK,CAAC5C,MAAM,KAAK,CAAC,IAAI,CAAC4C,KAAK,CAAC,CAAC,CAAC,EAAE;MACjCA,KAAK,CAACuD,GAAG,EAAE;IACf;IACA;IACA,IAAI5F,MAAM,KAAKzG,SAAS,EAAE;MACtB,MAAM,IAAImP,SAAS,CAAC,oDAAoD,CAAC;IAC7E;IACA;IACA,IAAI,CAAC1I,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACH,IAAI,GAAG,IAAI,CAAC8I,OAAO,CAAC,IAAI,CAAC,CAAC1I,EAAE,CAAC;IAClC,IAAI,CAACH,KAAK,CAAC,IAAI,CAAClD,QAAQ,CAAC,GAAG,IAAI,CAACiD,IAAI;IACrC,IAAI+I,IAAI,GAAG,IAAI,CAAC/I,IAAI;IACpB,IAAIgJ,GAAG,GAAGxG,KAAK,CAAC5C,MAAM,GAAG,CAAC;IAC1B,MAAMqJ,OAAO,GAAGV,QAAQ,CAACpF,GAAG;IAC5B,IAAI+F,GAAG,GAAG,IAAI,CAACnM,QAAQ;IACvB,IAAIoM,QAAQ,GAAG,KAAK;IACpB,KAAK,MAAMtG,IAAI,IAAIL,KAAK,EAAE;MACtB,MAAM4G,CAAC,GAAGJ,GAAG,EAAE;MACfD,IAAI,GAAGA,IAAI,CAACjG,KAAK,CAACD,IAAI,EAAE;QACpBlB,QAAQ,EAAE,IAAI0H,KAAK,CAACD,CAAC,CAAC,CAACE,IAAI,CAAC,IAAI,CAAC,CAAC3B,IAAI,CAACsB,OAAO,CAAC;QAC/CrH,aAAa,EAAE,IAAIyH,KAAK,CAACD,CAAC,CAAC,CAACE,IAAI,CAAC,IAAI,CAAC,CAAC3B,IAAI,CAAC,GAAG,CAAC;QAChDlG,QAAQ,EAAGyH,GAAG,IAAI,CAACC,QAAQ,GAAG,EAAE,GAAGF,OAAO,IAAIpG;MAClD,CAAC,CAAC;MACFsG,QAAQ,GAAG,IAAI;IACnB;IACA,IAAI,CAAChB,GAAG,GAAGY,IAAI;EACnB;EACA;AACJ;AACA;EACIvH,KAAK,CAACQ,IAAI,GAAG,IAAI,CAACmG,GAAG,EAAE;IACnB,IAAI,OAAOnG,IAAI,KAAK,QAAQ,EAAE;MAC1BA,IAAI,GAAG,IAAI,CAACmG,GAAG,CAAChG,OAAO,CAACH,IAAI,CAAC;IACjC;IACA,OAAOA,IAAI,CAACR,KAAK,EAAE;EACvB;EACA;AACJ;AACA;AACA;AACA;AACA;EACIU,aAAa,GAAG;IACZ,OAAO,IAAI,CAAC,CAACJ,QAAQ;EACzB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIK,OAAO,CAAC,GAAGoH,KAAK,EAAE;IACd;IACA;IACA,IAAIC,CAAC,GAAG,EAAE;IACV,KAAK,IAAIC,CAAC,GAAGF,KAAK,CAAC3J,MAAM,GAAG,CAAC,EAAE6J,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MACxC,MAAM7G,CAAC,GAAG2G,KAAK,CAACE,CAAC,CAAC;MAClB,IAAI,CAAC7G,CAAC,IAAIA,CAAC,KAAK,GAAG,EACf;MACJ4G,CAAC,GAAGA,CAAC,GAAI,GAAE5G,CAAE,IAAG4G,CAAE,EAAC,GAAG5G,CAAC;MACvB,IAAI,IAAI,CAAC8G,UAAU,CAAC9G,CAAC,CAAC,EAAE;QACpB;MACJ;IACJ;IACA,MAAMG,MAAM,GAAG,IAAI,CAAC,CAACqF,YAAY,CAACnO,GAAG,CAACuP,CAAC,CAAC;IACxC,IAAIzG,MAAM,KAAKrJ,SAAS,EAAE;MACtB,OAAOqJ,MAAM;IACjB;IACA,MAAMvI,MAAM,GAAG,IAAI,CAAC2N,GAAG,CAAChG,OAAO,CAACqH,CAAC,CAAC,CAAC/H,QAAQ,EAAE;IAC7C,IAAI,CAAC,CAAC2G,YAAY,CAAClJ,GAAG,CAACsK,CAAC,EAAEhP,MAAM,CAAC;IACjC,OAAOA,MAAM;EACjB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACImP,YAAY,CAAC,GAAGJ,KAAK,EAAE;IACnB;IACA;IACA,IAAIC,CAAC,GAAG,EAAE;IACV,KAAK,IAAIC,CAAC,GAAGF,KAAK,CAAC3J,MAAM,GAAG,CAAC,EAAE6J,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MACxC,MAAM7G,CAAC,GAAG2G,KAAK,CAACE,CAAC,CAAC;MAClB,IAAI,CAAC7G,CAAC,IAAIA,CAAC,KAAK,GAAG,EACf;MACJ4G,CAAC,GAAGA,CAAC,GAAI,GAAE5G,CAAE,IAAG4G,CAAE,EAAC,GAAG5G,CAAC;MACvB,IAAI,IAAI,CAAC8G,UAAU,CAAC9G,CAAC,CAAC,EAAE;QACpB;MACJ;IACJ;IACA,MAAMG,MAAM,GAAG,IAAI,CAAC,CAACsF,iBAAiB,CAACpO,GAAG,CAACuP,CAAC,CAAC;IAC7C,IAAIzG,MAAM,KAAKrJ,SAAS,EAAE;MACtB,OAAOqJ,MAAM;IACjB;IACA,MAAMvI,MAAM,GAAG,IAAI,CAAC2N,GAAG,CAAChG,OAAO,CAACqH,CAAC,CAAC,CAAC9H,aAAa,EAAE;IAClD,IAAI,CAAC,CAAC2G,iBAAiB,CAACnJ,GAAG,CAACsK,CAAC,EAAEhP,MAAM,CAAC;IACtC,OAAOA,MAAM;EACjB;EACA;AACJ;AACA;EACImH,QAAQ,CAACiI,KAAK,GAAG,IAAI,CAACzB,GAAG,EAAE;IACvB,IAAI,OAAOyB,KAAK,KAAK,QAAQ,EAAE;MAC3BA,KAAK,GAAG,IAAI,CAACzB,GAAG,CAAChG,OAAO,CAACyH,KAAK,CAAC;IACnC;IACA,OAAOA,KAAK,CAACjI,QAAQ,EAAE;EAC3B;EACA;AACJ;AACA;AACA;EACIC,aAAa,CAACgI,KAAK,GAAG,IAAI,CAACzB,GAAG,EAAE;IAC5B,IAAI,OAAOyB,KAAK,KAAK,QAAQ,EAAE;MAC3BA,KAAK,GAAG,IAAI,CAACzB,GAAG,CAAChG,OAAO,CAACyH,KAAK,CAAC;IACnC;IACA,OAAOA,KAAK,CAAChI,aAAa,EAAE;EAChC;EACA;AACJ;AACA;EACIiI,QAAQ,CAACD,KAAK,GAAG,IAAI,CAACzB,GAAG,EAAE;IACvB,IAAI,OAAOyB,KAAK,KAAK,QAAQ,EAAE;MAC3BA,KAAK,GAAG,IAAI,CAACzB,GAAG,CAAChG,OAAO,CAACyH,KAAK,CAAC;IACnC;IACA,OAAOA,KAAK,CAAC7J,IAAI;EACrB;EACA;AACJ;AACA;EACI+J,OAAO,CAACF,KAAK,GAAG,IAAI,CAACzB,GAAG,EAAE;IACtB,IAAI,OAAOyB,KAAK,KAAK,QAAQ,EAAE;MAC3BA,KAAK,GAAG,IAAI,CAACzB,GAAG,CAAChG,OAAO,CAACyH,KAAK,CAAC;IACnC;IACA,OAAO,CAACA,KAAK,CAAC1J,MAAM,IAAI0J,KAAK,EAAEnI,QAAQ,EAAE;EAC7C;EACMrF,OAAO,CAACwN,KAAK,GAAG,IAAI,CAACzB,GAAG,EAAElG,IAAI,GAAG;IACnC2E,aAAa,EAAE;EACnB,CAAC,EAAE;IAAA;IAAA;MACC,IAAI,OAAOgD,KAAK,KAAK,QAAQ,EAAE;QAC3BA,KAAK,GAAG,MAAI,CAACzB,GAAG,CAAChG,OAAO,CAACyH,KAAK,CAAC;MACnC,CAAC,MACI,IAAI,EAAEA,KAAK,YAAYvO,QAAQ,CAAC,EAAE;QACnC4G,IAAI,GAAG2H,KAAK;QACZA,KAAK,GAAG,MAAI,CAACzB,GAAG;MACpB;MACA,MAAM;QAAEvB;MAAc,CAAC,GAAG3E,IAAI;MAC9B,IAAI,CAAC2H,KAAK,CAACtG,UAAU,EAAE,EAAE;QACrB,OAAO,EAAE;MACb,CAAC,MACI;QACD,MAAMV,CAAC,SAASgH,KAAK,CAACxN,OAAO,EAAE;QAC/B,OAAOwK,aAAa,GAAGhE,CAAC,GAAGA,CAAC,CAACmH,GAAG,CAACtE,CAAC,IAAIA,CAAC,CAAC1F,IAAI,CAAC;MACjD;IAAC;EACL;EACA1D,WAAW,CAACuN,KAAK,GAAG,IAAI,CAACzB,GAAG,EAAElG,IAAI,GAAG;IACjC2E,aAAa,EAAE;EACnB,CAAC,EAAE;IACC,IAAI,OAAOgD,KAAK,KAAK,QAAQ,EAAE;MAC3BA,KAAK,GAAG,IAAI,CAACzB,GAAG,CAAChG,OAAO,CAACyH,KAAK,CAAC;IACnC,CAAC,MACI,IAAI,EAAEA,KAAK,YAAYvO,QAAQ,CAAC,EAAE;MACnC4G,IAAI,GAAG2H,KAAK;MACZA,KAAK,GAAG,IAAI,CAACzB,GAAG;IACpB;IACA,MAAM;MAAEvB,aAAa,GAAG;IAAK,CAAC,GAAG3E,IAAI;IACrC,IAAI,CAAC2H,KAAK,CAACtG,UAAU,EAAE,EAAE;MACrB,OAAO,EAAE;IACb,CAAC,MACI,IAAIsD,aAAa,EAAE;MACpB,OAAOgD,KAAK,CAACvN,WAAW,EAAE;IAC9B,CAAC,MACI;MACD,OAAOuN,KAAK,CAACvN,WAAW,EAAE,CAAC0N,GAAG,CAACtE,CAAC,IAAIA,CAAC,CAAC1F,IAAI,CAAC;IAC/C;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACUvD,KAAK,CAACoN,KAAK,GAAG,IAAI,CAACzB,GAAG,EAAE;IAAA;IAAA;MAC1B,IAAI,OAAOyB,KAAK,KAAK,QAAQ,EAAE;QAC3BA,KAAK,GAAG,MAAI,CAACzB,GAAG,CAAChG,OAAO,CAACyH,KAAK,CAAC;MACnC;MACA,OAAOA,KAAK,CAACpN,KAAK,EAAE;IAAC;EACzB;EACA;AACJ;AACA;EACIL,SAAS,CAACyN,KAAK,GAAG,IAAI,CAACzB,GAAG,EAAE;IACxB,IAAI,OAAOyB,KAAK,KAAK,QAAQ,EAAE;MAC3BA,KAAK,GAAG,IAAI,CAACzB,GAAG,CAAChG,OAAO,CAACyH,KAAK,CAAC;IACnC;IACA,OAAOA,KAAK,CAACzN,SAAS,EAAE;EAC5B;EACMM,QAAQ,CAACmN,KAAK,GAAG,IAAI,CAACzB,GAAG,EAAE;IAAEvB;EAAc,CAAC,GAAG;IACjDA,aAAa,EAAE;EACnB,CAAC,EAAE;IAAA;IAAA;MACC,IAAI,OAAOgD,KAAK,KAAK,QAAQ,EAAE;QAC3BA,KAAK,GAAG,MAAI,CAACzB,GAAG,CAAChG,OAAO,CAACyH,KAAK,CAAC;MACnC,CAAC,MACI,IAAI,EAAEA,KAAK,YAAYvO,QAAQ,CAAC,EAAE;QACnCuL,aAAa,GAAGgD,KAAK,CAAChD,aAAa;QACnCgD,KAAK,GAAG,MAAI,CAACzB,GAAG;MACpB;MACA,MAAM1C,CAAC,SAASmE,KAAK,CAACnN,QAAQ,EAAE;MAChC,OAAOmK,aAAa,GAAGnB,CAAC,GAAGA,CAAC,EAAEhE,QAAQ,EAAE;IAAC;EAC7C;EACAnF,YAAY,CAACsN,KAAK,GAAG,IAAI,CAACzB,GAAG,EAAE;IAAEvB;EAAc,CAAC,GAAG;IAC/CA,aAAa,EAAE;EACnB,CAAC,EAAE;IACC,IAAI,OAAOgD,KAAK,KAAK,QAAQ,EAAE;MAC3BA,KAAK,GAAG,IAAI,CAACzB,GAAG,CAAChG,OAAO,CAACyH,KAAK,CAAC;IACnC,CAAC,MACI,IAAI,EAAEA,KAAK,YAAYvO,QAAQ,CAAC,EAAE;MACnCuL,aAAa,GAAGgD,KAAK,CAAChD,aAAa;MACnCgD,KAAK,GAAG,IAAI,CAACzB,GAAG;IACpB;IACA,MAAM1C,CAAC,GAAGmE,KAAK,CAACtN,YAAY,EAAE;IAC9B,OAAOsK,aAAa,GAAGnB,CAAC,GAAGA,CAAC,EAAEhE,QAAQ,EAAE;EAC5C;EACM/E,QAAQ,CAACkN,KAAK,GAAG,IAAI,CAACzB,GAAG,EAAE;IAAEvB;EAAc,CAAC,GAAG;IACjDA,aAAa,EAAE;EACnB,CAAC,EAAE;IAAA;IAAA;MACC,IAAI,OAAOgD,KAAK,KAAK,QAAQ,EAAE;QAC3BA,KAAK,GAAG,MAAI,CAACzB,GAAG,CAAChG,OAAO,CAACyH,KAAK,CAAC;MACnC,CAAC,MACI,IAAI,EAAEA,KAAK,YAAYvO,QAAQ,CAAC,EAAE;QACnCuL,aAAa,GAAGgD,KAAK,CAAChD,aAAa;QACnCgD,KAAK,GAAG,MAAI,CAACzB,GAAG;MACpB;MACA,MAAM1C,CAAC,SAASmE,KAAK,CAAClN,QAAQ,EAAE;MAChC,OAAOkK,aAAa,GAAGnB,CAAC,GAAGA,CAAC,EAAEhE,QAAQ,EAAE;IAAC;EAC7C;EACA3F,YAAY,CAAC8N,KAAK,GAAG,IAAI,CAACzB,GAAG,EAAE;IAAEvB;EAAc,CAAC,GAAG;IAC/CA,aAAa,EAAE;EACnB,CAAC,EAAE;IACC,IAAI,OAAOgD,KAAK,KAAK,QAAQ,EAAE;MAC3BA,KAAK,GAAG,IAAI,CAACzB,GAAG,CAAChG,OAAO,CAACyH,KAAK,CAAC;IACnC,CAAC,MACI,IAAI,EAAEA,KAAK,YAAYvO,QAAQ,CAAC,EAAE;MACnCuL,aAAa,GAAGgD,KAAK,CAAChD,aAAa;MACnCgD,KAAK,GAAG,IAAI,CAACzB,GAAG;IACpB;IACA,MAAM1C,CAAC,GAAGmE,KAAK,CAAC9N,YAAY,EAAE;IAC9B,OAAO8K,aAAa,GAAGnB,CAAC,GAAGA,CAAC,EAAEhE,QAAQ,EAAE;EAC5C;EACMuI,IAAI,CAACJ,KAAK,GAAG,IAAI,CAACzB,GAAG,EAAElG,IAAI,GAAG,CAAC,CAAC,EAAE;IAAA;IAAA;MACpC,IAAI,OAAO2H,KAAK,KAAK,QAAQ,EAAE;QAC3BA,KAAK,GAAG,MAAI,CAACzB,GAAG,CAAChG,OAAO,CAACyH,KAAK,CAAC;MACnC,CAAC,MACI,IAAI,EAAEA,KAAK,YAAYvO,QAAQ,CAAC,EAAE;QACnC4G,IAAI,GAAG2H,KAAK;QACZA,KAAK,GAAG,MAAI,CAACzB,GAAG;MACpB;MACA,MAAM;QAAEvB,aAAa,GAAG,IAAI;QAAEqD,MAAM,GAAG,KAAK;QAAEC,MAAM;QAAE/C;MAAY,CAAC,GAAGlF,IAAI;MAC1E,MAAMkI,OAAO,GAAG,EAAE;MAClB,IAAI,CAACD,MAAM,IAAIA,MAAM,CAACN,KAAK,CAAC,EAAE;QAC1BO,OAAO,CAAC5G,IAAI,CAACqD,aAAa,GAAGgD,KAAK,GAAGA,KAAK,CAACnI,QAAQ,EAAE,CAAC;MAC1D;MACA,MAAMyF,IAAI,GAAG,IAAIO,GAAG,EAAE;MACtB,MAAMuC,IAAI,GAAG,CAAC3H,GAAG,EAAEmE,EAAE,KAAK;QACtBU,IAAI,CAACQ,GAAG,CAACrF,GAAG,CAAC;QACbA,GAAG,CAACoE,SAAS,CAAC,CAAC7B,EAAE,EAAEiC,OAAO,KAAK;UAC3B;UACA,IAAIjC,EAAE,EAAE;YACJ,OAAO4B,EAAE,CAAC5B,EAAE,CAAC;UACjB;UACA;UACA,IAAIoE,GAAG,GAAGnC,OAAO,CAACjH,MAAM;UACxB,IAAI,CAACoJ,GAAG,EACJ,OAAOxC,EAAE,EAAE;UACf,MAAM4D,IAAI,GAAG,MAAM;YACf,IAAI,EAAEpB,GAAG,KAAK,CAAC,EAAE;cACbxC,EAAE,EAAE;YACR;UACJ,CAAC;UACD,KAAK,MAAMf,CAAC,IAAIoB,OAAO,EAAE;YACrB,IAAI,CAACqD,MAAM,IAAIA,MAAM,CAACzE,CAAC,CAAC,EAAE;cACtB0E,OAAO,CAAC5G,IAAI,CAACqD,aAAa,GAAGnB,CAAC,GAAGA,CAAC,CAAChE,QAAQ,EAAE,CAAC;YAClD;YACA,IAAIwI,MAAM,IAAIxE,CAAC,CAACjH,cAAc,EAAE,EAAE;cAC9BiH,CAAC,CAAC/I,QAAQ,EAAE,CACP2N,IAAI,CAACb,CAAC,IAAKA,CAAC,EAAE3F,SAAS,EAAE,GAAG2F,CAAC,CAAChN,KAAK,EAAE,GAAGgN,CAAE,CAAC,CAC3Ca,IAAI,CAACb,CAAC,IAAIA,CAAC,EAAEvC,UAAU,CAACC,IAAI,EAAEC,UAAU,CAAC,GAAG6C,IAAI,CAACR,CAAC,EAAEY,IAAI,CAAC,GAAGA,IAAI,EAAE,CAAC;YAC5E,CAAC,MACI;cACD,IAAI3E,CAAC,CAACwB,UAAU,CAACC,IAAI,EAAEC,UAAU,CAAC,EAAE;gBAChC6C,IAAI,CAACvE,CAAC,EAAE2E,IAAI,CAAC;cACjB,CAAC,MACI;gBACDA,IAAI,EAAE;cACV;YACJ;UACJ;QACJ,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;MACd,CAAC;;MACD,MAAME,KAAK,GAAGV,KAAK;MACnB,OAAO,IAAI7C,OAAO,CAAC,CAACC,GAAG,EAAEuD,GAAG,KAAK;QAC7BP,IAAI,CAACM,KAAK,EAAE1F,EAAE,IAAI;UACd;UACA,IAAIA,EAAE,EACF,OAAO2F,GAAG,CAAC3F,EAAE,CAAC;UAClB;UACAoC,GAAG,CAACmD,OAAO,CAAC;QAChB,CAAC,CAAC;MACN,CAAC,CAAC;IAAC;EACP;EACAK,QAAQ,CAACZ,KAAK,GAAG,IAAI,CAACzB,GAAG,EAAElG,IAAI,GAAG,CAAC,CAAC,EAAE;IAClC,IAAI,OAAO2H,KAAK,KAAK,QAAQ,EAAE;MAC3BA,KAAK,GAAG,IAAI,CAACzB,GAAG,CAAChG,OAAO,CAACyH,KAAK,CAAC;IACnC,CAAC,MACI,IAAI,EAAEA,KAAK,YAAYvO,QAAQ,CAAC,EAAE;MACnC4G,IAAI,GAAG2H,KAAK;MACZA,KAAK,GAAG,IAAI,CAACzB,GAAG;IACpB;IACA,MAAM;MAAEvB,aAAa,GAAG,IAAI;MAAEqD,MAAM,GAAG,KAAK;MAAEC,MAAM;MAAE/C;IAAY,CAAC,GAAGlF,IAAI;IAC1E,MAAMkI,OAAO,GAAG,EAAE;IAClB,IAAI,CAACD,MAAM,IAAIA,MAAM,CAACN,KAAK,CAAC,EAAE;MAC1BO,OAAO,CAAC5G,IAAI,CAACqD,aAAa,GAAGgD,KAAK,GAAGA,KAAK,CAACnI,QAAQ,EAAE,CAAC;IAC1D;IACA,MAAMyF,IAAI,GAAG,IAAIO,GAAG,CAAC,CAACmC,KAAK,CAAC,CAAC;IAC7B,KAAK,MAAMvH,GAAG,IAAI6E,IAAI,EAAE;MACpB,MAAML,OAAO,GAAGxE,GAAG,CAAChG,WAAW,EAAE;MACjC,KAAK,MAAMoJ,CAAC,IAAIoB,OAAO,EAAE;QACrB,IAAI,CAACqD,MAAM,IAAIA,MAAM,CAACzE,CAAC,CAAC,EAAE;UACtB0E,OAAO,CAAC5G,IAAI,CAACqD,aAAa,GAAGnB,CAAC,GAAGA,CAAC,CAAChE,QAAQ,EAAE,CAAC;QAClD;QACA,IAAI+H,CAAC,GAAG/D,CAAC;QACT,IAAIA,CAAC,CAACjH,cAAc,EAAE,EAAE;UACpB,IAAI,EAAEyL,MAAM,KAAKT,CAAC,GAAG/D,CAAC,CAAC3J,YAAY,EAAE,CAAC,CAAC,EACnC;UACJ,IAAI0N,CAAC,CAAC3F,SAAS,EAAE,EACb2F,CAAC,CAACrN,SAAS,EAAE;QACrB;QACA,IAAIqN,CAAC,CAACvC,UAAU,CAACC,IAAI,EAAEC,UAAU,CAAC,EAAE;UAChCD,IAAI,CAACQ,GAAG,CAAC8B,CAAC,CAAC;QACf;MACJ;IACJ;IACA,OAAOW,OAAO;EAClB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,CAACrK,MAAM,CAAC2K,aAAa,IAAI;IACrB,OAAO,IAAI,CAACC,OAAO,EAAE;EACzB;EACAA,OAAO,CAACd,KAAK,GAAG,IAAI,CAACzB,GAAG,EAAEwC,OAAO,GAAG,CAAC,CAAC,EAAE;IACpC;IACA;IACA;IACA,IAAI,OAAOf,KAAK,KAAK,QAAQ,EAAE;MAC3BA,KAAK,GAAG,IAAI,CAACzB,GAAG,CAAChG,OAAO,CAACyH,KAAK,CAAC;IACnC,CAAC,MACI,IAAI,EAAEA,KAAK,YAAYvO,QAAQ,CAAC,EAAE;MACnCsP,OAAO,GAAGf,KAAK;MACfA,KAAK,GAAG,IAAI,CAACzB,GAAG;IACpB;IACA,OAAO,IAAI,CAACyC,MAAM,CAAChB,KAAK,EAAEe,OAAO,CAAC,CAAC7K,MAAM,CAAC2K,aAAa,CAAC,EAAE;EAC9D;EACA;AACJ;AACA;AACA;AACA;EACI,CAAC3K,MAAM,CAAC+K,QAAQ,IAAI;IAChB,OAAO,IAAI,CAACC,WAAW,EAAE;EAC7B;EACA,CAACA,WAAW,CAAClB,KAAK,GAAG,IAAI,CAACzB,GAAG,EAAElG,IAAI,GAAG,CAAC,CAAC,EAAE;IACtC,IAAI,OAAO2H,KAAK,KAAK,QAAQ,EAAE;MAC3BA,KAAK,GAAG,IAAI,CAACzB,GAAG,CAAChG,OAAO,CAACyH,KAAK,CAAC;IACnC,CAAC,MACI,IAAI,EAAEA,KAAK,YAAYvO,QAAQ,CAAC,EAAE;MACnC4G,IAAI,GAAG2H,KAAK;MACZA,KAAK,GAAG,IAAI,CAACzB,GAAG;IACpB;IACA,MAAM;MAAEvB,aAAa,GAAG,IAAI;MAAEqD,MAAM,GAAG,KAAK;MAAEC,MAAM;MAAE/C;IAAY,CAAC,GAAGlF,IAAI;IAC1E,IAAI,CAACiI,MAAM,IAAIA,MAAM,CAACN,KAAK,CAAC,EAAE;MAC1B,MAAMhD,aAAa,GAAGgD,KAAK,GAAGA,KAAK,CAACnI,QAAQ,EAAE;IAClD;IACA,MAAMyF,IAAI,GAAG,IAAIO,GAAG,CAAC,CAACmC,KAAK,CAAC,CAAC;IAC7B,KAAK,MAAMvH,GAAG,IAAI6E,IAAI,EAAE;MACpB,MAAML,OAAO,GAAGxE,GAAG,CAAChG,WAAW,EAAE;MACjC,KAAK,MAAMoJ,CAAC,IAAIoB,OAAO,EAAE;QACrB,IAAI,CAACqD,MAAM,IAAIA,MAAM,CAACzE,CAAC,CAAC,EAAE;UACtB,MAAMmB,aAAa,GAAGnB,CAAC,GAAGA,CAAC,CAAChE,QAAQ,EAAE;QAC1C;QACA,IAAI+H,CAAC,GAAG/D,CAAC;QACT,IAAIA,CAAC,CAACjH,cAAc,EAAE,EAAE;UACpB,IAAI,EAAEyL,MAAM,KAAKT,CAAC,GAAG/D,CAAC,CAAC3J,YAAY,EAAE,CAAC,CAAC,EACnC;UACJ,IAAI0N,CAAC,CAAC3F,SAAS,EAAE,EACb2F,CAAC,CAACrN,SAAS,EAAE;QACrB;QACA,IAAIqN,CAAC,CAACvC,UAAU,CAACC,IAAI,EAAEC,UAAU,CAAC,EAAE;UAChCD,IAAI,CAACQ,GAAG,CAAC8B,CAAC,CAAC;QACf;MACJ;IACJ;EACJ;EACAoB,MAAM,CAAChB,KAAK,GAAG,IAAI,CAACzB,GAAG,EAAElG,IAAI,GAAG,CAAC,CAAC,EAAE;IAChC,IAAI,OAAO2H,KAAK,KAAK,QAAQ,EAAE;MAC3BA,KAAK,GAAG,IAAI,CAACzB,GAAG,CAAChG,OAAO,CAACyH,KAAK,CAAC;IACnC,CAAC,MACI,IAAI,EAAEA,KAAK,YAAYvO,QAAQ,CAAC,EAAE;MACnC4G,IAAI,GAAG2H,KAAK;MACZA,KAAK,GAAG,IAAI,CAACzB,GAAG;IACpB;IACA,MAAM;MAAEvB,aAAa,GAAG,IAAI;MAAEqD,MAAM,GAAG,KAAK;MAAEC,MAAM;MAAE/C;IAAY,CAAC,GAAGlF,IAAI;IAC1E,MAAMkI,OAAO,GAAG,IAAIlO,UAAU,CAAC8O,QAAQ,CAAC;MAAEC,UAAU,EAAE;IAAK,CAAC,CAAC;IAC7D,IAAI,CAACd,MAAM,IAAIA,MAAM,CAACN,KAAK,CAAC,EAAE;MAC1BO,OAAO,CAACc,KAAK,CAACrE,aAAa,GAAGgD,KAAK,GAAGA,KAAK,CAACnI,QAAQ,EAAE,CAAC;IAC3D;IACA,MAAMyF,IAAI,GAAG,IAAIO,GAAG,EAAE;IACtB,MAAMyD,KAAK,GAAG,CAACtB,KAAK,CAAC;IACrB,IAAIuB,UAAU,GAAG,CAAC;IAClB,MAAM7C,OAAO,GAAG,MAAM;MAClB,IAAI8C,MAAM,GAAG,KAAK;MAClB,OAAO,CAACA,MAAM,EAAE;QACZ,MAAM/I,GAAG,GAAG6I,KAAK,CAACG,KAAK,EAAE;QACzB,IAAI,CAAChJ,GAAG,EAAE;UACN,IAAI8I,UAAU,KAAK,CAAC,EAChBhB,OAAO,CAACmB,GAAG,EAAE;UACjB;QACJ;QACAH,UAAU,EAAE;QACZjE,IAAI,CAACQ,GAAG,CAACrF,GAAG,CAAC;QACb,MAAMkJ,SAAS,GAAG,CAAC3G,EAAE,EAAEiC,OAAO,EAAE2E,YAAY,GAAG,KAAK,KAAK;UACrD;UACA,IAAI5G,EAAE,EACF,OAAOuF,OAAO,CAACsB,IAAI,CAAC,OAAO,EAAE7G,EAAE,CAAC;UACpC;UACA,IAAIqF,MAAM,IAAI,CAACuB,YAAY,EAAE;YACzB,MAAMjP,QAAQ,GAAG,EAAE;YACnB,KAAK,MAAMkJ,CAAC,IAAIoB,OAAO,EAAE;cACrB,IAAIpB,CAAC,CAACjH,cAAc,EAAE,EAAE;gBACpBjC,QAAQ,CAACgH,IAAI,CAACkC,CAAC,CACV/I,QAAQ,EAAE,CACV2N,IAAI,CAAEb,CAAC,IAAKA,CAAC,EAAE3F,SAAS,EAAE,GAAG2F,CAAC,CAAChN,KAAK,EAAE,GAAGgN,CAAC,CAAC,CAAC;cACrD;YACJ;YACA,IAAIjN,QAAQ,CAACqD,MAAM,EAAE;cACjBmH,OAAO,CAAC2E,GAAG,CAACnP,QAAQ,CAAC,CAAC8N,IAAI,CAAC,MAAMkB,SAAS,CAAC,IAAI,EAAE1E,OAAO,EAAE,IAAI,CAAC,CAAC;cAChE;YACJ;UACJ;UACA,KAAK,MAAMpB,CAAC,IAAIoB,OAAO,EAAE;YACrB,IAAIpB,CAAC,KAAK,CAACyE,MAAM,IAAIA,MAAM,CAACzE,CAAC,CAAC,CAAC,EAAE;cAC7B,IAAI,CAAC0E,OAAO,CAACc,KAAK,CAACrE,aAAa,GAAGnB,CAAC,GAAGA,CAAC,CAAChE,QAAQ,EAAE,CAAC,EAAE;gBAClD2J,MAAM,GAAG,IAAI;cACjB;YACJ;UACJ;UACAD,UAAU,EAAE;UACZ,KAAK,MAAM1F,CAAC,IAAIoB,OAAO,EAAE;YACrB,MAAM2C,CAAC,GAAG/D,CAAC,CAACvB,cAAc,EAAE,IAAIuB,CAAC;YACjC,IAAI+D,CAAC,CAACvC,UAAU,CAACC,IAAI,EAAEC,UAAU,CAAC,EAAE;cAChC+D,KAAK,CAAC3H,IAAI,CAACiG,CAAC,CAAC;YACjB;UACJ;UACA,IAAI4B,MAAM,IAAI,CAACjB,OAAO,CAACwB,OAAO,EAAE;YAC5BxB,OAAO,CAACyB,IAAI,CAAC,OAAO,EAAEtD,OAAO,CAAC;UAClC,CAAC,MACI,IAAI,CAACuD,IAAI,EAAE;YACZvD,OAAO,EAAE;UACb;QACJ,CAAC;QACD;QACA,IAAIuD,IAAI,GAAG,IAAI;QACfxJ,GAAG,CAACoE,SAAS,CAAC8E,SAAS,EAAE,IAAI,CAAC;QAC9BM,IAAI,GAAG,KAAK;MAChB;IACJ,CAAC;IACDvD,OAAO,EAAE;IACT,OAAO6B,OAAO;EAClB;EACA2B,UAAU,CAAClC,KAAK,GAAG,IAAI,CAACzB,GAAG,EAAElG,IAAI,GAAG,CAAC,CAAC,EAAE;IACpC,IAAI,OAAO2H,KAAK,KAAK,QAAQ,EAAE;MAC3BA,KAAK,GAAG,IAAI,CAACzB,GAAG,CAAChG,OAAO,CAACyH,KAAK,CAAC;IACnC,CAAC,MACI,IAAI,EAAEA,KAAK,YAAYvO,QAAQ,CAAC,EAAE;MACnC4G,IAAI,GAAG2H,KAAK;MACZA,KAAK,GAAG,IAAI,CAACzB,GAAG;IACpB;IACA,MAAM;MAAEvB,aAAa,GAAG,IAAI;MAAEqD,MAAM,GAAG,KAAK;MAAEC,MAAM;MAAE/C;IAAY,CAAC,GAAGlF,IAAI;IAC1E,MAAMkI,OAAO,GAAG,IAAIlO,UAAU,CAAC8O,QAAQ,CAAC;MAAEC,UAAU,EAAE;IAAK,CAAC,CAAC;IAC7D,MAAM9D,IAAI,GAAG,IAAIO,GAAG,EAAE;IACtB,IAAI,CAACyC,MAAM,IAAIA,MAAM,CAACN,KAAK,CAAC,EAAE;MAC1BO,OAAO,CAACc,KAAK,CAACrE,aAAa,GAAGgD,KAAK,GAAGA,KAAK,CAACnI,QAAQ,EAAE,CAAC;IAC3D;IACA,MAAMyJ,KAAK,GAAG,CAACtB,KAAK,CAAC;IACrB,IAAIuB,UAAU,GAAG,CAAC;IAClB,MAAM7C,OAAO,GAAG,MAAM;MAClB,IAAI8C,MAAM,GAAG,KAAK;MAClB,OAAO,CAACA,MAAM,EAAE;QACZ,MAAM/I,GAAG,GAAG6I,KAAK,CAACG,KAAK,EAAE;QACzB,IAAI,CAAChJ,GAAG,EAAE;UACN,IAAI8I,UAAU,KAAK,CAAC,EAChBhB,OAAO,CAACmB,GAAG,EAAE;UACjB;QACJ;QACAH,UAAU,EAAE;QACZjE,IAAI,CAACQ,GAAG,CAACrF,GAAG,CAAC;QACb,MAAMwE,OAAO,GAAGxE,GAAG,CAAChG,WAAW,EAAE;QACjC,KAAK,MAAMoJ,CAAC,IAAIoB,OAAO,EAAE;UACrB,IAAI,CAACqD,MAAM,IAAIA,MAAM,CAACzE,CAAC,CAAC,EAAE;YACtB,IAAI,CAAC0E,OAAO,CAACc,KAAK,CAACrE,aAAa,GAAGnB,CAAC,GAAGA,CAAC,CAAChE,QAAQ,EAAE,CAAC,EAAE;cAClD2J,MAAM,GAAG,IAAI;YACjB;UACJ;QACJ;QACAD,UAAU,EAAE;QACZ,KAAK,MAAM1F,CAAC,IAAIoB,OAAO,EAAE;UACrB,IAAI2C,CAAC,GAAG/D,CAAC;UACT,IAAIA,CAAC,CAACjH,cAAc,EAAE,EAAE;YACpB,IAAI,EAAEyL,MAAM,KAAKT,CAAC,GAAG/D,CAAC,CAAC3J,YAAY,EAAE,CAAC,CAAC,EACnC;YACJ,IAAI0N,CAAC,CAAC3F,SAAS,EAAE,EACb2F,CAAC,CAACrN,SAAS,EAAE;UACrB;UACA,IAAIqN,CAAC,CAACvC,UAAU,CAACC,IAAI,EAAEC,UAAU,CAAC,EAAE;YAChC+D,KAAK,CAAC3H,IAAI,CAACiG,CAAC,CAAC;UACjB;QACJ;MACJ;MACA,IAAI4B,MAAM,IAAI,CAACjB,OAAO,CAACwB,OAAO,EAC1BxB,OAAO,CAACyB,IAAI,CAAC,OAAO,EAAEtD,OAAO,CAAC;IACtC,CAAC;IACDA,OAAO,EAAE;IACT,OAAO6B,OAAO;EAClB;EACA4B,KAAK,CAAC/J,IAAI,GAAG,IAAI,CAACmG,GAAG,EAAE;IACnB,MAAMZ,MAAM,GAAG,IAAI,CAACY,GAAG;IACvB,IAAI,CAACA,GAAG,GAAG,OAAOnG,IAAI,KAAK,QAAQ,GAAG,IAAI,CAACmG,GAAG,CAAChG,OAAO,CAACH,IAAI,CAAC,GAAGA,IAAI;IACnE,IAAI,CAACmG,GAAG,CAACtI,QAAQ,CAAC,CAAC0H,MAAM,CAAC;EAC9B;AACJ;AACA3M,OAAO,CAACM,cAAc,GAAGA,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,MAAMD,eAAe,SAASC,cAAc,CAAC;EACzC;AACJ;AACA;EACIiI,GAAG,GAAG,IAAI;EACV5D,WAAW,CAAC4I,GAAG,GAAGG,OAAO,CAACH,GAAG,EAAE,EAAElG,IAAI,GAAG,CAAC,CAAC,EAAE;IACxC,MAAM;MAAE9B,MAAM,GAAG;IAAK,CAAC,GAAG8B,IAAI;IAC9B,KAAK,CAACkG,GAAG,EAAEzM,MAAM,CAACkM,KAAK,EAAE,IAAI,EAAE;MAAE,GAAG3F,IAAI;MAAE9B;IAAO,CAAC,CAAC;IACnD,IAAI,CAACA,MAAM,GAAGA,MAAM;IACpB,KAAK,IAAIyC,CAAC,GAAG,IAAI,CAACuF,GAAG,EAAEvF,CAAC,EAAEA,CAAC,GAAGA,CAAC,CAAC1C,MAAM,EAAE;MACpC0C,CAAC,CAACzC,MAAM,GAAG,IAAI,CAACA,MAAM;IAC1B;EACJ;EACA;AACJ;AACA;EACIyI,aAAa,CAACvG,GAAG,EAAE;IACf;IACA;IACA;IACA,OAAO3G,MAAM,CAACkM,KAAK,CAACC,KAAK,CAACxF,GAAG,CAAC,CAACrC,IAAI,CAAC8H,WAAW,EAAE;EACrD;EACA;AACJ;AACA;EACIgB,OAAO,CAAC1I,EAAE,EAAE;IACR,OAAO,IAAIhF,SAAS,CAAC,IAAI,CAAC2B,QAAQ,EAAEM,KAAK,EAAE3D,SAAS,EAAE,IAAI,CAACuG,KAAK,EAAE,IAAI,CAACE,MAAM,EAAE,IAAI,CAAC+B,aAAa,EAAE,EAAE;MAAE9B;IAAG,CAAC,CAAC;EAChH;EACA;AACJ;AACA;EACIsJ,UAAU,CAAC9G,CAAC,EAAE;IACV,OAAQA,CAAC,CAACqF,UAAU,CAAC,GAAG,CAAC,IAAIrF,CAAC,CAACqF,UAAU,CAAC,IAAI,CAAC,IAAI,iBAAiB,CAACvE,IAAI,CAACd,CAAC,CAAC;EAChF;AACJ;AACAhI,OAAO,CAACK,eAAe,GAAGA,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMD,eAAe,SAASE,cAAc,CAAC;EACzC;AACJ;AACA;EACIiI,GAAG,GAAG,GAAG;EACT5D,WAAW,CAAC4I,GAAG,GAAGG,OAAO,CAACH,GAAG,EAAE,EAAElG,IAAI,GAAG,CAAC,CAAC,EAAE;IACxC,MAAM;MAAE9B,MAAM,GAAG;IAAM,CAAC,GAAG8B,IAAI;IAC/B,KAAK,CAACkG,GAAG,EAAEzM,MAAM,CAACsQ,KAAK,EAAE,GAAG,EAAE;MAAE,GAAG/J,IAAI;MAAE9B;IAAO,CAAC,CAAC;IAClD,IAAI,CAACA,MAAM,GAAGA,MAAM;EACxB;EACA;AACJ;AACA;EACIyI,aAAa,CAACqD,IAAI,EAAE;IAChB,OAAO,GAAG;EACd;EACA;AACJ;AACA;EACInD,OAAO,CAAC1I,EAAE,EAAE;IACR,OAAO,IAAIjF,SAAS,CAAC,IAAI,CAAC4B,QAAQ,EAAEM,KAAK,EAAE3D,SAAS,EAAE,IAAI,CAACuG,KAAK,EAAE,IAAI,CAACE,MAAM,EAAE,IAAI,CAAC+B,aAAa,EAAE,EAAE;MAAE9B;IAAG,CAAC,CAAC;EAChH;EACA;AACJ;AACA;EACIsJ,UAAU,CAAC9G,CAAC,EAAE;IACV,OAAOA,CAAC,CAACqF,UAAU,CAAC,GAAG,CAAC;EAC5B;AACJ;AACArN,OAAO,CAACI,eAAe,GAAGA,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMD,gBAAgB,SAASC,eAAe,CAAC;EAC3CuE,WAAW,CAAC4I,GAAG,GAAGG,OAAO,CAACH,GAAG,EAAE,EAAElG,IAAI,GAAG,CAAC,CAAC,EAAE;IACxC,MAAM;MAAE9B,MAAM,GAAG;IAAK,CAAC,GAAG8B,IAAI;IAC9B,KAAK,CAACkG,GAAG,EAAE;MAAE,GAAGlG,IAAI;MAAE9B;IAAO,CAAC,CAAC;EACnC;AACJ;AACAvF,OAAO,CAACG,gBAAgB,GAAGA,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACAH,OAAO,CAACE,IAAI,GAAGwN,OAAO,CAAC4D,QAAQ,KAAK,OAAO,GAAG9Q,SAAS,GAAGD,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA;AACAP,OAAO,CAACC,UAAU,GAAGyN,OAAO,CAAC4D,QAAQ,KAAK,OAAO,GAC3CjR,eAAe,GACfqN,OAAO,CAAC4D,QAAQ,KAAK,QAAQ,GACzBnR,gBAAgB,GAChBC,eAAe"},"metadata":{},"sourceType":"script","externalDependencies":[]}