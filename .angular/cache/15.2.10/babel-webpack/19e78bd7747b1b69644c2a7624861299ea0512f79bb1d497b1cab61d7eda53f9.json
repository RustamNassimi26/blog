{"ast":null,"code":"\"use strict\";\n\n// translate the various posix character classes into unicode properties\n// this works across all unicode locales\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseClass = void 0;\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses = {\n  '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n  '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n  '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n  '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n  '[:cntrl:]': ['\\\\p{Cc}', true],\n  '[:digit:]': ['\\\\p{Nd}', true],\n  '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n  '[:lower:]': ['\\\\p{Ll}', true],\n  '[:print:]': ['\\\\p{C}', true],\n  '[:punct:]': ['\\\\p{P}', true],\n  '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n  '[:upper:]': ['\\\\p{Lu}', true],\n  '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n  '[:xdigit:]': ['A-Fa-f0-9', false]\n};\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = s => s.replace(/[[\\]\\\\-]/g, '\\\\$&');\n// escape all regexp magic characters\nconst regexpEscape = s => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// everything has already been escaped, we just have to join\nconst rangesToString = ranges => ranges.join('');\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nconst parseClass = (glob, position) => {\n  const pos = position;\n  /* c8 ignore start */\n  if (glob.charAt(pos) !== '[') {\n    throw new Error('not in a brace expression');\n  }\n  /* c8 ignore stop */\n  const ranges = [];\n  const negs = [];\n  let i = pos + 1;\n  let sawStart = false;\n  let uflag = false;\n  let escaping = false;\n  let negate = false;\n  let endPos = pos;\n  let rangeStart = '';\n  WHILE: while (i < glob.length) {\n    const c = glob.charAt(i);\n    if ((c === '!' || c === '^') && i === pos + 1) {\n      negate = true;\n      i++;\n      continue;\n    }\n    if (c === ']' && sawStart && !escaping) {\n      endPos = i + 1;\n      break;\n    }\n    sawStart = true;\n    if (c === '\\\\') {\n      if (!escaping) {\n        escaping = true;\n        i++;\n        continue;\n      }\n      // escaped \\ char, fall through and treat like normal char\n    }\n\n    if (c === '[' && !escaping) {\n      // either a posix class, a collation equivalent, or just a [\n      for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n        if (glob.startsWith(cls, i)) {\n          // invalid, [a-[] is fine, but not [a-[:alpha]]\n          if (rangeStart) {\n            return ['$.', false, glob.length - pos, true];\n          }\n          i += cls.length;\n          if (neg) negs.push(unip);else ranges.push(unip);\n          uflag = uflag || u;\n          continue WHILE;\n        }\n      }\n    }\n    // now it's just a normal character, effectively\n    escaping = false;\n    if (rangeStart) {\n      // throw this range away if it's not valid, but others\n      // can still match.\n      if (c > rangeStart) {\n        ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));\n      } else if (c === rangeStart) {\n        ranges.push(braceEscape(c));\n      }\n      rangeStart = '';\n      i++;\n      continue;\n    }\n    // now might be the start of a range.\n    // can be either c-d or c-] or c<more...>] or c] at this point\n    if (glob.startsWith('-]', i + 1)) {\n      ranges.push(braceEscape(c + '-'));\n      i += 2;\n      continue;\n    }\n    if (glob.startsWith('-', i + 1)) {\n      rangeStart = c;\n      i += 2;\n      continue;\n    }\n    // not the start of a range, just a single character\n    ranges.push(braceEscape(c));\n    i++;\n  }\n  if (endPos < i) {\n    // didn't see the end of the class, not a valid class,\n    // but might still be valid as a literal match.\n    return ['', false, 0, false];\n  }\n  // if we got no ranges and no negates, then we have a range that\n  // cannot possibly match anything, and that poisons the whole glob\n  if (!ranges.length && !negs.length) {\n    return ['$.', false, glob.length - pos, true];\n  }\n  // if we got one positive range, and it's a single character, then that's\n  // not actually a magic pattern, it's just that one literal character.\n  // we should not treat that as \"magic\", we should just return the literal\n  // character. [_] is a perfectly valid way to escape glob magic chars.\n  if (negs.length === 0 && ranges.length === 1 && /^\\\\?.$/.test(ranges[0]) && !negate) {\n    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];\n    return [regexpEscape(r), false, endPos - pos, false];\n  }\n  const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';\n  const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';\n  const comb = ranges.length && negs.length ? '(' + sranges + '|' + snegs + ')' : ranges.length ? sranges : snegs;\n  return [comb, uflag, endPos - pos, true];\n};\nexports.parseClass = parseClass;","map":{"version":3,"names":["Object","defineProperty","exports","value","parseClass","posixClasses","braceEscape","s","replace","regexpEscape","rangesToString","ranges","join","glob","position","pos","charAt","Error","negs","i","sawStart","uflag","escaping","negate","endPos","rangeStart","WHILE","length","c","cls","unip","u","neg","entries","startsWith","push","test","r","slice","sranges","snegs","comb"],"sources":["I:/Angular/angular-blog/node_modules/ignore-walk/node_modules/minimatch/dist/cjs/brace-expressions.js"],"sourcesContent":["\"use strict\";\n// translate the various posix character classes into unicode properties\n// this works across all unicode locales\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseClass = void 0;\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses = {\n    '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n    '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n    '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n    '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n    '[:cntrl:]': ['\\\\p{Cc}', true],\n    '[:digit:]': ['\\\\p{Nd}', true],\n    '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n    '[:lower:]': ['\\\\p{Ll}', true],\n    '[:print:]': ['\\\\p{C}', true],\n    '[:punct:]': ['\\\\p{P}', true],\n    '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n    '[:upper:]': ['\\\\p{Lu}', true],\n    '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n    '[:xdigit:]': ['A-Fa-f0-9', false],\n};\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s) => s.replace(/[[\\]\\\\-]/g, '\\\\$&');\n// escape all regexp magic characters\nconst regexpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges) => ranges.join('');\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nconst parseClass = (glob, position) => {\n    const pos = position;\n    /* c8 ignore start */\n    if (glob.charAt(pos) !== '[') {\n        throw new Error('not in a brace expression');\n    }\n    /* c8 ignore stop */\n    const ranges = [];\n    const negs = [];\n    let i = pos + 1;\n    let sawStart = false;\n    let uflag = false;\n    let escaping = false;\n    let negate = false;\n    let endPos = pos;\n    let rangeStart = '';\n    WHILE: while (i < glob.length) {\n        const c = glob.charAt(i);\n        if ((c === '!' || c === '^') && i === pos + 1) {\n            negate = true;\n            i++;\n            continue;\n        }\n        if (c === ']' && sawStart && !escaping) {\n            endPos = i + 1;\n            break;\n        }\n        sawStart = true;\n        if (c === '\\\\') {\n            if (!escaping) {\n                escaping = true;\n                i++;\n                continue;\n            }\n            // escaped \\ char, fall through and treat like normal char\n        }\n        if (c === '[' && !escaping) {\n            // either a posix class, a collation equivalent, or just a [\n            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n                if (glob.startsWith(cls, i)) {\n                    // invalid, [a-[] is fine, but not [a-[:alpha]]\n                    if (rangeStart) {\n                        return ['$.', false, glob.length - pos, true];\n                    }\n                    i += cls.length;\n                    if (neg)\n                        negs.push(unip);\n                    else\n                        ranges.push(unip);\n                    uflag = uflag || u;\n                    continue WHILE;\n                }\n            }\n        }\n        // now it's just a normal character, effectively\n        escaping = false;\n        if (rangeStart) {\n            // throw this range away if it's not valid, but others\n            // can still match.\n            if (c > rangeStart) {\n                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));\n            }\n            else if (c === rangeStart) {\n                ranges.push(braceEscape(c));\n            }\n            rangeStart = '';\n            i++;\n            continue;\n        }\n        // now might be the start of a range.\n        // can be either c-d or c-] or c<more...>] or c] at this point\n        if (glob.startsWith('-]', i + 1)) {\n            ranges.push(braceEscape(c + '-'));\n            i += 2;\n            continue;\n        }\n        if (glob.startsWith('-', i + 1)) {\n            rangeStart = c;\n            i += 2;\n            continue;\n        }\n        // not the start of a range, just a single character\n        ranges.push(braceEscape(c));\n        i++;\n    }\n    if (endPos < i) {\n        // didn't see the end of the class, not a valid class,\n        // but might still be valid as a literal match.\n        return ['', false, 0, false];\n    }\n    // if we got no ranges and no negates, then we have a range that\n    // cannot possibly match anything, and that poisons the whole glob\n    if (!ranges.length && !negs.length) {\n        return ['$.', false, glob.length - pos, true];\n    }\n    // if we got one positive range, and it's a single character, then that's\n    // not actually a magic pattern, it's just that one literal character.\n    // we should not treat that as \"magic\", we should just return the literal\n    // character. [_] is a perfectly valid way to escape glob magic chars.\n    if (negs.length === 0 &&\n        ranges.length === 1 &&\n        /^\\\\?.$/.test(ranges[0]) &&\n        !negate) {\n        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];\n        return [regexpEscape(r), false, endPos - pos, false];\n    }\n    const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';\n    const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';\n    const comb = ranges.length && negs.length\n        ? '(' + sranges + '|' + snegs + ')'\n        : ranges.length\n            ? sranges\n            : snegs;\n    return [comb, uflag, endPos - pos, true];\n};\nexports.parseClass = parseClass;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}