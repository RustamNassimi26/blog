{"ast":null,"code":"var _asyncToGenerator = require(\"I:/Angular/angular-blog/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst Fetcher = require('./fetcher.js');\nconst FileFetcher = require('./file.js');\nconst RemoteFetcher = require('./remote.js');\nconst DirFetcher = require('./dir.js');\nconst hashre = /^[a-f0-9]{40}$/;\nconst git = require('@npmcli/git');\nconst pickManifest = require('npm-pick-manifest');\nconst npa = require('npm-package-arg');\nconst Minipass = require('minipass');\nconst cacache = require('cacache');\nconst log = require('proc-log');\nconst npm = require('./util/npm.js');\nconst _resolvedFromRepo = Symbol('_resolvedFromRepo');\nconst _resolvedFromHosted = Symbol('_resolvedFromHosted');\nconst _resolvedFromClone = Symbol('_resolvedFromClone');\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved');\nconst _addGitSha = Symbol('_addGitSha');\nconst addGitSha = require('./util/add-git-sha.js');\nconst _clone = Symbol('_clone');\nconst _cloneHosted = Symbol('_cloneHosted');\nconst _cloneRepo = Symbol('_cloneRepo');\nconst _setResolvedWithSha = Symbol('_setResolvedWithSha');\nconst _prepareDir = Symbol('_prepareDir');\nconst _readPackageJson = Symbol.for('package.Fetcher._readPackageJson');\n\n// get the repository url.\n// prefer https if there's auth, since ssh will drop that.\n// otherwise, prefer ssh if available (more secure).\n// We have to add the git+ back because npa suppresses it.\nconst repoUrl = (h, opts) => h.sshurl && !(h.https && h.auth) && addGitPlus(h.sshurl(opts)) || h.https && addGitPlus(h.https(opts));\n\n// add git+ to the url, but only one time.\nconst addGitPlus = url => url && `git+${url}`.replace(/^(git\\+)+/, 'git+');\nclass GitFetcher extends Fetcher {\n  constructor(spec, opts) {\n    super(spec, opts);\n\n    // we never want to compare integrity for git dependencies: npm/rfcs#525\n    if (this.opts.integrity) {\n      delete this.opts.integrity;\n      log.warn(`skipping integrity check for git dependency ${this.spec.fetchSpec}`);\n    }\n    this.resolvedRef = null;\n    if (this.spec.hosted) {\n      this.from = this.spec.hosted.shortcut({\n        noCommittish: false\n      });\n    }\n\n    // shortcut: avoid full clone when we can go straight to the tgz\n    // if we have the full sha and it's a hosted git platform\n    if (this.spec.gitCommittish && hashre.test(this.spec.gitCommittish)) {\n      this.resolvedSha = this.spec.gitCommittish;\n      // use hosted.tarball() when we shell to RemoteFetcher later\n      this.resolved = this.spec.hosted ? repoUrl(this.spec.hosted, {\n        noCommittish: false\n      }) : this.spec.rawSpec;\n    } else {\n      this.resolvedSha = '';\n    }\n    this.Arborist = opts.Arborist || null;\n  }\n\n  // just exposed to make it easier to test all the combinations\n  static repoUrl(hosted, opts) {\n    return repoUrl(hosted, opts);\n  }\n  get types() {\n    return ['git'];\n  }\n  resolve() {\n    // likely a hosted git repo with a sha, so get the tarball url\n    // but in general, no reason to resolve() more than necessary!\n    if (this.resolved) {\n      return super.resolve();\n    }\n\n    // fetch the git repo and then look at the current hash\n    const h = this.spec.hosted;\n    // try to use ssh, fall back to git.\n    return h ? this[_resolvedFromHosted](h) : this[_resolvedFromRepo](this.spec.fetchSpec);\n  }\n\n  // first try https, since that's faster and passphrase-less for\n  // public repos, and supports private repos when auth is provided.\n  // Fall back to SSH to support private repos\n  // NB: we always store the https url in resolved field if auth\n  // is present, otherwise ssh if the hosted type provides it\n  [_resolvedFromHosted](hosted) {\n    return this[_resolvedFromRepo](hosted.https && hosted.https()).catch(er => {\n      // Throw early since we know pathspec errors will fail again if retried\n      if (er instanceof git.errors.GitPathspecError) {\n        throw er;\n      }\n      const ssh = hosted.sshurl && hosted.sshurl();\n      // no fallthrough if we can't fall through or have https auth\n      if (!ssh || hosted.auth) {\n        throw er;\n      }\n      return this[_resolvedFromRepo](ssh);\n    });\n  }\n  [_resolvedFromRepo](gitRemote) {\n    // XXX make this a custom error class\n    if (!gitRemote) {\n      return Promise.reject(new Error(`No git url for ${this.spec}`));\n    }\n    const gitRange = this.spec.gitRange;\n    const name = this.spec.name;\n    return git.revs(gitRemote, this.opts).then(remoteRefs => {\n      return gitRange ? pickManifest({\n        versions: remoteRefs.versions,\n        'dist-tags': remoteRefs['dist-tags'],\n        name\n      }, gitRange, this.opts) : this.spec.gitCommittish ? remoteRefs.refs[this.spec.gitCommittish] || remoteRefs.refs[remoteRefs.shas[this.spec.gitCommittish]] : remoteRefs.refs.HEAD; // no git committish, get default head\n    }).then(revDoc => {\n      // the committish provided isn't in the rev list\n      // things like HEAD~3 or @yesterday can land here.\n      if (!revDoc || !revDoc.sha) {\n        return this[_resolvedFromClone]();\n      }\n      this.resolvedRef = revDoc;\n      this.resolvedSha = revDoc.sha;\n      this[_addGitSha](revDoc.sha);\n      return this.resolved;\n    });\n  }\n  [_setResolvedWithSha](withSha) {\n    // we haven't cloned, so a tgz download is still faster\n    // of course, if it's not a known host, we can't do that.\n    this.resolved = !this.spec.hosted ? withSha : repoUrl(npa(withSha).hosted, {\n      noCommittish: false\n    });\n  }\n\n  // when we get the git sha, we affix it to our spec to build up\n  // either a git url with a hash, or a tarball download URL\n  [_addGitSha](sha) {\n    this[_setResolvedWithSha](addGitSha(this.spec, sha));\n  }\n  [_resolvedFromClone]() {\n    // do a full or shallow clone, then look at the HEAD\n    // kind of wasteful, but no other option, really\n    return this[_clone](dir => this.resolved);\n  }\n  [_prepareDir](dir) {\n    return this[_readPackageJson](dir + '/package.json').then(mani => {\n      // no need if we aren't going to do any preparation.\n      const scripts = mani.scripts;\n      if (!mani.workspaces && (!scripts || !(scripts.postinstall || scripts.build || scripts.preinstall || scripts.install || scripts.prepack || scripts.prepare))) {\n        return;\n      }\n\n      // to avoid cases where we have an cycle of git deps that depend\n      // on one another, we only ever do preparation for one instance\n      // of a given git dep along the chain of installations.\n      // Note that this does mean that a dependency MAY in theory end up\n      // trying to run its prepare script using a dependency that has not\n      // been properly prepared itself, but that edge case is smaller\n      // and less hazardous than a fork bomb of npm and git commands.\n      const noPrepare = !process.env._PACOTE_NO_PREPARE_ ? [] : process.env._PACOTE_NO_PREPARE_.split('\\n');\n      if (noPrepare.includes(this.resolved)) {\n        log.info('prepare', 'skip prepare, already seen', this.resolved);\n        return;\n      }\n      noPrepare.push(this.resolved);\n\n      // the DirFetcher will do its own preparation to run the prepare scripts\n      // All we have to do is put the deps in place so that it can succeed.\n      return npm(this.npmBin, [].concat(this.npmInstallCmd).concat(this.npmCliConfig), dir, {\n        ...process.env,\n        _PACOTE_NO_PREPARE_: noPrepare.join('\\n')\n      }, {\n        message: 'git dep preparation failed'\n      });\n    });\n  }\n  [_tarballFromResolved]() {\n    const stream = new Minipass();\n    stream.resolved = this.resolved;\n    stream.from = this.from;\n\n    // check it out and then shell out to the DirFetcher tarball packer\n    this[_clone](dir => this[_prepareDir](dir).then(() => new Promise((res, rej) => {\n      if (!this.Arborist) {\n        throw new Error('GitFetcher requires an Arborist constructor to pack a tarball');\n      }\n      const df = new DirFetcher(`file:${dir}`, {\n        ...this.opts,\n        Arborist: this.Arborist,\n        resolved: null,\n        integrity: null\n      });\n      const dirStream = df[_tarballFromResolved]();\n      dirStream.on('error', rej);\n      dirStream.on('end', res);\n      dirStream.pipe(stream);\n    }))).catch( /* istanbul ignore next: very unlikely and hard to test */\n    er => stream.emit('error', er));\n    return stream;\n  }\n\n  // clone a git repo into a temp folder (or fetch and unpack if possible)\n  // handler accepts a directory, and returns a promise that resolves\n  // when we're done with it, at which point, cacache deletes it\n  //\n  // TODO: after cloning, create a tarball of the folder, and add to the cache\n  // with cacache.put.stream(), using a key that's deterministic based on the\n  // spec and repo, so that we don't ever clone the same thing multiple times.\n  [_clone](handler, tarballOk = true) {\n    var _this = this;\n    const o = {\n      tmpPrefix: 'git-clone'\n    };\n    const ref = this.resolvedSha || this.spec.gitCommittish;\n    const h = this.spec.hosted;\n    const resolved = this.resolved;\n\n    // can be set manually to false to fall back to actual git clone\n    tarballOk = tarballOk && h && resolved === repoUrl(h, {\n      noCommittish: false\n    }) && h.tarball;\n    return cacache.tmp.withTmp(this.cache, o, /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (tmp) {\n        // if we're resolved, and have a tarball url, shell out to RemoteFetcher\n        if (tarballOk) {\n          const nameat = _this.spec.name ? `${_this.spec.name}@` : '';\n          return new RemoteFetcher(h.tarball({\n            noCommittish: false\n          }), {\n            ..._this.opts,\n            allowGitIgnore: true,\n            pkgid: `git:${nameat}${_this.resolved}`,\n            resolved: _this.resolved,\n            integrity: null // it'll always be different, if we have one\n          }).extract(tmp).then(() => handler(tmp), er => {\n            // fall back to ssh download if tarball fails\n            if (er.constructor.name.match(/^Http/)) {\n              return _this[_clone](handler, false);\n            } else {\n              throw er;\n            }\n          });\n        }\n        const sha = yield h ? _this[_cloneHosted](ref, tmp) : _this[_cloneRepo](_this.spec.fetchSpec, ref, tmp);\n        _this.resolvedSha = sha;\n        if (!_this.resolved) {\n          yield _this[_addGitSha](sha);\n        }\n        return handler(tmp);\n      });\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  }\n\n  // first try https, since that's faster and passphrase-less for\n  // public repos, and supports private repos when auth is provided.\n  // Fall back to SSH to support private repos\n  // NB: we always store the https url in resolved field if auth\n  // is present, otherwise ssh if the hosted type provides it\n  [_cloneHosted](ref, tmp) {\n    const hosted = this.spec.hosted;\n    return this[_cloneRepo](hosted.https({\n      noCommittish: true\n    }), ref, tmp).catch(er => {\n      // Throw early since we know pathspec errors will fail again if retried\n      if (er instanceof git.errors.GitPathspecError) {\n        throw er;\n      }\n      const ssh = hosted.sshurl && hosted.sshurl({\n        noCommittish: true\n      });\n      // no fallthrough if we can't fall through or have https auth\n      if (!ssh || hosted.auth) {\n        throw er;\n      }\n      return this[_cloneRepo](ssh, ref, tmp);\n    });\n  }\n  [_cloneRepo](repo, ref, tmp) {\n    const {\n      opts,\n      spec\n    } = this;\n    return git.clone(repo, ref, tmp, {\n      ...opts,\n      spec\n    });\n  }\n  manifest() {\n    if (this.package) {\n      return Promise.resolve(this.package);\n    }\n    return this.spec.hosted && this.resolved ? FileFetcher.prototype.manifest.apply(this) : this[_clone](dir => this[_readPackageJson](dir + '/package.json').then(mani => this.package = {\n      ...mani,\n      _resolved: this.resolved,\n      _from: this.from\n    }));\n  }\n  packument() {\n    return FileFetcher.prototype.packument.apply(this);\n  }\n}\nmodule.exports = GitFetcher;","map":{"version":3,"names":["Fetcher","require","FileFetcher","RemoteFetcher","DirFetcher","hashre","git","pickManifest","npa","Minipass","cacache","log","npm","_resolvedFromRepo","Symbol","_resolvedFromHosted","_resolvedFromClone","_tarballFromResolved","for","_addGitSha","addGitSha","_clone","_cloneHosted","_cloneRepo","_setResolvedWithSha","_prepareDir","_readPackageJson","repoUrl","h","opts","sshurl","https","auth","addGitPlus","url","replace","GitFetcher","constructor","spec","integrity","warn","fetchSpec","resolvedRef","hosted","from","shortcut","noCommittish","gitCommittish","test","resolvedSha","resolved","rawSpec","Arborist","types","resolve","catch","er","errors","GitPathspecError","ssh","gitRemote","Promise","reject","Error","gitRange","name","revs","then","remoteRefs","versions","refs","shas","HEAD","revDoc","sha","withSha","dir","mani","scripts","workspaces","postinstall","build","preinstall","install","prepack","prepare","noPrepare","process","env","_PACOTE_NO_PREPARE_","split","includes","info","push","npmBin","concat","npmInstallCmd","npmCliConfig","join","message","stream","res","rej","df","dirStream","on","pipe","emit","handler","tarballOk","o","tmpPrefix","ref","tarball","tmp","withTmp","cache","nameat","allowGitIgnore","pkgid","extract","match","repo","clone","manifest","package","prototype","apply","_resolved","_from","packument","module","exports"],"sources":["I:/Angular/angular-blog/node_modules/pacote/lib/git.js"],"sourcesContent":["const Fetcher = require('./fetcher.js')\nconst FileFetcher = require('./file.js')\nconst RemoteFetcher = require('./remote.js')\nconst DirFetcher = require('./dir.js')\nconst hashre = /^[a-f0-9]{40}$/\nconst git = require('@npmcli/git')\nconst pickManifest = require('npm-pick-manifest')\nconst npa = require('npm-package-arg')\nconst Minipass = require('minipass')\nconst cacache = require('cacache')\nconst log = require('proc-log')\nconst npm = require('./util/npm.js')\n\nconst _resolvedFromRepo = Symbol('_resolvedFromRepo')\nconst _resolvedFromHosted = Symbol('_resolvedFromHosted')\nconst _resolvedFromClone = Symbol('_resolvedFromClone')\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved')\nconst _addGitSha = Symbol('_addGitSha')\nconst addGitSha = require('./util/add-git-sha.js')\nconst _clone = Symbol('_clone')\nconst _cloneHosted = Symbol('_cloneHosted')\nconst _cloneRepo = Symbol('_cloneRepo')\nconst _setResolvedWithSha = Symbol('_setResolvedWithSha')\nconst _prepareDir = Symbol('_prepareDir')\nconst _readPackageJson = Symbol.for('package.Fetcher._readPackageJson')\n\n// get the repository url.\n// prefer https if there's auth, since ssh will drop that.\n// otherwise, prefer ssh if available (more secure).\n// We have to add the git+ back because npa suppresses it.\nconst repoUrl = (h, opts) =>\n  h.sshurl && !(h.https && h.auth) && addGitPlus(h.sshurl(opts)) ||\n  h.https && addGitPlus(h.https(opts))\n\n// add git+ to the url, but only one time.\nconst addGitPlus = url => url && `git+${url}`.replace(/^(git\\+)+/, 'git+')\n\nclass GitFetcher extends Fetcher {\n  constructor (spec, opts) {\n    super(spec, opts)\n\n    // we never want to compare integrity for git dependencies: npm/rfcs#525\n    if (this.opts.integrity) {\n      delete this.opts.integrity\n      log.warn(`skipping integrity check for git dependency ${this.spec.fetchSpec}`)\n    }\n\n    this.resolvedRef = null\n    if (this.spec.hosted) {\n      this.from = this.spec.hosted.shortcut({ noCommittish: false })\n    }\n\n    // shortcut: avoid full clone when we can go straight to the tgz\n    // if we have the full sha and it's a hosted git platform\n    if (this.spec.gitCommittish && hashre.test(this.spec.gitCommittish)) {\n      this.resolvedSha = this.spec.gitCommittish\n      // use hosted.tarball() when we shell to RemoteFetcher later\n      this.resolved = this.spec.hosted\n        ? repoUrl(this.spec.hosted, { noCommittish: false })\n        : this.spec.rawSpec\n    } else {\n      this.resolvedSha = ''\n    }\n\n    this.Arborist = opts.Arborist || null\n  }\n\n  // just exposed to make it easier to test all the combinations\n  static repoUrl (hosted, opts) {\n    return repoUrl(hosted, opts)\n  }\n\n  get types () {\n    return ['git']\n  }\n\n  resolve () {\n    // likely a hosted git repo with a sha, so get the tarball url\n    // but in general, no reason to resolve() more than necessary!\n    if (this.resolved) {\n      return super.resolve()\n    }\n\n    // fetch the git repo and then look at the current hash\n    const h = this.spec.hosted\n    // try to use ssh, fall back to git.\n    return h ? this[_resolvedFromHosted](h)\n      : this[_resolvedFromRepo](this.spec.fetchSpec)\n  }\n\n  // first try https, since that's faster and passphrase-less for\n  // public repos, and supports private repos when auth is provided.\n  // Fall back to SSH to support private repos\n  // NB: we always store the https url in resolved field if auth\n  // is present, otherwise ssh if the hosted type provides it\n  [_resolvedFromHosted] (hosted) {\n    return this[_resolvedFromRepo](hosted.https && hosted.https())\n      .catch(er => {\n        // Throw early since we know pathspec errors will fail again if retried\n        if (er instanceof git.errors.GitPathspecError) {\n          throw er\n        }\n        const ssh = hosted.sshurl && hosted.sshurl()\n        // no fallthrough if we can't fall through or have https auth\n        if (!ssh || hosted.auth) {\n          throw er\n        }\n        return this[_resolvedFromRepo](ssh)\n      })\n  }\n\n  [_resolvedFromRepo] (gitRemote) {\n    // XXX make this a custom error class\n    if (!gitRemote) {\n      return Promise.reject(new Error(`No git url for ${this.spec}`))\n    }\n    const gitRange = this.spec.gitRange\n    const name = this.spec.name\n    return git.revs(gitRemote, this.opts).then(remoteRefs => {\n      return gitRange ? pickManifest({\n        versions: remoteRefs.versions,\n        'dist-tags': remoteRefs['dist-tags'],\n        name,\n      }, gitRange, this.opts)\n        : this.spec.gitCommittish ?\n          remoteRefs.refs[this.spec.gitCommittish] ||\n          remoteRefs.refs[remoteRefs.shas[this.spec.gitCommittish]]\n          : remoteRefs.refs.HEAD // no git committish, get default head\n    }).then(revDoc => {\n      // the committish provided isn't in the rev list\n      // things like HEAD~3 or @yesterday can land here.\n      if (!revDoc || !revDoc.sha) {\n        return this[_resolvedFromClone]()\n      }\n\n      this.resolvedRef = revDoc\n      this.resolvedSha = revDoc.sha\n      this[_addGitSha](revDoc.sha)\n      return this.resolved\n    })\n  }\n\n  [_setResolvedWithSha] (withSha) {\n    // we haven't cloned, so a tgz download is still faster\n    // of course, if it's not a known host, we can't do that.\n    this.resolved = !this.spec.hosted ? withSha\n      : repoUrl(npa(withSha).hosted, { noCommittish: false })\n  }\n\n  // when we get the git sha, we affix it to our spec to build up\n  // either a git url with a hash, or a tarball download URL\n  [_addGitSha] (sha) {\n    this[_setResolvedWithSha](addGitSha(this.spec, sha))\n  }\n\n  [_resolvedFromClone] () {\n    // do a full or shallow clone, then look at the HEAD\n    // kind of wasteful, but no other option, really\n    return this[_clone](dir => this.resolved)\n  }\n\n  [_prepareDir] (dir) {\n    return this[_readPackageJson](dir + '/package.json').then(mani => {\n      // no need if we aren't going to do any preparation.\n      const scripts = mani.scripts\n      if (!mani.workspaces && (!scripts || !(\n        scripts.postinstall ||\n          scripts.build ||\n          scripts.preinstall ||\n          scripts.install ||\n          scripts.prepack ||\n          scripts.prepare))) {\n        return\n      }\n\n      // to avoid cases where we have an cycle of git deps that depend\n      // on one another, we only ever do preparation for one instance\n      // of a given git dep along the chain of installations.\n      // Note that this does mean that a dependency MAY in theory end up\n      // trying to run its prepare script using a dependency that has not\n      // been properly prepared itself, but that edge case is smaller\n      // and less hazardous than a fork bomb of npm and git commands.\n      const noPrepare = !process.env._PACOTE_NO_PREPARE_ ? []\n        : process.env._PACOTE_NO_PREPARE_.split('\\n')\n      if (noPrepare.includes(this.resolved)) {\n        log.info('prepare', 'skip prepare, already seen', this.resolved)\n        return\n      }\n      noPrepare.push(this.resolved)\n\n      // the DirFetcher will do its own preparation to run the prepare scripts\n      // All we have to do is put the deps in place so that it can succeed.\n      return npm(\n        this.npmBin,\n        [].concat(this.npmInstallCmd).concat(this.npmCliConfig),\n        dir,\n        { ...process.env, _PACOTE_NO_PREPARE_: noPrepare.join('\\n') },\n        { message: 'git dep preparation failed' }\n      )\n    })\n  }\n\n  [_tarballFromResolved] () {\n    const stream = new Minipass()\n    stream.resolved = this.resolved\n    stream.from = this.from\n\n    // check it out and then shell out to the DirFetcher tarball packer\n    this[_clone](dir => this[_prepareDir](dir)\n      .then(() => new Promise((res, rej) => {\n        if (!this.Arborist) {\n          throw new Error('GitFetcher requires an Arborist constructor to pack a tarball')\n        }\n        const df = new DirFetcher(`file:${dir}`, {\n          ...this.opts,\n          Arborist: this.Arborist,\n          resolved: null,\n          integrity: null,\n        })\n        const dirStream = df[_tarballFromResolved]()\n        dirStream.on('error', rej)\n        dirStream.on('end', res)\n        dirStream.pipe(stream)\n      }))).catch(\n      /* istanbul ignore next: very unlikely and hard to test */\n      er => stream.emit('error', er)\n    )\n    return stream\n  }\n\n  // clone a git repo into a temp folder (or fetch and unpack if possible)\n  // handler accepts a directory, and returns a promise that resolves\n  // when we're done with it, at which point, cacache deletes it\n  //\n  // TODO: after cloning, create a tarball of the folder, and add to the cache\n  // with cacache.put.stream(), using a key that's deterministic based on the\n  // spec and repo, so that we don't ever clone the same thing multiple times.\n  [_clone] (handler, tarballOk = true) {\n    const o = { tmpPrefix: 'git-clone' }\n    const ref = this.resolvedSha || this.spec.gitCommittish\n    const h = this.spec.hosted\n    const resolved = this.resolved\n\n    // can be set manually to false to fall back to actual git clone\n    tarballOk = tarballOk &&\n      h && resolved === repoUrl(h, { noCommittish: false }) && h.tarball\n\n    return cacache.tmp.withTmp(this.cache, o, async tmp => {\n      // if we're resolved, and have a tarball url, shell out to RemoteFetcher\n      if (tarballOk) {\n        const nameat = this.spec.name ? `${this.spec.name}@` : ''\n        return new RemoteFetcher(h.tarball({ noCommittish: false }), {\n          ...this.opts,\n          allowGitIgnore: true,\n          pkgid: `git:${nameat}${this.resolved}`,\n          resolved: this.resolved,\n          integrity: null, // it'll always be different, if we have one\n        }).extract(tmp).then(() => handler(tmp), er => {\n          // fall back to ssh download if tarball fails\n          if (er.constructor.name.match(/^Http/)) {\n            return this[_clone](handler, false)\n          } else {\n            throw er\n          }\n        })\n      }\n\n      const sha = await (\n        h ? this[_cloneHosted](ref, tmp)\n        : this[_cloneRepo](this.spec.fetchSpec, ref, tmp)\n      )\n      this.resolvedSha = sha\n      if (!this.resolved) {\n        await this[_addGitSha](sha)\n      }\n      return handler(tmp)\n    })\n  }\n\n  // first try https, since that's faster and passphrase-less for\n  // public repos, and supports private repos when auth is provided.\n  // Fall back to SSH to support private repos\n  // NB: we always store the https url in resolved field if auth\n  // is present, otherwise ssh if the hosted type provides it\n  [_cloneHosted] (ref, tmp) {\n    const hosted = this.spec.hosted\n    return this[_cloneRepo](hosted.https({ noCommittish: true }), ref, tmp)\n      .catch(er => {\n        // Throw early since we know pathspec errors will fail again if retried\n        if (er instanceof git.errors.GitPathspecError) {\n          throw er\n        }\n        const ssh = hosted.sshurl && hosted.sshurl({ noCommittish: true })\n        // no fallthrough if we can't fall through or have https auth\n        if (!ssh || hosted.auth) {\n          throw er\n        }\n        return this[_cloneRepo](ssh, ref, tmp)\n      })\n  }\n\n  [_cloneRepo] (repo, ref, tmp) {\n    const { opts, spec } = this\n    return git.clone(repo, ref, tmp, { ...opts, spec })\n  }\n\n  manifest () {\n    if (this.package) {\n      return Promise.resolve(this.package)\n    }\n\n    return this.spec.hosted && this.resolved\n      ? FileFetcher.prototype.manifest.apply(this)\n      : this[_clone](dir =>\n        this[_readPackageJson](dir + '/package.json')\n          .then(mani => this.package = {\n            ...mani,\n            _resolved: this.resolved,\n            _from: this.from,\n          }))\n  }\n\n  packument () {\n    return FileFetcher.prototype.packument.apply(this)\n  }\n}\nmodule.exports = GitFetcher\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}