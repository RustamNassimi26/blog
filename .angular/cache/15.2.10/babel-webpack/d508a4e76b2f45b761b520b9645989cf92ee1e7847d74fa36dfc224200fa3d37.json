{"ast":null,"code":"#! /usr/bin/env node\n\n// to GET CONTENTS for folder at PATH (which may be a PACKAGE):\n// - if PACKAGE, read path/package.json\n//   - if bins in ../node_modules/.bin, add those to result\n// - if depth >= maxDepth, add PATH to result, and finish\n// - readdir(PATH, with file types)\n// - add all FILEs in PATH to result\n// - if PARENT:\n//   - if depth < maxDepth, add GET CONTENTS of all DIRs in PATH\n//   - else, add all DIRs in PATH\n// - if no parent\n//   - if no bundled deps,\n//     - if depth < maxDepth, add GET CONTENTS of DIRs in path except\n//       node_modules\n//     - else, add all DIRs in path other than node_modules\n//   - if has bundled deps,\n//     - get list of bundled deps\n//     - add GET CONTENTS of bundled deps, PACKAGE=true, depth + 1\nvar _asyncToGenerator = require(\"I:/Angular/angular-blog/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst bundled = require('npm-bundled');\nconst {\n  promisify\n} = require('util');\nconst fs = require('fs');\nconst readFile = promisify(fs.readFile);\nconst readdir = promisify(fs.readdir);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst {\n  relative,\n  resolve,\n  basename,\n  dirname\n} = require('path');\nconst normalizePackageBin = require('npm-normalize-package-bin');\nconst readPackage = ({\n  path,\n  packageJsonCache\n}) => packageJsonCache.has(path) ? Promise.resolve(packageJsonCache.get(path)) : readFile(path).then(json => {\n  const pkg = normalizePackageBin(JSON.parse(json));\n  packageJsonCache.set(path, pkg);\n  return pkg;\n}).catch(er => null);\n\n// just normalize bundle deps and bin, that's all we care about here.\nconst normalized = Symbol('package data has been normalized');\nconst rpj = ({\n  path,\n  packageJsonCache\n}) => readPackage({\n  path,\n  packageJsonCache\n}).then(pkg => {\n  if (!pkg || pkg[normalized]) {\n    return pkg;\n  }\n  if (pkg.bundledDependencies && !pkg.bundleDependencies) {\n    pkg.bundleDependencies = pkg.bundledDependencies;\n    delete pkg.bundledDependencies;\n  }\n  const bd = pkg.bundleDependencies;\n  if (bd === true) {\n    pkg.bundleDependencies = [...Object.keys(pkg.dependencies || {}), ...Object.keys(pkg.optionalDependencies || {})];\n  }\n  if (typeof bd === 'object' && !Array.isArray(bd)) {\n    pkg.bundleDependencies = Object.keys(bd);\n  }\n  pkg[normalized] = true;\n  return pkg;\n});\nconst pkgContents = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* ({\n    path,\n    depth,\n    currentDepth = 0,\n    pkg = null,\n    result = null,\n    packageJsonCache = null\n  }) {\n    if (!result) {\n      result = new Set();\n    }\n    if (!packageJsonCache) {\n      packageJsonCache = new Map();\n    }\n    if (pkg === true) {\n      return rpj({\n        path: path + '/package.json',\n        packageJsonCache\n      }).then(p => pkgContents({\n        path,\n        depth,\n        currentDepth,\n        pkg: p,\n        result,\n        packageJsonCache\n      }));\n    }\n    if (pkg) {\n      // add all bins to result if they exist\n      if (pkg.bin) {\n        const dir = dirname(path);\n        const scope = basename(dir);\n        const nm = /^@.+/.test(scope) ? dirname(dir) : dir;\n        const binFiles = [];\n        Object.keys(pkg.bin).forEach(b => {\n          const base = resolve(nm, '.bin', b);\n          binFiles.push(base, base + '.cmd', base + '.ps1');\n        });\n        const bins = yield Promise.all(binFiles.map(b => stat(b).then(() => b).catch(er => null)));\n        bins.filter(b => b).forEach(b => result.add(b));\n      }\n    }\n    if (currentDepth >= depth) {\n      result.add(path);\n      return result;\n    }\n\n    // we'll need bundle list later, so get that now in parallel\n    const [dirEntries, bundleDeps] = yield Promise.all([readdir(path, {\n      withFileTypes: true\n    }), currentDepth === 0 && pkg && pkg.bundleDependencies ? bundled({\n      path,\n      packageJsonCache\n    }) : null]).catch(() => []);\n\n    // not a thing, probably a missing folder\n    if (!dirEntries) {\n      return result;\n    }\n\n    // empty folder, just add the folder itself to the result\n    if (!dirEntries.length && !bundleDeps && currentDepth !== 0) {\n      result.add(path);\n      return result;\n    }\n    const recursePromises = [];\n\n    // if we didn't get withFileTypes support, tack that on\n    if (typeof dirEntries[0] === 'string') {\n      // use a map so we can return a promise, but we mutate dirEntries in place\n      // this is much slower than getting the entries from the readdir call,\n      // but polyfills support for node versions before 10.10\n      yield Promise.all(dirEntries.map( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (name, index) {\n          const p = resolve(path, name);\n          const st = yield lstat(p);\n          dirEntries[index] = Object.assign(st, {\n            name\n          });\n        });\n        return function (_x2, _x3) {\n          return _ref2.apply(this, arguments);\n        };\n      }()));\n    }\n    for (const entry of dirEntries) {\n      const p = resolve(path, entry.name);\n      if (entry.isDirectory() === false) {\n        result.add(p);\n        continue;\n      }\n      if (currentDepth !== 0 || entry.name !== 'node_modules') {\n        if (currentDepth < depth - 1) {\n          recursePromises.push(pkgContents({\n            path: p,\n            packageJsonCache,\n            depth,\n            currentDepth: currentDepth + 1,\n            result\n          }));\n        } else {\n          result.add(p);\n        }\n        continue;\n      }\n    }\n    if (bundleDeps) {\n      // bundle deps are all folders\n      // we always recurse to get pkg bins, but if currentDepth is too high,\n      // it'll return early before walking their contents.\n      recursePromises.push(...bundleDeps.map(dep => {\n        const p = resolve(path, 'node_modules', dep);\n        return pkgContents({\n          path: p,\n          packageJsonCache,\n          pkg: true,\n          depth,\n          currentDepth: currentDepth + 1,\n          result\n        });\n      }));\n    }\n    if (recursePromises.length) {\n      yield Promise.all(recursePromises);\n    }\n    return result;\n  });\n  return function pkgContents(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nmodule.exports = ({\n  path,\n  depth = 1,\n  packageJsonCache\n}) => pkgContents({\n  path: resolve(path),\n  depth,\n  pkg: true,\n  packageJsonCache\n}).then(results => [...results]);\nif (require.main === module) {\n  const options = {\n    path: null,\n    depth: 1\n  };\n  const usage = `Usage:\n  installed-package-contents <path> [-d<n> --depth=<n>]\n\nLists the files installed for a package specified by <path>.\n\nOptions:\n  -d<n> --depth=<n>   Provide a numeric value (\"Infinity\" is allowed)\n                      to specify how deep in the file tree to traverse.\n                      Default=1\n  -h --help           Show this usage information`;\n  process.argv.slice(2).forEach(arg => {\n    let match;\n    if ((match = arg.match(/^--depth=([0-9]+|Infinity)/)) || (match = arg.match(/^-d([0-9]+|Infinity)/))) {\n      options.depth = +match[1];\n    } else if (arg === '-h' || arg === '--help') {\n      console.log(usage);\n      process.exit(0);\n    } else {\n      options.path = arg;\n    }\n  });\n  if (!options.path) {\n    console.error('ERROR: no path provided');\n    console.error(usage);\n    process.exit(1);\n  }\n  const cwd = process.cwd();\n  module.exports(options).then(list => list.sort().forEach(p => console.log(relative(cwd, p)))).catch( /* istanbul ignore next - pretty unusual */er => {\n    console.error(er);\n    process.exit(1);\n  });\n}","map":{"version":3,"names":["bundled","require","promisify","fs","readFile","readdir","stat","lstat","relative","resolve","basename","dirname","normalizePackageBin","readPackage","path","packageJsonCache","has","Promise","get","then","json","pkg","JSON","parse","set","catch","er","normalized","Symbol","rpj","bundledDependencies","bundleDependencies","bd","Object","keys","dependencies","optionalDependencies","Array","isArray","pkgContents","depth","currentDepth","result","Set","Map","p","bin","dir","scope","nm","test","binFiles","forEach","b","base","push","bins","all","map","filter","add","dirEntries","bundleDeps","withFileTypes","length","recursePromises","name","index","st","assign","entry","isDirectory","dep","module","exports","results","main","options","usage","process","argv","slice","arg","match","console","log","exit","error","cwd","list","sort"],"sources":["I:/Angular/angular-blog/node_modules/@npmcli/installed-package-contents/lib/index.js"],"sourcesContent":["#! /usr/bin/env node\n\n// to GET CONTENTS for folder at PATH (which may be a PACKAGE):\n// - if PACKAGE, read path/package.json\n//   - if bins in ../node_modules/.bin, add those to result\n// - if depth >= maxDepth, add PATH to result, and finish\n// - readdir(PATH, with file types)\n// - add all FILEs in PATH to result\n// - if PARENT:\n//   - if depth < maxDepth, add GET CONTENTS of all DIRs in PATH\n//   - else, add all DIRs in PATH\n// - if no parent\n//   - if no bundled deps,\n//     - if depth < maxDepth, add GET CONTENTS of DIRs in path except\n//       node_modules\n//     - else, add all DIRs in path other than node_modules\n//   - if has bundled deps,\n//     - get list of bundled deps\n//     - add GET CONTENTS of bundled deps, PACKAGE=true, depth + 1\n\nconst bundled = require('npm-bundled')\nconst { promisify } = require('util')\nconst fs = require('fs')\nconst readFile = promisify(fs.readFile)\nconst readdir = promisify(fs.readdir)\nconst stat = promisify(fs.stat)\nconst lstat = promisify(fs.lstat)\nconst { relative, resolve, basename, dirname } = require('path')\nconst normalizePackageBin = require('npm-normalize-package-bin')\n\nconst readPackage = ({ path, packageJsonCache }) =>\n  packageJsonCache.has(path) ? Promise.resolve(packageJsonCache.get(path))\n  : readFile(path).then(json => {\n    const pkg = normalizePackageBin(JSON.parse(json))\n    packageJsonCache.set(path, pkg)\n    return pkg\n  })\n    .catch(er => null)\n\n// just normalize bundle deps and bin, that's all we care about here.\nconst normalized = Symbol('package data has been normalized')\nconst rpj = ({ path, packageJsonCache }) =>\n  readPackage({ path, packageJsonCache })\n    .then(pkg => {\n      if (!pkg || pkg[normalized]) {\n        return pkg\n      }\n      if (pkg.bundledDependencies && !pkg.bundleDependencies) {\n        pkg.bundleDependencies = pkg.bundledDependencies\n        delete pkg.bundledDependencies\n      }\n      const bd = pkg.bundleDependencies\n      if (bd === true) {\n        pkg.bundleDependencies = [\n          ...Object.keys(pkg.dependencies || {}),\n          ...Object.keys(pkg.optionalDependencies || {}),\n        ]\n      }\n      if (typeof bd === 'object' && !Array.isArray(bd)) {\n        pkg.bundleDependencies = Object.keys(bd)\n      }\n      pkg[normalized] = true\n      return pkg\n    })\n\nconst pkgContents = async ({\n  path,\n  depth,\n  currentDepth = 0,\n  pkg = null,\n  result = null,\n  packageJsonCache = null,\n}) => {\n  if (!result) {\n    result = new Set()\n  }\n\n  if (!packageJsonCache) {\n    packageJsonCache = new Map()\n  }\n\n  if (pkg === true) {\n    return rpj({ path: path + '/package.json', packageJsonCache })\n      .then(p => pkgContents({\n        path,\n        depth,\n        currentDepth,\n        pkg: p,\n        result,\n        packageJsonCache,\n      }))\n  }\n\n  if (pkg) {\n    // add all bins to result if they exist\n    if (pkg.bin) {\n      const dir = dirname(path)\n      const scope = basename(dir)\n      const nm = /^@.+/.test(scope) ? dirname(dir) : dir\n\n      const binFiles = []\n      Object.keys(pkg.bin).forEach(b => {\n        const base = resolve(nm, '.bin', b)\n        binFiles.push(base, base + '.cmd', base + '.ps1')\n      })\n\n      const bins = await Promise.all(\n        binFiles.map(b => stat(b).then(() => b).catch((er) => null))\n      )\n      bins.filter(b => b).forEach(b => result.add(b))\n    }\n  }\n\n  if (currentDepth >= depth) {\n    result.add(path)\n    return result\n  }\n\n  // we'll need bundle list later, so get that now in parallel\n  const [dirEntries, bundleDeps] = await Promise.all([\n    readdir(path, { withFileTypes: true }),\n    currentDepth === 0 && pkg && pkg.bundleDependencies\n      ? bundled({ path, packageJsonCache }) : null,\n  ]).catch(() => [])\n\n  // not a thing, probably a missing folder\n  if (!dirEntries) {\n    return result\n  }\n\n  // empty folder, just add the folder itself to the result\n  if (!dirEntries.length && !bundleDeps && currentDepth !== 0) {\n    result.add(path)\n    return result\n  }\n\n  const recursePromises = []\n\n  // if we didn't get withFileTypes support, tack that on\n  if (typeof dirEntries[0] === 'string') {\n    // use a map so we can return a promise, but we mutate dirEntries in place\n    // this is much slower than getting the entries from the readdir call,\n    // but polyfills support for node versions before 10.10\n    await Promise.all(dirEntries.map(async (name, index) => {\n      const p = resolve(path, name)\n      const st = await lstat(p)\n      dirEntries[index] = Object.assign(st, { name })\n    }))\n  }\n\n  for (const entry of dirEntries) {\n    const p = resolve(path, entry.name)\n    if (entry.isDirectory() === false) {\n      result.add(p)\n      continue\n    }\n\n    if (currentDepth !== 0 || entry.name !== 'node_modules') {\n      if (currentDepth < depth - 1) {\n        recursePromises.push(pkgContents({\n          path: p,\n          packageJsonCache,\n          depth,\n          currentDepth: currentDepth + 1,\n          result,\n        }))\n      } else {\n        result.add(p)\n      }\n      continue\n    }\n  }\n\n  if (bundleDeps) {\n    // bundle deps are all folders\n    // we always recurse to get pkg bins, but if currentDepth is too high,\n    // it'll return early before walking their contents.\n    recursePromises.push(...bundleDeps.map(dep => {\n      const p = resolve(path, 'node_modules', dep)\n      return pkgContents({\n        path: p,\n        packageJsonCache,\n        pkg: true,\n        depth,\n        currentDepth: currentDepth + 1,\n        result,\n      })\n    }))\n  }\n\n  if (recursePromises.length) {\n    await Promise.all(recursePromises)\n  }\n\n  return result\n}\n\nmodule.exports = ({ path, depth = 1, packageJsonCache }) => pkgContents({\n  path: resolve(path),\n  depth,\n  pkg: true,\n  packageJsonCache,\n}).then(results => [...results])\n\nif (require.main === module) {\n  const options = { path: null, depth: 1 }\n  const usage = `Usage:\n  installed-package-contents <path> [-d<n> --depth=<n>]\n\nLists the files installed for a package specified by <path>.\n\nOptions:\n  -d<n> --depth=<n>   Provide a numeric value (\"Infinity\" is allowed)\n                      to specify how deep in the file tree to traverse.\n                      Default=1\n  -h --help           Show this usage information`\n\n  process.argv.slice(2).forEach(arg => {\n    let match\n    if ((match = arg.match(/^--depth=([0-9]+|Infinity)/)) ||\n        (match = arg.match(/^-d([0-9]+|Infinity)/))) {\n      options.depth = +match[1]\n    } else if (arg === '-h' || arg === '--help') {\n      console.log(usage)\n      process.exit(0)\n    } else {\n      options.path = arg\n    }\n  })\n  if (!options.path) {\n    console.error('ERROR: no path provided')\n    console.error(usage)\n    process.exit(1)\n  }\n  const cwd = process.cwd()\n  module.exports(options)\n    .then(list => list.sort().forEach(p => console.log(relative(cwd, p))))\n    .catch(/* istanbul ignore next - pretty unusual */ er => {\n      console.error(er)\n      process.exit(1)\n    })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}