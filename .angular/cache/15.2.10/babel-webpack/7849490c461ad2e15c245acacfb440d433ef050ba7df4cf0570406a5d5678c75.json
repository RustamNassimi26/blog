{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _asyncToGenerator = require(\"I:/Angular/angular-blog/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AddCommandModule = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst tools_1 = require(\"@angular-devkit/schematics/tools\");\nconst module_1 = require(\"module\");\nconst npm_package_arg_1 = __importDefault(require(\"npm-package-arg\"));\nconst path_1 = require(\"path\");\nconst semver_1 = require(\"semver\");\nconst workspace_schema_1 = require(\"../../../lib/config/workspace-schema\");\nconst schematics_command_module_1 = require(\"../../command-builder/schematics-command-module\");\nconst color_1 = require(\"../../utilities/color\");\nconst error_1 = require(\"../../utilities/error\");\nconst package_metadata_1 = require(\"../../utilities/package-metadata\");\nconst prompt_1 = require(\"../../utilities/prompt\");\nconst spinner_1 = require(\"../../utilities/spinner\");\nconst tty_1 = require(\"../../utilities/tty\");\nconst version_1 = require(\"../../utilities/version\");\n/**\n * The set of packages that should have certain versions excluded from consideration\n * when attempting to find a compatible version for a package.\n * The key is a package name and the value is a SemVer range of versions to exclude.\n */\nconst packageVersionExclusions = {\n  // @angular/localize@9.x and earlier versions as well as @angular/localize@10.0 prereleases do not have peer dependencies setup.\n  '@angular/localize': '<10.0.0',\n  // @angular/material@7.x versions have unbounded peer dependency ranges (>=7.0.0).\n  '@angular/material': '7.x'\n};\nclass AddCommandModule extends schematics_command_module_1.SchematicsCommandModule {\n  constructor() {\n    super(...arguments);\n    this.command = 'add <collection>';\n    this.describe = 'Adds support for an external library to your project.';\n    this.longDescriptionPath = (0, path_1.join)(__dirname, 'long-description.md');\n    this.allowPrivateSchematics = true;\n    this.schematicName = 'ng-add';\n    this.rootRequire = (0, module_1.createRequire)(this.context.root + '/');\n  }\n  builder(argv) {\n    var _superprop_getBuilder = () => super.builder,\n      _this = this;\n    return _asyncToGenerator(function* () {\n      const localYargs = (yield _superprop_getBuilder().call(_this, argv)).positional('collection', {\n        description: 'The package to be added.',\n        type: 'string',\n        demandOption: true\n      }).option('registry', {\n        description: 'The NPM registry to use.',\n        type: 'string'\n      }).option('verbose', {\n        description: 'Display additional details about internal operations during execution.',\n        type: 'boolean',\n        default: false\n      }).option('skip-confirmation', {\n        description: 'Skip asking a confirmation prompt before installing and executing the package. ' + 'Ensure package name is correct prior to using this option.',\n        type: 'boolean',\n        default: false\n      })\n      // Prior to downloading we don't know the full schema and therefore we cannot be strict on the options.\n      // Possibly in the future update the logic to use the following syntax:\n      // `ng add @angular/localize -- --package-options`.\n      .strict(false);\n      const collectionName = yield _this.getCollectionName();\n      const workflow = yield _this.getOrCreateWorkflowForBuilder(collectionName);\n      try {\n        const collection = workflow.engine.createCollection(collectionName);\n        const options = yield _this.getSchematicOptions(collection, _this.schematicName, workflow);\n        return _this.addSchemaOptionsToCommand(localYargs, options);\n      } catch (error) {\n        // During `ng add` prior to the downloading of the package\n        // we are not able to resolve and create a collection.\n        // Or when the the collection value is a path to a tarball.\n      }\n      return localYargs;\n    })();\n  }\n  // eslint-disable-next-line max-lines-per-function\n  run(options) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      const {\n        logger,\n        packageManager\n      } = _this2.context;\n      const {\n        verbose,\n        registry,\n        collection,\n        skipConfirmation\n      } = options;\n      packageManager.ensureCompatibility();\n      let packageIdentifier;\n      try {\n        packageIdentifier = (0, npm_package_arg_1.default)(collection);\n      } catch (e) {\n        (0, error_1.assertIsError)(e);\n        logger.error(e.message);\n        return 1;\n      }\n      if (packageIdentifier.name && packageIdentifier.registry && _this2.isPackageInstalled(packageIdentifier.name)) {\n        const validVersion = yield _this2.isProjectVersionValid(packageIdentifier);\n        if (validVersion) {\n          // Already installed so just run schematic\n          logger.info('Skipping installation: Package already installed');\n          return _this2.executeSchematic({\n            ...options,\n            collection: packageIdentifier.name\n          });\n        }\n      }\n      const spinner = new spinner_1.Spinner();\n      spinner.start('Determining package manager...');\n      const usingYarn = packageManager.name === workspace_schema_1.PackageManager.Yarn;\n      spinner.info(`Using package manager: ${color_1.colors.grey(packageManager.name)}`);\n      if (packageIdentifier.name && packageIdentifier.type === 'tag' && !packageIdentifier.rawSpec) {\n        // only package name provided; search for viable version\n        // plus special cases for packages that did not have peer deps setup\n        spinner.start('Searching for compatible package version...');\n        let packageMetadata;\n        try {\n          packageMetadata = yield (0, package_metadata_1.fetchPackageMetadata)(packageIdentifier.name, logger, {\n            registry,\n            usingYarn,\n            verbose\n          });\n        } catch (e) {\n          (0, error_1.assertIsError)(e);\n          spinner.fail(`Unable to load package information from registry: ${e.message}`);\n          return 1;\n        }\n        // Start with the version tagged as `latest` if it exists\n        const latestManifest = packageMetadata.tags['latest'];\n        if (latestManifest) {\n          packageIdentifier = npm_package_arg_1.default.resolve(latestManifest.name, latestManifest.version);\n        }\n        // Adjust the version based on name and peer dependencies\n        if ((latestManifest === null || latestManifest === void 0 ? void 0 : latestManifest.peerDependencies) && Object.keys(latestManifest.peerDependencies).length === 0) {\n          spinner.succeed(`Found compatible package version: ${color_1.colors.grey(packageIdentifier.toString())}.`);\n        } else if (!latestManifest || (yield _this2.hasMismatchedPeer(latestManifest))) {\n          // 'latest' is invalid so search for most recent matching package\n          // Allow prelease versions if the CLI itself is a prerelease\n          const allowPrereleases = (0, semver_1.prerelease)(version_1.VERSION.full);\n          const versionExclusions = packageVersionExclusions[packageMetadata.name];\n          const versionManifests = Object.values(packageMetadata.versions).filter(value => {\n            // Prerelease versions are not stable and should not be considered by default\n            if (!allowPrereleases && (0, semver_1.prerelease)(value.version)) {\n              return false;\n            }\n            // Deprecated versions should not be used or considered\n            if (value.deprecated) {\n              return false;\n            }\n            // Excluded package versions should not be considered\n            if (versionExclusions && (0, semver_1.satisfies)(value.version, versionExclusions, {\n              includePrerelease: true\n            })) {\n              return false;\n            }\n            return true;\n          });\n          // Sort in reverse SemVer order so that the newest compatible version is chosen\n          versionManifests.sort((a, b) => (0, semver_1.compare)(b.version, a.version, true));\n          let newIdentifier;\n          for (const versionManifest of versionManifests) {\n            if (!(yield _this2.hasMismatchedPeer(versionManifest))) {\n              newIdentifier = npm_package_arg_1.default.resolve(versionManifest.name, versionManifest.version);\n              break;\n            }\n          }\n          if (!newIdentifier) {\n            spinner.warn(\"Unable to find compatible package. Using 'latest' tag.\");\n          } else {\n            packageIdentifier = newIdentifier;\n            spinner.succeed(`Found compatible package version: ${color_1.colors.grey(packageIdentifier.toString())}.`);\n          }\n        } else {\n          spinner.succeed(`Found compatible package version: ${color_1.colors.grey(packageIdentifier.toString())}.`);\n        }\n      }\n      let collectionName = packageIdentifier.name;\n      let savePackage;\n      try {\n        spinner.start('Loading package information from registry...');\n        const manifest = yield (0, package_metadata_1.fetchPackageManifest)(packageIdentifier.toString(), logger, {\n          registry,\n          verbose,\n          usingYarn\n        });\n        savePackage = (_a = manifest['ng-add']) === null || _a === void 0 ? void 0 : _a.save;\n        collectionName = manifest.name;\n        if (yield _this2.hasMismatchedPeer(manifest)) {\n          spinner.warn('Package has unmet peer dependencies. Adding the package may not succeed.');\n        } else {\n          spinner.succeed(`Package information loaded.`);\n        }\n      } catch (e) {\n        (0, error_1.assertIsError)(e);\n        spinner.fail(`Unable to fetch package information for '${packageIdentifier}': ${e.message}`);\n        return 1;\n      }\n      if (!skipConfirmation) {\n        const confirmationResponse = yield (0, prompt_1.askConfirmation)(`\\nThe package ${color_1.colors.blue(packageIdentifier.raw)} will be installed and executed.\\n` + 'Would you like to proceed?', true, false);\n        if (!confirmationResponse) {\n          if (!(0, tty_1.isTTY)()) {\n            logger.error('No terminal detected. ' + `'--skip-confirmation' can be used to bypass installation confirmation. ` + `Ensure package name is correct prior to '--skip-confirmation' option usage.`);\n          }\n          logger.error('Command aborted.');\n          return 1;\n        }\n      }\n      if (savePackage === false) {\n        // Temporary packages are located in a different directory\n        // Hence we need to resolve them using the temp path\n        const {\n          success,\n          tempNodeModules\n        } = yield packageManager.installTemp(packageIdentifier.raw, registry ? [`--registry=\"${registry}\"`] : undefined);\n        const tempRequire = (0, module_1.createRequire)(tempNodeModules + '/');\n        const resolvedCollectionPath = tempRequire.resolve((0, path_1.join)(collectionName, 'package.json'));\n        if (!success) {\n          return 1;\n        }\n        collectionName = (0, path_1.dirname)(resolvedCollectionPath);\n      } else {\n        const success = yield packageManager.install(packageIdentifier.raw, savePackage, registry ? [`--registry=\"${registry}\"`] : undefined);\n        if (!success) {\n          return 1;\n        }\n      }\n      return _this2.executeSchematic({\n        ...options,\n        collection: collectionName\n      });\n    })();\n  }\n  isProjectVersionValid(packageIdentifier) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (!packageIdentifier.name) {\n        return false;\n      }\n      let validVersion = false;\n      const installedVersion = yield _this3.findProjectVersion(packageIdentifier.name);\n      if (installedVersion) {\n        if (packageIdentifier.type === 'range' && packageIdentifier.fetchSpec) {\n          validVersion = (0, semver_1.satisfies)(installedVersion, packageIdentifier.fetchSpec);\n        } else if (packageIdentifier.type === 'version') {\n          const v1 = (0, semver_1.valid)(packageIdentifier.fetchSpec);\n          const v2 = (0, semver_1.valid)(installedVersion);\n          validVersion = v1 !== null && v1 === v2;\n        } else if (!packageIdentifier.rawSpec) {\n          validVersion = true;\n        }\n      }\n      return validVersion;\n    })();\n  }\n  getCollectionName() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const [, collectionName] = _this4.context.args.positional;\n      return collectionName;\n    })();\n  }\n  isPackageInstalled(name) {\n    try {\n      this.rootRequire.resolve((0, path_1.join)(name, 'package.json'));\n      return true;\n    } catch (e) {\n      (0, error_1.assertIsError)(e);\n      if (e.code !== 'MODULE_NOT_FOUND') {\n        throw e;\n      }\n    }\n    return false;\n  }\n  executeSchematic(options) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const {\n          verbose,\n          skipConfirmation,\n          interactive,\n          force,\n          dryRun,\n          registry,\n          defaults,\n          collection: collectionName,\n          ...schematicOptions\n        } = options;\n        return yield _this5.runSchematic({\n          schematicOptions,\n          schematicName: _this5.schematicName,\n          collectionName,\n          executionOptions: {\n            interactive,\n            force,\n            dryRun,\n            defaults,\n            packageRegistry: registry\n          }\n        });\n      } catch (e) {\n        if (e instanceof tools_1.NodePackageDoesNotSupportSchematics) {\n          _this5.context.logger.error(core_1.tags.oneLine`\n          The package that you are trying to add does not support schematics. You can try using\n          a different version of the package or contact the package author to add ng-add support.\n        `);\n          return 1;\n        }\n        throw e;\n      }\n    })();\n  }\n  findProjectVersion(name) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      var _a, _b;\n      const {\n        logger,\n        root\n      } = _this6.context;\n      let installedPackage;\n      try {\n        installedPackage = _this6.rootRequire.resolve((0, path_1.join)(name, 'package.json'));\n      } catch {}\n      if (installedPackage) {\n        try {\n          const installed = yield (0, package_metadata_1.fetchPackageManifest)((0, path_1.dirname)(installedPackage), logger);\n          return installed.version;\n        } catch {}\n      }\n      let projectManifest;\n      try {\n        projectManifest = yield (0, package_metadata_1.fetchPackageManifest)(root, logger);\n      } catch {}\n      if (projectManifest) {\n        const version = ((_a = projectManifest.dependencies) === null || _a === void 0 ? void 0 : _a[name]) || ((_b = projectManifest.devDependencies) === null || _b === void 0 ? void 0 : _b[name]);\n        if (version) {\n          return version;\n        }\n      }\n      return null;\n    })();\n  }\n  hasMismatchedPeer(manifest) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      for (const peer in manifest.peerDependencies) {\n        let peerIdentifier;\n        try {\n          peerIdentifier = npm_package_arg_1.default.resolve(peer, manifest.peerDependencies[peer]);\n        } catch {\n          _this7.context.logger.warn(`Invalid peer dependency ${peer} found in package.`);\n          continue;\n        }\n        if (peerIdentifier.type === 'version' || peerIdentifier.type === 'range') {\n          try {\n            const version = yield _this7.findProjectVersion(peer);\n            if (!version) {\n              continue;\n            }\n            const options = {\n              includePrerelease: true\n            };\n            if (!(0, semver_1.intersects)(version, peerIdentifier.rawSpec, options) && !(0, semver_1.satisfies)(version, peerIdentifier.rawSpec, options)) {\n              return true;\n            }\n          } catch {\n            // Not found or invalid so ignore\n            continue;\n          }\n        } else {\n          // type === 'tag' | 'file' | 'directory' | 'remote' | 'git'\n          // Cannot accurately compare these as the tag/location may have changed since install\n        }\n      }\n      return false;\n    })();\n  }\n}\nexports.AddCommandModule = AddCommandModule;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","AddCommandModule","core_1","require","tools_1","module_1","npm_package_arg_1","path_1","semver_1","workspace_schema_1","schematics_command_module_1","color_1","error_1","package_metadata_1","prompt_1","spinner_1","tty_1","version_1","packageVersionExclusions","SchematicsCommandModule","constructor","arguments","command","describe","longDescriptionPath","join","__dirname","allowPrivateSchematics","schematicName","rootRequire","createRequire","context","root","builder","argv","localYargs","positional","description","type","demandOption","option","default","strict","collectionName","getCollectionName","workflow","getOrCreateWorkflowForBuilder","collection","engine","createCollection","options","getSchematicOptions","addSchemaOptionsToCommand","error","run","_a","logger","packageManager","verbose","registry","skipConfirmation","ensureCompatibility","packageIdentifier","e","assertIsError","message","name","isPackageInstalled","validVersion","isProjectVersionValid","info","executeSchematic","spinner","Spinner","start","usingYarn","PackageManager","Yarn","colors","grey","rawSpec","packageMetadata","fetchPackageMetadata","fail","latestManifest","tags","resolve","version","peerDependencies","keys","length","succeed","toString","hasMismatchedPeer","allowPrereleases","prerelease","VERSION","full","versionExclusions","versionManifests","values","versions","filter","deprecated","satisfies","includePrerelease","sort","a","b","compare","newIdentifier","versionManifest","warn","savePackage","manifest","fetchPackageManifest","save","confirmationResponse","askConfirmation","blue","raw","isTTY","success","tempNodeModules","installTemp","undefined","tempRequire","resolvedCollectionPath","dirname","install","installedVersion","findProjectVersion","fetchSpec","v1","valid","v2","args","code","interactive","force","dryRun","defaults","schematicOptions","runSchematic","executionOptions","packageRegistry","NodePackageDoesNotSupportSchematics","oneLine","_b","installedPackage","installed","projectManifest","dependencies","devDependencies","peer","peerIdentifier","intersects"],"sources":["I:/Angular/angular-blog/node_modules/@angular/cli/src/commands/add/cli.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AddCommandModule = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst tools_1 = require(\"@angular-devkit/schematics/tools\");\nconst module_1 = require(\"module\");\nconst npm_package_arg_1 = __importDefault(require(\"npm-package-arg\"));\nconst path_1 = require(\"path\");\nconst semver_1 = require(\"semver\");\nconst workspace_schema_1 = require(\"../../../lib/config/workspace-schema\");\nconst schematics_command_module_1 = require(\"../../command-builder/schematics-command-module\");\nconst color_1 = require(\"../../utilities/color\");\nconst error_1 = require(\"../../utilities/error\");\nconst package_metadata_1 = require(\"../../utilities/package-metadata\");\nconst prompt_1 = require(\"../../utilities/prompt\");\nconst spinner_1 = require(\"../../utilities/spinner\");\nconst tty_1 = require(\"../../utilities/tty\");\nconst version_1 = require(\"../../utilities/version\");\n/**\n * The set of packages that should have certain versions excluded from consideration\n * when attempting to find a compatible version for a package.\n * The key is a package name and the value is a SemVer range of versions to exclude.\n */\nconst packageVersionExclusions = {\n    // @angular/localize@9.x and earlier versions as well as @angular/localize@10.0 prereleases do not have peer dependencies setup.\n    '@angular/localize': '<10.0.0',\n    // @angular/material@7.x versions have unbounded peer dependency ranges (>=7.0.0).\n    '@angular/material': '7.x',\n};\nclass AddCommandModule extends schematics_command_module_1.SchematicsCommandModule {\n    constructor() {\n        super(...arguments);\n        this.command = 'add <collection>';\n        this.describe = 'Adds support for an external library to your project.';\n        this.longDescriptionPath = (0, path_1.join)(__dirname, 'long-description.md');\n        this.allowPrivateSchematics = true;\n        this.schematicName = 'ng-add';\n        this.rootRequire = (0, module_1.createRequire)(this.context.root + '/');\n    }\n    async builder(argv) {\n        const localYargs = (await super.builder(argv))\n            .positional('collection', {\n            description: 'The package to be added.',\n            type: 'string',\n            demandOption: true,\n        })\n            .option('registry', { description: 'The NPM registry to use.', type: 'string' })\n            .option('verbose', {\n            description: 'Display additional details about internal operations during execution.',\n            type: 'boolean',\n            default: false,\n        })\n            .option('skip-confirmation', {\n            description: 'Skip asking a confirmation prompt before installing and executing the package. ' +\n                'Ensure package name is correct prior to using this option.',\n            type: 'boolean',\n            default: false,\n        })\n            // Prior to downloading we don't know the full schema and therefore we cannot be strict on the options.\n            // Possibly in the future update the logic to use the following syntax:\n            // `ng add @angular/localize -- --package-options`.\n            .strict(false);\n        const collectionName = await this.getCollectionName();\n        const workflow = await this.getOrCreateWorkflowForBuilder(collectionName);\n        try {\n            const collection = workflow.engine.createCollection(collectionName);\n            const options = await this.getSchematicOptions(collection, this.schematicName, workflow);\n            return this.addSchemaOptionsToCommand(localYargs, options);\n        }\n        catch (error) {\n            // During `ng add` prior to the downloading of the package\n            // we are not able to resolve and create a collection.\n            // Or when the the collection value is a path to a tarball.\n        }\n        return localYargs;\n    }\n    // eslint-disable-next-line max-lines-per-function\n    async run(options) {\n        var _a;\n        const { logger, packageManager } = this.context;\n        const { verbose, registry, collection, skipConfirmation } = options;\n        packageManager.ensureCompatibility();\n        let packageIdentifier;\n        try {\n            packageIdentifier = (0, npm_package_arg_1.default)(collection);\n        }\n        catch (e) {\n            (0, error_1.assertIsError)(e);\n            logger.error(e.message);\n            return 1;\n        }\n        if (packageIdentifier.name &&\n            packageIdentifier.registry &&\n            this.isPackageInstalled(packageIdentifier.name)) {\n            const validVersion = await this.isProjectVersionValid(packageIdentifier);\n            if (validVersion) {\n                // Already installed so just run schematic\n                logger.info('Skipping installation: Package already installed');\n                return this.executeSchematic({ ...options, collection: packageIdentifier.name });\n            }\n        }\n        const spinner = new spinner_1.Spinner();\n        spinner.start('Determining package manager...');\n        const usingYarn = packageManager.name === workspace_schema_1.PackageManager.Yarn;\n        spinner.info(`Using package manager: ${color_1.colors.grey(packageManager.name)}`);\n        if (packageIdentifier.name && packageIdentifier.type === 'tag' && !packageIdentifier.rawSpec) {\n            // only package name provided; search for viable version\n            // plus special cases for packages that did not have peer deps setup\n            spinner.start('Searching for compatible package version...');\n            let packageMetadata;\n            try {\n                packageMetadata = await (0, package_metadata_1.fetchPackageMetadata)(packageIdentifier.name, logger, {\n                    registry,\n                    usingYarn,\n                    verbose,\n                });\n            }\n            catch (e) {\n                (0, error_1.assertIsError)(e);\n                spinner.fail(`Unable to load package information from registry: ${e.message}`);\n                return 1;\n            }\n            // Start with the version tagged as `latest` if it exists\n            const latestManifest = packageMetadata.tags['latest'];\n            if (latestManifest) {\n                packageIdentifier = npm_package_arg_1.default.resolve(latestManifest.name, latestManifest.version);\n            }\n            // Adjust the version based on name and peer dependencies\n            if ((latestManifest === null || latestManifest === void 0 ? void 0 : latestManifest.peerDependencies) &&\n                Object.keys(latestManifest.peerDependencies).length === 0) {\n                spinner.succeed(`Found compatible package version: ${color_1.colors.grey(packageIdentifier.toString())}.`);\n            }\n            else if (!latestManifest || (await this.hasMismatchedPeer(latestManifest))) {\n                // 'latest' is invalid so search for most recent matching package\n                // Allow prelease versions if the CLI itself is a prerelease\n                const allowPrereleases = (0, semver_1.prerelease)(version_1.VERSION.full);\n                const versionExclusions = packageVersionExclusions[packageMetadata.name];\n                const versionManifests = Object.values(packageMetadata.versions).filter((value) => {\n                    // Prerelease versions are not stable and should not be considered by default\n                    if (!allowPrereleases && (0, semver_1.prerelease)(value.version)) {\n                        return false;\n                    }\n                    // Deprecated versions should not be used or considered\n                    if (value.deprecated) {\n                        return false;\n                    }\n                    // Excluded package versions should not be considered\n                    if (versionExclusions &&\n                        (0, semver_1.satisfies)(value.version, versionExclusions, { includePrerelease: true })) {\n                        return false;\n                    }\n                    return true;\n                });\n                // Sort in reverse SemVer order so that the newest compatible version is chosen\n                versionManifests.sort((a, b) => (0, semver_1.compare)(b.version, a.version, true));\n                let newIdentifier;\n                for (const versionManifest of versionManifests) {\n                    if (!(await this.hasMismatchedPeer(versionManifest))) {\n                        newIdentifier = npm_package_arg_1.default.resolve(versionManifest.name, versionManifest.version);\n                        break;\n                    }\n                }\n                if (!newIdentifier) {\n                    spinner.warn(\"Unable to find compatible package. Using 'latest' tag.\");\n                }\n                else {\n                    packageIdentifier = newIdentifier;\n                    spinner.succeed(`Found compatible package version: ${color_1.colors.grey(packageIdentifier.toString())}.`);\n                }\n            }\n            else {\n                spinner.succeed(`Found compatible package version: ${color_1.colors.grey(packageIdentifier.toString())}.`);\n            }\n        }\n        let collectionName = packageIdentifier.name;\n        let savePackage;\n        try {\n            spinner.start('Loading package information from registry...');\n            const manifest = await (0, package_metadata_1.fetchPackageManifest)(packageIdentifier.toString(), logger, {\n                registry,\n                verbose,\n                usingYarn,\n            });\n            savePackage = (_a = manifest['ng-add']) === null || _a === void 0 ? void 0 : _a.save;\n            collectionName = manifest.name;\n            if (await this.hasMismatchedPeer(manifest)) {\n                spinner.warn('Package has unmet peer dependencies. Adding the package may not succeed.');\n            }\n            else {\n                spinner.succeed(`Package information loaded.`);\n            }\n        }\n        catch (e) {\n            (0, error_1.assertIsError)(e);\n            spinner.fail(`Unable to fetch package information for '${packageIdentifier}': ${e.message}`);\n            return 1;\n        }\n        if (!skipConfirmation) {\n            const confirmationResponse = await (0, prompt_1.askConfirmation)(`\\nThe package ${color_1.colors.blue(packageIdentifier.raw)} will be installed and executed.\\n` +\n                'Would you like to proceed?', true, false);\n            if (!confirmationResponse) {\n                if (!(0, tty_1.isTTY)()) {\n                    logger.error('No terminal detected. ' +\n                        `'--skip-confirmation' can be used to bypass installation confirmation. ` +\n                        `Ensure package name is correct prior to '--skip-confirmation' option usage.`);\n                }\n                logger.error('Command aborted.');\n                return 1;\n            }\n        }\n        if (savePackage === false) {\n            // Temporary packages are located in a different directory\n            // Hence we need to resolve them using the temp path\n            const { success, tempNodeModules } = await packageManager.installTemp(packageIdentifier.raw, registry ? [`--registry=\"${registry}\"`] : undefined);\n            const tempRequire = (0, module_1.createRequire)(tempNodeModules + '/');\n            const resolvedCollectionPath = tempRequire.resolve((0, path_1.join)(collectionName, 'package.json'));\n            if (!success) {\n                return 1;\n            }\n            collectionName = (0, path_1.dirname)(resolvedCollectionPath);\n        }\n        else {\n            const success = await packageManager.install(packageIdentifier.raw, savePackage, registry ? [`--registry=\"${registry}\"`] : undefined);\n            if (!success) {\n                return 1;\n            }\n        }\n        return this.executeSchematic({ ...options, collection: collectionName });\n    }\n    async isProjectVersionValid(packageIdentifier) {\n        if (!packageIdentifier.name) {\n            return false;\n        }\n        let validVersion = false;\n        const installedVersion = await this.findProjectVersion(packageIdentifier.name);\n        if (installedVersion) {\n            if (packageIdentifier.type === 'range' && packageIdentifier.fetchSpec) {\n                validVersion = (0, semver_1.satisfies)(installedVersion, packageIdentifier.fetchSpec);\n            }\n            else if (packageIdentifier.type === 'version') {\n                const v1 = (0, semver_1.valid)(packageIdentifier.fetchSpec);\n                const v2 = (0, semver_1.valid)(installedVersion);\n                validVersion = v1 !== null && v1 === v2;\n            }\n            else if (!packageIdentifier.rawSpec) {\n                validVersion = true;\n            }\n        }\n        return validVersion;\n    }\n    async getCollectionName() {\n        const [, collectionName] = this.context.args.positional;\n        return collectionName;\n    }\n    isPackageInstalled(name) {\n        try {\n            this.rootRequire.resolve((0, path_1.join)(name, 'package.json'));\n            return true;\n        }\n        catch (e) {\n            (0, error_1.assertIsError)(e);\n            if (e.code !== 'MODULE_NOT_FOUND') {\n                throw e;\n            }\n        }\n        return false;\n    }\n    async executeSchematic(options) {\n        try {\n            const { verbose, skipConfirmation, interactive, force, dryRun, registry, defaults, collection: collectionName, ...schematicOptions } = options;\n            return await this.runSchematic({\n                schematicOptions,\n                schematicName: this.schematicName,\n                collectionName,\n                executionOptions: {\n                    interactive,\n                    force,\n                    dryRun,\n                    defaults,\n                    packageRegistry: registry,\n                },\n            });\n        }\n        catch (e) {\n            if (e instanceof tools_1.NodePackageDoesNotSupportSchematics) {\n                this.context.logger.error(core_1.tags.oneLine `\n          The package that you are trying to add does not support schematics. You can try using\n          a different version of the package or contact the package author to add ng-add support.\n        `);\n                return 1;\n            }\n            throw e;\n        }\n    }\n    async findProjectVersion(name) {\n        var _a, _b;\n        const { logger, root } = this.context;\n        let installedPackage;\n        try {\n            installedPackage = this.rootRequire.resolve((0, path_1.join)(name, 'package.json'));\n        }\n        catch { }\n        if (installedPackage) {\n            try {\n                const installed = await (0, package_metadata_1.fetchPackageManifest)((0, path_1.dirname)(installedPackage), logger);\n                return installed.version;\n            }\n            catch { }\n        }\n        let projectManifest;\n        try {\n            projectManifest = await (0, package_metadata_1.fetchPackageManifest)(root, logger);\n        }\n        catch { }\n        if (projectManifest) {\n            const version = ((_a = projectManifest.dependencies) === null || _a === void 0 ? void 0 : _a[name]) || ((_b = projectManifest.devDependencies) === null || _b === void 0 ? void 0 : _b[name]);\n            if (version) {\n                return version;\n            }\n        }\n        return null;\n    }\n    async hasMismatchedPeer(manifest) {\n        for (const peer in manifest.peerDependencies) {\n            let peerIdentifier;\n            try {\n                peerIdentifier = npm_package_arg_1.default.resolve(peer, manifest.peerDependencies[peer]);\n            }\n            catch {\n                this.context.logger.warn(`Invalid peer dependency ${peer} found in package.`);\n                continue;\n            }\n            if (peerIdentifier.type === 'version' || peerIdentifier.type === 'range') {\n                try {\n                    const version = await this.findProjectVersion(peer);\n                    if (!version) {\n                        continue;\n                    }\n                    const options = { includePrerelease: true };\n                    if (!(0, semver_1.intersects)(version, peerIdentifier.rawSpec, options) &&\n                        !(0, semver_1.satisfies)(version, peerIdentifier.rawSpec, options)) {\n                        return true;\n                    }\n                }\n                catch {\n                    // Not found or invalid so ignore\n                    continue;\n                }\n            }\n            else {\n                // type === 'tag' | 'file' | 'directory' | 'remote' | 'git'\n                // Cannot accurately compare these as the tag/location may have changed since install\n            }\n        }\n        return false;\n    }\n}\nexports.AddCommandModule = AddCommandModule;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}