{"ast":null,"code":"// turn an array of lines from `git ls-remote` into a thing\n// vaguely resembling a packument, where docs are a resolved ref\n\nconst semver = require('semver');\nmodule.exports = lines => finish(lines.reduce(linesToRevsReducer, {\n  versions: {},\n  'dist-tags': {},\n  refs: {},\n  shas: {}\n}));\nconst finish = revs => distTags(shaList(peelTags(revs)));\n\n// We can check out shallow clones on specific SHAs if we have a ref\nconst shaList = revs => {\n  Object.keys(revs.refs).forEach(ref => {\n    const doc = revs.refs[ref];\n    if (!revs.shas[doc.sha]) {\n      revs.shas[doc.sha] = [ref];\n    } else {\n      revs.shas[doc.sha].push(ref);\n    }\n  });\n  return revs;\n};\n\n// Replace any tags with their ^{} counterparts, if those exist\nconst peelTags = revs => {\n  Object.keys(revs.refs).filter(ref => ref.endsWith('^{}')).forEach(ref => {\n    const peeled = revs.refs[ref];\n    const unpeeled = revs.refs[ref.replace(/\\^\\{\\}$/, '')];\n    if (unpeeled) {\n      unpeeled.sha = peeled.sha;\n      delete revs.refs[ref];\n    }\n  });\n  return revs;\n};\nconst distTags = revs => {\n  // not entirely sure what situations would result in an\n  // ichabod repo, but best to be careful in Sleepy Hollow anyway\n  const HEAD = revs.refs.HEAD || /* istanbul ignore next */{};\n  const versions = Object.keys(revs.versions);\n  versions.forEach(v => {\n    // simulate a dist-tags with latest pointing at the\n    // 'latest' branch if one exists and is a version,\n    // or HEAD if not.\n    const ver = revs.versions[v];\n    if (revs.refs.latest && ver.sha === revs.refs.latest.sha) {\n      revs['dist-tags'].latest = v;\n    } else if (ver.sha === HEAD.sha) {\n      revs['dist-tags'].HEAD = v;\n      if (!revs.refs.latest) {\n        revs['dist-tags'].latest = v;\n      }\n    }\n  });\n  return revs;\n};\nconst refType = ref => {\n  if (ref.startsWith('refs/tags/')) {\n    return 'tag';\n  }\n  if (ref.startsWith('refs/heads/')) {\n    return 'branch';\n  }\n  if (ref.startsWith('refs/pull/')) {\n    return 'pull';\n  }\n  if (ref === 'HEAD') {\n    return 'head';\n  }\n  // Could be anything, ignore for now\n  /* istanbul ignore next */\n  return 'other';\n};\n\n// return the doc, or null if we should ignore it.\nconst lineToRevDoc = line => {\n  const split = line.trim().split(/\\s+/, 2);\n  if (split.length < 2) {\n    return null;\n  }\n  const sha = split[0].trim();\n  const rawRef = split[1].trim();\n  const type = refType(rawRef);\n  if (type === 'tag') {\n    // refs/tags/foo^{} is the 'peeled tag', ie the commit\n    // that is tagged by refs/tags/foo they resolve to the same\n    // content, just different objects in git's data structure.\n    // But, we care about the thing the tag POINTS to, not the tag\n    // object itself, so we only look at the peeled tag refs, and\n    // ignore the pointer.\n    // For now, though, we have to save both, because some tags\n    // don't have peels, if they were not annotated.\n    const ref = rawRef.slice('refs/tags/'.length);\n    return {\n      sha,\n      ref,\n      rawRef,\n      type\n    };\n  }\n  if (type === 'branch') {\n    const ref = rawRef.slice('refs/heads/'.length);\n    return {\n      sha,\n      ref,\n      rawRef,\n      type\n    };\n  }\n  if (type === 'pull') {\n    // NB: merged pull requests installable with #pull/123/merge\n    // for the merged pr, or #pull/123 for the PR head\n    const ref = rawRef.slice('refs/'.length).replace(/\\/head$/, '');\n    return {\n      sha,\n      ref,\n      rawRef,\n      type\n    };\n  }\n  if (type === 'head') {\n    const ref = 'HEAD';\n    return {\n      sha,\n      ref,\n      rawRef,\n      type\n    };\n  }\n\n  // at this point, all we can do is leave the ref un-munged\n  return {\n    sha,\n    ref: rawRef,\n    rawRef,\n    type\n  };\n};\nconst linesToRevsReducer = (revs, line) => {\n  const doc = lineToRevDoc(line);\n  if (!doc) {\n    return revs;\n  }\n  revs.refs[doc.ref] = doc;\n  revs.refs[doc.rawRef] = doc;\n  if (doc.type === 'tag') {\n    // try to pull a semver value out of tags like `release-v1.2.3`\n    // which is a pretty common pattern.\n    const match = !doc.ref.endsWith('^{}') && doc.ref.match(/v?(\\d+\\.\\d+\\.\\d+(?:[-+].+)?)$/);\n    if (match && semver.valid(match[1], true)) {\n      revs.versions[semver.clean(match[1], true)] = doc;\n    }\n  }\n  return revs;\n};","map":{"version":3,"names":["semver","require","module","exports","lines","finish","reduce","linesToRevsReducer","versions","refs","shas","revs","distTags","shaList","peelTags","Object","keys","forEach","ref","doc","sha","push","filter","endsWith","peeled","unpeeled","replace","HEAD","v","ver","latest","refType","startsWith","lineToRevDoc","line","split","trim","length","rawRef","type","slice","match","valid","clean"],"sources":["I:/Angular/angular-blog/node_modules/@npmcli/git/lib/lines-to-revs.js"],"sourcesContent":["// turn an array of lines from `git ls-remote` into a thing\n// vaguely resembling a packument, where docs are a resolved ref\n\nconst semver = require('semver')\n\nmodule.exports = lines => finish(lines.reduce(linesToRevsReducer, {\n  versions: {},\n  'dist-tags': {},\n  refs: {},\n  shas: {},\n}))\n\nconst finish = revs => distTags(shaList(peelTags(revs)))\n\n// We can check out shallow clones on specific SHAs if we have a ref\nconst shaList = revs => {\n  Object.keys(revs.refs).forEach(ref => {\n    const doc = revs.refs[ref]\n    if (!revs.shas[doc.sha]) {\n      revs.shas[doc.sha] = [ref]\n    } else {\n      revs.shas[doc.sha].push(ref)\n    }\n  })\n  return revs\n}\n\n// Replace any tags with their ^{} counterparts, if those exist\nconst peelTags = revs => {\n  Object.keys(revs.refs).filter(ref => ref.endsWith('^{}')).forEach(ref => {\n    const peeled = revs.refs[ref]\n    const unpeeled = revs.refs[ref.replace(/\\^\\{\\}$/, '')]\n    if (unpeeled) {\n      unpeeled.sha = peeled.sha\n      delete revs.refs[ref]\n    }\n  })\n  return revs\n}\n\nconst distTags = revs => {\n  // not entirely sure what situations would result in an\n  // ichabod repo, but best to be careful in Sleepy Hollow anyway\n  const HEAD = revs.refs.HEAD || /* istanbul ignore next */ {}\n  const versions = Object.keys(revs.versions)\n  versions.forEach(v => {\n    // simulate a dist-tags with latest pointing at the\n    // 'latest' branch if one exists and is a version,\n    // or HEAD if not.\n    const ver = revs.versions[v]\n    if (revs.refs.latest && ver.sha === revs.refs.latest.sha) {\n      revs['dist-tags'].latest = v\n    } else if (ver.sha === HEAD.sha) {\n      revs['dist-tags'].HEAD = v\n      if (!revs.refs.latest) {\n        revs['dist-tags'].latest = v\n      }\n    }\n  })\n  return revs\n}\n\nconst refType = ref => {\n  if (ref.startsWith('refs/tags/')) {\n    return 'tag'\n  }\n  if (ref.startsWith('refs/heads/')) {\n    return 'branch'\n  }\n  if (ref.startsWith('refs/pull/')) {\n    return 'pull'\n  }\n  if (ref === 'HEAD') {\n    return 'head'\n  }\n  // Could be anything, ignore for now\n  /* istanbul ignore next */\n  return 'other'\n}\n\n// return the doc, or null if we should ignore it.\nconst lineToRevDoc = line => {\n  const split = line.trim().split(/\\s+/, 2)\n  if (split.length < 2) {\n    return null\n  }\n\n  const sha = split[0].trim()\n  const rawRef = split[1].trim()\n  const type = refType(rawRef)\n\n  if (type === 'tag') {\n    // refs/tags/foo^{} is the 'peeled tag', ie the commit\n    // that is tagged by refs/tags/foo they resolve to the same\n    // content, just different objects in git's data structure.\n    // But, we care about the thing the tag POINTS to, not the tag\n    // object itself, so we only look at the peeled tag refs, and\n    // ignore the pointer.\n    // For now, though, we have to save both, because some tags\n    // don't have peels, if they were not annotated.\n    const ref = rawRef.slice('refs/tags/'.length)\n    return { sha, ref, rawRef, type }\n  }\n\n  if (type === 'branch') {\n    const ref = rawRef.slice('refs/heads/'.length)\n    return { sha, ref, rawRef, type }\n  }\n\n  if (type === 'pull') {\n    // NB: merged pull requests installable with #pull/123/merge\n    // for the merged pr, or #pull/123 for the PR head\n    const ref = rawRef.slice('refs/'.length).replace(/\\/head$/, '')\n    return { sha, ref, rawRef, type }\n  }\n\n  if (type === 'head') {\n    const ref = 'HEAD'\n    return { sha, ref, rawRef, type }\n  }\n\n  // at this point, all we can do is leave the ref un-munged\n  return { sha, ref: rawRef, rawRef, type }\n}\n\nconst linesToRevsReducer = (revs, line) => {\n  const doc = lineToRevDoc(line)\n\n  if (!doc) {\n    return revs\n  }\n\n  revs.refs[doc.ref] = doc\n  revs.refs[doc.rawRef] = doc\n\n  if (doc.type === 'tag') {\n    // try to pull a semver value out of tags like `release-v1.2.3`\n    // which is a pretty common pattern.\n    const match = !doc.ref.endsWith('^{}') &&\n      doc.ref.match(/v?(\\d+\\.\\d+\\.\\d+(?:[-+].+)?)$/)\n    if (match && semver.valid(match[1], true)) {\n      revs.versions[semver.clean(match[1], true)] = doc\n    }\n  }\n\n  return revs\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}