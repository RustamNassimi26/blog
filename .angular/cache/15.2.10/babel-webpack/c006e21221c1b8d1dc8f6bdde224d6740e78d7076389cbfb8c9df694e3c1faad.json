{"ast":null,"code":"// put javascript in here\n'use strict';\n\nconst Parser = require('jsonparse');\nconst Minipass = require('minipass');\nclass JSONStreamError extends Error {\n  constructor(err, caller) {\n    super(err.message);\n    Error.captureStackTrace(this, caller || this.constructor);\n  }\n  get name() {\n    return 'JSONStreamError';\n  }\n  set name(n) {}\n}\nconst check = (x, y) => typeof x === 'string' ? String(y) === x : x && typeof x.test === 'function' ? x.test(y) : typeof x === 'boolean' || typeof x === 'object' ? x : typeof x === 'function' ? x(y) : false;\nconst _parser = Symbol('_parser');\nconst _onValue = Symbol('_onValue');\nconst _onTokenOriginal = Symbol('_onTokenOriginal');\nconst _onToken = Symbol('_onToken');\nconst _onError = Symbol('_onError');\nconst _count = Symbol('_count');\nconst _path = Symbol('_path');\nconst _map = Symbol('_map');\nconst _root = Symbol('_root');\nconst _header = Symbol('_header');\nconst _footer = Symbol('_footer');\nconst _setHeaderFooter = Symbol('_setHeaderFooter');\nconst _ending = Symbol('_ending');\nclass JSONStream extends Minipass {\n  constructor(opts = {}) {\n    super({\n      ...opts,\n      objectMode: true\n    });\n    this[_ending] = false;\n    const parser = this[_parser] = new Parser();\n    parser.onValue = value => this[_onValue](value);\n    this[_onTokenOriginal] = parser.onToken;\n    parser.onToken = (token, value) => this[_onToken](token, value);\n    parser.onError = er => this[_onError](er);\n    this[_count] = 0;\n    this[_path] = typeof opts.path === 'string' ? opts.path.split('.').map(e => e === '$*' ? {\n      emitKey: true\n    } : e === '*' ? true : e === '' ? {\n      recurse: true\n    } : e) : Array.isArray(opts.path) && opts.path.length ? opts.path : null;\n    this[_map] = typeof opts.map === 'function' ? opts.map : null;\n    this[_root] = null;\n    this[_header] = null;\n    this[_footer] = null;\n    this[_count] = 0;\n  }\n  [_setHeaderFooter](key, value) {\n    // header has not been emitted yet\n    if (this[_header] !== false) {\n      this[_header] = this[_header] || {};\n      this[_header][key] = value;\n    }\n\n    // footer has not been emitted yet but header has\n    if (this[_footer] !== false && this[_header] === false) {\n      this[_footer] = this[_footer] || {};\n      this[_footer][key] = value;\n    }\n  }\n  [_onError](er) {\n    // error will always happen during a write() call.\n    const caller = this[_ending] ? this.end : this.write;\n    this[_ending] = false;\n    return this.emit('error', new JSONStreamError(er, caller));\n  }\n  [_onToken](token, value) {\n    const parser = this[_parser];\n    this[_onTokenOriginal].call(parser, token, value);\n    if (parser.stack.length === 0) {\n      if (this[_root]) {\n        const root = this[_root];\n        if (!this[_path]) super.write(root);\n        this[_root] = null;\n        this[_count] = 0;\n      }\n    }\n  }\n  [_onValue](value) {\n    const parser = this[_parser];\n    // the LAST onValue encountered is the root object.\n    // just overwrite it each time.\n    this[_root] = value;\n    if (!this[_path]) return;\n    let i = 0; // iterates on path\n    let j = 0; // iterates on stack\n    let emitKey = false;\n    let emitPath = false;\n    while (i < this[_path].length) {\n      const key = this[_path][i];\n      j++;\n      if (key && !key.recurse) {\n        const c = j === parser.stack.length ? parser : parser.stack[j];\n        if (!c) return;\n        if (!check(key, c.key)) {\n          this[_setHeaderFooter](c.key, value);\n          return;\n        }\n        emitKey = !!key.emitKey;\n        emitPath = !!key.emitPath;\n        i++;\n      } else {\n        i++;\n        if (i >= this[_path].length) return;\n        const nextKey = this[_path][i];\n        if (!nextKey) return;\n        while (true) {\n          const c = j === parser.stack.length ? parser : parser.stack[j];\n          if (!c) return;\n          if (check(nextKey, c.key)) {\n            i++;\n            if (!Object.isFrozen(parser.stack[j])) parser.stack[j].value = null;\n            break;\n          } else {\n            this[_setHeaderFooter](c.key, value);\n          }\n          j++;\n        }\n      }\n    }\n\n    // emit header\n    if (this[_header]) {\n      const header = this[_header];\n      this[_header] = false;\n      this.emit('header', header);\n    }\n    if (j !== parser.stack.length) return;\n    this[_count]++;\n    const actualPath = parser.stack.slice(1).map(e => e.key).concat([parser.key]);\n    if (value !== null && value !== undefined) {\n      const data = this[_map] ? this[_map](value, actualPath) : value;\n      if (data !== null && data !== undefined) {\n        const emit = emitKey || emitPath ? {\n          value: data\n        } : data;\n        if (emitKey) emit.key = parser.key;\n        if (emitPath) emit.path = actualPath;\n        super.write(emit);\n      }\n    }\n    if (parser.value) delete parser.value[parser.key];\n    for (const k of parser.stack) {\n      k.value = null;\n    }\n  }\n  write(chunk, encoding, cb) {\n    if (typeof encoding === 'function') cb = encoding, encoding = null;\n    if (typeof chunk === 'string') chunk = Buffer.from(chunk, encoding);else if (!Buffer.isBuffer(chunk)) return this.emit('error', new TypeError('Can only parse JSON from string or buffer input'));\n    this[_parser].write(chunk);\n    if (cb) cb();\n    return this.flowing;\n  }\n  end(chunk, encoding, cb) {\n    this[_ending] = true;\n    if (typeof encoding === 'function') cb = encoding, encoding = null;\n    if (typeof chunk === 'function') cb = chunk, chunk = null;\n    if (chunk) this.write(chunk, encoding);\n    if (cb) this.once('end', cb);\n    const h = this[_header];\n    this[_header] = null;\n    const f = this[_footer];\n    this[_footer] = null;\n    if (h) this.emit('header', h);\n    if (f) this.emit('footer', f);\n    return super.end();\n  }\n  static get JSONStreamError() {\n    return JSONStreamError;\n  }\n  static parse(path, map) {\n    return new JSONStream({\n      path,\n      map\n    });\n  }\n}\nmodule.exports = JSONStream;","map":{"version":3,"names":["Parser","require","Minipass","JSONStreamError","Error","constructor","err","caller","message","captureStackTrace","name","n","check","x","y","String","test","_parser","Symbol","_onValue","_onTokenOriginal","_onToken","_onError","_count","_path","_map","_root","_header","_footer","_setHeaderFooter","_ending","JSONStream","opts","objectMode","parser","onValue","value","onToken","token","onError","er","path","split","map","e","emitKey","recurse","Array","isArray","length","key","end","write","emit","call","stack","root","i","j","emitPath","c","nextKey","Object","isFrozen","header","actualPath","slice","concat","undefined","data","k","chunk","encoding","cb","Buffer","from","isBuffer","TypeError","flowing","once","h","f","parse","module","exports"],"sources":["I:/Angular/angular-blog/node_modules/minipass-json-stream/index.js"],"sourcesContent":["// put javascript in here\n'use strict'\n\nconst Parser = require('jsonparse')\nconst Minipass = require('minipass')\n\nclass JSONStreamError extends Error {\n  constructor (err, caller) {\n    super(err.message)\n    Error.captureStackTrace(this, caller || this.constructor)\n  }\n  get name () {\n    return 'JSONStreamError'\n  }\n  set name (n) {}\n}\n\nconst check = (x, y) =>\n  typeof x === 'string' ? String(y) === x\n  : x && typeof x.test === 'function' ? x.test(y)\n  : typeof x === 'boolean' || typeof x === 'object' ? x\n  : typeof x === 'function' ? x(y)\n  : false\n\nconst _parser = Symbol('_parser')\nconst _onValue = Symbol('_onValue')\nconst _onTokenOriginal = Symbol('_onTokenOriginal')\nconst _onToken = Symbol('_onToken')\nconst _onError = Symbol('_onError')\nconst _count = Symbol('_count')\nconst _path = Symbol('_path')\nconst _map = Symbol('_map')\nconst _root = Symbol('_root')\nconst _header = Symbol('_header')\nconst _footer = Symbol('_footer')\nconst _setHeaderFooter = Symbol('_setHeaderFooter')\nconst _ending = Symbol('_ending')\n\nclass JSONStream extends Minipass {\n  constructor (opts = {}) {\n    super({\n      ...opts,\n      objectMode: true,\n    })\n\n    this[_ending] = false\n    const parser = this[_parser] = new Parser()\n    parser.onValue = value => this[_onValue](value)\n    this[_onTokenOriginal] = parser.onToken\n    parser.onToken = (token, value) => this[_onToken](token, value)\n    parser.onError = er => this[_onError](er)\n\n    this[_count] = 0\n    this[_path] = typeof opts.path === 'string'\n      ? opts.path.split('.').map(e =>\n          e === '$*' ? { emitKey: true }\n          : e === '*' ? true\n          : e === '' ? { recurse: true }\n          : e)\n      : Array.isArray(opts.path) && opts.path.length ? opts.path\n      : null\n\n    this[_map] = typeof opts.map === 'function' ? opts.map : null\n    this[_root] = null\n    this[_header] = null\n    this[_footer] = null\n    this[_count] = 0\n  }\n\n  [_setHeaderFooter] (key, value) {\n    // header has not been emitted yet\n    if (this[_header] !== false) {\n      this[_header] = this[_header] || {}\n      this[_header][key] = value\n    }\n\n    // footer has not been emitted yet but header has\n    if (this[_footer] !== false && this[_header] === false) {\n      this[_footer] = this[_footer] || {}\n      this[_footer][key] = value\n    }\n  }\n\n  [_onError] (er) {\n    // error will always happen during a write() call.\n    const caller = this[_ending] ? this.end : this.write\n    this[_ending] = false\n    return this.emit('error', new JSONStreamError(er, caller))\n  }\n\n  [_onToken] (token, value) {\n    const parser = this[_parser]\n    this[_onTokenOriginal].call(parser, token, value)\n    if (parser.stack.length === 0) {\n      if (this[_root]) {\n        const root = this[_root]\n        if (!this[_path])\n          super.write(root)\n        this[_root] = null\n        this[_count] = 0\n      }\n    }\n  }\n\n  [_onValue] (value) {\n    const parser = this[_parser]\n    // the LAST onValue encountered is the root object.\n    // just overwrite it each time.\n    this[_root] = value\n\n    if(!this[_path]) return\n\n    let i = 0 // iterates on path\n    let j  = 0 // iterates on stack\n    let emitKey = false\n    let emitPath = false\n    while (i < this[_path].length) {\n      const key = this[_path][i]\n      j++\n\n      if (key && !key.recurse) {\n        const c = (j === parser.stack.length) ? parser : parser.stack[j]\n        if (!c) return\n        if (!check(key, c.key)) {\n          this[_setHeaderFooter](c.key, value)\n          return\n        }\n        emitKey = !!key.emitKey;\n        emitPath = !!key.emitPath;\n        i++\n      } else {\n        i++\n        if (i >= this[_path].length)\n          return\n        const nextKey = this[_path][i]\n        if (!nextKey)\n          return\n        while (true) {\n          const c = (j === parser.stack.length) ? parser : parser.stack[j]\n          if (!c) return\n          if (check(nextKey, c.key)) {\n            i++\n            if (!Object.isFrozen(parser.stack[j]))\n              parser.stack[j].value = null\n            break\n          } else {\n            this[_setHeaderFooter](c.key, value)\n          }\n          j++\n        }\n      }\n    }\n\n    // emit header\n    if (this[_header]) {\n      const header = this[_header]\n      this[_header] = false\n      this.emit('header', header)\n    }\n    if (j !== parser.stack.length) return\n\n    this[_count] ++\n    const actualPath = parser.stack.slice(1)\n      .map(e => e.key).concat([parser.key])\n    if (value !== null && value !== undefined) {\n      const data = this[_map] ? this[_map](value, actualPath) : value\n      if (data !== null && data !== undefined) {\n        const emit = emitKey || emitPath ? { value: data } : data\n        if (emitKey)\n          emit.key = parser.key\n        if (emitPath)\n          emit.path = actualPath\n        super.write(emit)\n      }\n    }\n\n    if (parser.value)\n      delete parser.value[parser.key]\n\n    for (const k of parser.stack) {\n      k.value = null\n    }\n  }\n\n  write (chunk, encoding, cb) {\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = null\n    if (typeof chunk === 'string')\n      chunk = Buffer.from(chunk, encoding)\n    else if (!Buffer.isBuffer(chunk))\n      return this.emit('error', new TypeError(\n        'Can only parse JSON from string or buffer input'))\n    this[_parser].write(chunk)\n    if (cb)\n      cb()\n    return this.flowing\n  }\n\n  end (chunk, encoding, cb) {\n    this[_ending] = true\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = null\n    if (typeof chunk === 'function')\n      cb = chunk, chunk = null\n    if (chunk)\n      this.write(chunk, encoding)\n    if (cb)\n      this.once('end', cb)\n\n    const h = this[_header]\n    this[_header] = null\n    const f = this[_footer]\n    this[_footer] = null\n    if (h)\n      this.emit('header', h)\n    if (f)\n      this.emit('footer', f)\n    return super.end()\n  }\n\n  static get JSONStreamError () { return JSONStreamError }\n  static parse (path, map) {\n    return new JSONStream({path, map})\n  }\n}\n\nmodule.exports = JSONStream\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}