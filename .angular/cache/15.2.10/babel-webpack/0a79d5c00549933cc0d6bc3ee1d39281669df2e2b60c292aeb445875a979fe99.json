{"ast":null,"code":"const url = require('url');\nconst lastIndexOfBefore = (str, char, beforeChar) => {\n  const startPosition = str.indexOf(beforeChar);\n  return str.lastIndexOf(char, startPosition > -1 ? startPosition : Infinity);\n};\nconst safeUrl = u => {\n  try {\n    return new url.URL(u);\n  } catch {\n    // this fn should never throw\n  }\n};\n\n// accepts input like git:github.com:user/repo and inserts the // after the first :\nconst correctProtocol = (arg, protocols) => {\n  const firstColon = arg.indexOf(':');\n  const proto = arg.slice(0, firstColon + 1);\n  if (Object.prototype.hasOwnProperty.call(protocols, proto)) {\n    return arg;\n  }\n  const firstAt = arg.indexOf('@');\n  if (firstAt > -1) {\n    if (firstAt > firstColon) {\n      return `git+ssh://${arg}`;\n    } else {\n      return arg;\n    }\n  }\n  const doubleSlash = arg.indexOf('//');\n  if (doubleSlash === firstColon + 1) {\n    return arg;\n  }\n  return `${arg.slice(0, firstColon + 1)}//${arg.slice(firstColon + 1)}`;\n};\n\n// attempt to correct an scp style url so that it will parse with `new URL()`\nconst correctUrl = giturl => {\n  // ignore @ that come after the first hash since the denotes the start\n  // of a committish which can contain @ characters\n  const firstAt = lastIndexOfBefore(giturl, '@', '#');\n  // ignore colons that come after the hash since that could include colons such as:\n  // git@github.com:user/package-2#semver:^1.0.0\n  const lastColonBeforeHash = lastIndexOfBefore(giturl, ':', '#');\n  if (lastColonBeforeHash > firstAt) {\n    // the last : comes after the first @ (or there is no @)\n    // like it would in:\n    // proto://hostname.com:user/repo\n    // username@hostname.com:user/repo\n    // :password@hostname.com:user/repo\n    // username:password@hostname.com:user/repo\n    // proto://username@hostname.com:user/repo\n    // proto://:password@hostname.com:user/repo\n    // proto://username:password@hostname.com:user/repo\n    // then we replace the last : with a / to create a valid path\n    giturl = giturl.slice(0, lastColonBeforeHash) + '/' + giturl.slice(lastColonBeforeHash + 1);\n  }\n  if (lastIndexOfBefore(giturl, ':', '#') === -1 && giturl.indexOf('//') === -1) {\n    // we have no : at all\n    // as it would be in:\n    // username@hostname.com/user/repo\n    // then we prepend a protocol\n    giturl = `git+ssh://${giturl}`;\n  }\n  return giturl;\n};\nmodule.exports = (giturl, protocols) => {\n  const withProtocol = protocols ? correctProtocol(giturl, protocols) : giturl;\n  return safeUrl(withProtocol) || safeUrl(correctUrl(withProtocol));\n};","map":{"version":3,"names":["url","require","lastIndexOfBefore","str","char","beforeChar","startPosition","indexOf","lastIndexOf","Infinity","safeUrl","u","URL","correctProtocol","arg","protocols","firstColon","proto","slice","Object","prototype","hasOwnProperty","call","firstAt","doubleSlash","correctUrl","giturl","lastColonBeforeHash","module","exports","withProtocol"],"sources":["I:/Angular/angular-blog/node_modules/hosted-git-info/lib/parse-url.js"],"sourcesContent":["const url = require('url')\n\nconst lastIndexOfBefore = (str, char, beforeChar) => {\n  const startPosition = str.indexOf(beforeChar)\n  return str.lastIndexOf(char, startPosition > -1 ? startPosition : Infinity)\n}\n\nconst safeUrl = (u) => {\n  try {\n    return new url.URL(u)\n  } catch {\n    // this fn should never throw\n  }\n}\n\n// accepts input like git:github.com:user/repo and inserts the // after the first :\nconst correctProtocol = (arg, protocols) => {\n  const firstColon = arg.indexOf(':')\n  const proto = arg.slice(0, firstColon + 1)\n  if (Object.prototype.hasOwnProperty.call(protocols, proto)) {\n    return arg\n  }\n\n  const firstAt = arg.indexOf('@')\n  if (firstAt > -1) {\n    if (firstAt > firstColon) {\n      return `git+ssh://${arg}`\n    } else {\n      return arg\n    }\n  }\n\n  const doubleSlash = arg.indexOf('//')\n  if (doubleSlash === firstColon + 1) {\n    return arg\n  }\n\n  return `${arg.slice(0, firstColon + 1)}//${arg.slice(firstColon + 1)}`\n}\n\n// attempt to correct an scp style url so that it will parse with `new URL()`\nconst correctUrl = (giturl) => {\n  // ignore @ that come after the first hash since the denotes the start\n  // of a committish which can contain @ characters\n  const firstAt = lastIndexOfBefore(giturl, '@', '#')\n  // ignore colons that come after the hash since that could include colons such as:\n  // git@github.com:user/package-2#semver:^1.0.0\n  const lastColonBeforeHash = lastIndexOfBefore(giturl, ':', '#')\n\n  if (lastColonBeforeHash > firstAt) {\n    // the last : comes after the first @ (or there is no @)\n    // like it would in:\n    // proto://hostname.com:user/repo\n    // username@hostname.com:user/repo\n    // :password@hostname.com:user/repo\n    // username:password@hostname.com:user/repo\n    // proto://username@hostname.com:user/repo\n    // proto://:password@hostname.com:user/repo\n    // proto://username:password@hostname.com:user/repo\n    // then we replace the last : with a / to create a valid path\n    giturl = giturl.slice(0, lastColonBeforeHash) + '/' + giturl.slice(lastColonBeforeHash + 1)\n  }\n\n  if (lastIndexOfBefore(giturl, ':', '#') === -1 && giturl.indexOf('//') === -1) {\n    // we have no : at all\n    // as it would be in:\n    // username@hostname.com/user/repo\n    // then we prepend a protocol\n    giturl = `git+ssh://${giturl}`\n  }\n\n  return giturl\n}\n\nmodule.exports = (giturl, protocols) => {\n  const withProtocol = protocols ? correctProtocol(giturl, protocols) : giturl\n  return safeUrl(withProtocol) || safeUrl(correctUrl(withProtocol))\n}\n"],"mappings":"AAAA,MAAMA,GAAG,GAAGC,OAAO,CAAC,KAAK,CAAC;AAE1B,MAAMC,iBAAiB,GAAG,CAACC,GAAG,EAAEC,IAAI,EAAEC,UAAU,KAAK;EACnD,MAAMC,aAAa,GAAGH,GAAG,CAACI,OAAO,CAACF,UAAU,CAAC;EAC7C,OAAOF,GAAG,CAACK,WAAW,CAACJ,IAAI,EAAEE,aAAa,GAAG,CAAC,CAAC,GAAGA,aAAa,GAAGG,QAAQ,CAAC;AAC7E,CAAC;AAED,MAAMC,OAAO,GAAIC,CAAC,IAAK;EACrB,IAAI;IACF,OAAO,IAAIX,GAAG,CAACY,GAAG,CAACD,CAAC,CAAC;EACvB,CAAC,CAAC,MAAM;IACN;EAAA;AAEJ,CAAC;;AAED;AACA,MAAME,eAAe,GAAG,CAACC,GAAG,EAAEC,SAAS,KAAK;EAC1C,MAAMC,UAAU,GAAGF,GAAG,CAACP,OAAO,CAAC,GAAG,CAAC;EACnC,MAAMU,KAAK,GAAGH,GAAG,CAACI,KAAK,CAAC,CAAC,EAAEF,UAAU,GAAG,CAAC,CAAC;EAC1C,IAAIG,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACP,SAAS,EAAEE,KAAK,CAAC,EAAE;IAC1D,OAAOH,GAAG;EACZ;EAEA,MAAMS,OAAO,GAAGT,GAAG,CAACP,OAAO,CAAC,GAAG,CAAC;EAChC,IAAIgB,OAAO,GAAG,CAAC,CAAC,EAAE;IAChB,IAAIA,OAAO,GAAGP,UAAU,EAAE;MACxB,OAAQ,aAAYF,GAAI,EAAC;IAC3B,CAAC,MAAM;MACL,OAAOA,GAAG;IACZ;EACF;EAEA,MAAMU,WAAW,GAAGV,GAAG,CAACP,OAAO,CAAC,IAAI,CAAC;EACrC,IAAIiB,WAAW,KAAKR,UAAU,GAAG,CAAC,EAAE;IAClC,OAAOF,GAAG;EACZ;EAEA,OAAQ,GAAEA,GAAG,CAACI,KAAK,CAAC,CAAC,EAAEF,UAAU,GAAG,CAAC,CAAE,KAAIF,GAAG,CAACI,KAAK,CAACF,UAAU,GAAG,CAAC,CAAE,EAAC;AACxE,CAAC;;AAED;AACA,MAAMS,UAAU,GAAIC,MAAM,IAAK;EAC7B;EACA;EACA,MAAMH,OAAO,GAAGrB,iBAAiB,CAACwB,MAAM,EAAE,GAAG,EAAE,GAAG,CAAC;EACnD;EACA;EACA,MAAMC,mBAAmB,GAAGzB,iBAAiB,CAACwB,MAAM,EAAE,GAAG,EAAE,GAAG,CAAC;EAE/D,IAAIC,mBAAmB,GAAGJ,OAAO,EAAE;IACjC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACAG,MAAM,GAAGA,MAAM,CAACR,KAAK,CAAC,CAAC,EAAES,mBAAmB,CAAC,GAAG,GAAG,GAAGD,MAAM,CAACR,KAAK,CAACS,mBAAmB,GAAG,CAAC,CAAC;EAC7F;EAEA,IAAIzB,iBAAiB,CAACwB,MAAM,EAAE,GAAG,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC,IAAIA,MAAM,CAACnB,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;IAC7E;IACA;IACA;IACA;IACAmB,MAAM,GAAI,aAAYA,MAAO,EAAC;EAChC;EAEA,OAAOA,MAAM;AACf,CAAC;AAEDE,MAAM,CAACC,OAAO,GAAG,CAACH,MAAM,EAAEX,SAAS,KAAK;EACtC,MAAMe,YAAY,GAAGf,SAAS,GAAGF,eAAe,CAACa,MAAM,EAAEX,SAAS,CAAC,GAAGW,MAAM;EAC5E,OAAOhB,OAAO,CAACoB,YAAY,CAAC,IAAIpB,OAAO,CAACe,UAAU,CAACK,YAAY,CAAC,CAAC;AACnE,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}