{"ast":null,"code":"'use strict';\n\nconst {\n  spawn\n} = require('child_process');\nconst os = require('os');\nconst which = require('which');\nconst escape = require('./escape.js');\n\n// 'extra' object is for decorating the error a bit more\nconst promiseSpawn = (cmd, args, opts = {}, extra = {}) => {\n  if (opts.shell) {\n    return spawnWithShell(cmd, args, opts, extra);\n  }\n  let proc;\n  const p = new Promise((res, rej) => {\n    proc = spawn(cmd, args, opts);\n    const stdout = [];\n    const stderr = [];\n    const reject = er => rej(Object.assign(er, {\n      cmd,\n      args,\n      ...stdioResult(stdout, stderr, opts),\n      ...extra\n    }));\n    proc.on('error', reject);\n    if (proc.stdout) {\n      proc.stdout.on('data', c => stdout.push(c)).on('error', reject);\n      proc.stdout.on('error', er => reject(er));\n    }\n    if (proc.stderr) {\n      proc.stderr.on('data', c => stderr.push(c)).on('error', reject);\n      proc.stderr.on('error', er => reject(er));\n    }\n    proc.on('close', (code, signal) => {\n      const result = {\n        cmd,\n        args,\n        code,\n        signal,\n        ...stdioResult(stdout, stderr, opts),\n        ...extra\n      };\n      if (code || signal) {\n        rej(Object.assign(new Error('command failed'), result));\n      } else {\n        res(result);\n      }\n    });\n  });\n  p.stdin = proc.stdin;\n  p.process = proc;\n  return p;\n};\nconst spawnWithShell = (cmd, args, opts, extra) => {\n  let command = opts.shell;\n  // if shell is set to true, we use a platform default. we can't let the core\n  // spawn method decide this for us because we need to know what shell is in use\n  // ahead of time so that we can escape arguments properly. we don't need coverage here.\n  if (command === true) {\n    // istanbul ignore next\n    command = process.platform === 'win32' ? process.env.ComSpec : 'sh';\n  }\n  const options = {\n    ...opts,\n    shell: false\n  };\n  const realArgs = [];\n  let script = cmd;\n\n  // first, determine if we're in windows because if we are we need to know if we're\n  // running an .exe or a .cmd/.bat since the latter requires extra escaping\n  const isCmd = /(?:^|\\\\)cmd(?:\\.exe)?$/i.test(command);\n  if (isCmd) {\n    let doubleEscape = false;\n\n    // find the actual command we're running\n    let initialCmd = '';\n    let insideQuotes = false;\n    for (let i = 0; i < cmd.length; ++i) {\n      const char = cmd.charAt(i);\n      if (char === ' ' && !insideQuotes) {\n        break;\n      }\n      initialCmd += char;\n      if (char === '\"' || char === \"'\") {\n        insideQuotes = !insideQuotes;\n      }\n    }\n    let pathToInitial;\n    try {\n      pathToInitial = which.sync(initialCmd, {\n        path: options.env && options.env.PATH || process.env.PATH,\n        pathext: options.env && options.env.PATHEXT || process.env.PATHEXT\n      }).toLowerCase();\n    } catch (err) {\n      pathToInitial = initialCmd.toLowerCase();\n    }\n    doubleEscape = pathToInitial.endsWith('.cmd') || pathToInitial.endsWith('.bat');\n    for (const arg of args) {\n      script += ` ${escape.cmd(arg, doubleEscape)}`;\n    }\n    realArgs.push('/d', '/s', '/c', script);\n    options.windowsVerbatimArguments = true;\n  } else {\n    for (const arg of args) {\n      script += ` ${escape.sh(arg)}`;\n    }\n    realArgs.push('-c', script);\n  }\n  return promiseSpawn(command, realArgs, options, extra);\n};\n\n// open a file with the default application as defined by the user's OS\nconst open = (_args, opts = {}, extra = {}) => {\n  const options = {\n    ...opts,\n    shell: true\n  };\n  const args = [].concat(_args);\n  let platform = process.platform;\n  // process.platform === 'linux' may actually indicate WSL, if that's the case\n  // we want to treat things as win32 anyway so the host can open the argument\n  if (platform === 'linux' && os.release().toLowerCase().includes('microsoft')) {\n    platform = 'win32';\n  }\n  let command = options.command;\n  if (!command) {\n    if (platform === 'win32') {\n      // spawnWithShell does not do the additional os.release() check, so we\n      // have to force the shell here to make sure we treat WSL as windows.\n      options.shell = process.env.ComSpec;\n      // also, the start command accepts a title so to make sure that we don't\n      // accidentally interpret the first arg as the title, we stick an empty\n      // string immediately after the start command\n      command = 'start \"\"';\n    } else if (platform === 'darwin') {\n      command = 'open';\n    } else {\n      command = 'xdg-open';\n    }\n  }\n  return spawnWithShell(command, args, options, extra);\n};\npromiseSpawn.open = open;\nconst isPipe = (stdio = 'pipe', fd) => {\n  if (stdio === 'pipe' || stdio === null) {\n    return true;\n  }\n  if (Array.isArray(stdio)) {\n    return isPipe(stdio[fd], fd);\n  }\n  return false;\n};\nconst stdioResult = (stdout, stderr, {\n  stdioString = true,\n  stdio\n}) => {\n  const result = {\n    stdout: null,\n    stderr: null\n  };\n\n  // stdio is [stdin, stdout, stderr]\n  if (isPipe(stdio, 1)) {\n    result.stdout = Buffer.concat(stdout);\n    if (stdioString) {\n      result.stdout = result.stdout.toString().trim();\n    }\n  }\n  if (isPipe(stdio, 2)) {\n    result.stderr = Buffer.concat(stderr);\n    if (stdioString) {\n      result.stderr = result.stderr.toString().trim();\n    }\n  }\n  return result;\n};\nmodule.exports = promiseSpawn;","map":{"version":3,"names":["spawn","require","os","which","escape","promiseSpawn","cmd","args","opts","extra","shell","spawnWithShell","proc","p","Promise","res","rej","stdout","stderr","reject","er","Object","assign","stdioResult","on","c","push","code","signal","result","Error","stdin","process","command","platform","env","ComSpec","options","realArgs","script","isCmd","test","doubleEscape","initialCmd","insideQuotes","i","length","char","charAt","pathToInitial","sync","path","PATH","pathext","PATHEXT","toLowerCase","err","endsWith","arg","windowsVerbatimArguments","sh","open","_args","concat","release","includes","isPipe","stdio","fd","Array","isArray","stdioString","Buffer","toString","trim","module","exports"],"sources":["I:/Angular/angular-blog/node_modules/@npmcli/promise-spawn/lib/index.js"],"sourcesContent":["'use strict'\n\nconst { spawn } = require('child_process')\nconst os = require('os')\nconst which = require('which')\n\nconst escape = require('./escape.js')\n\n// 'extra' object is for decorating the error a bit more\nconst promiseSpawn = (cmd, args, opts = {}, extra = {}) => {\n  if (opts.shell) {\n    return spawnWithShell(cmd, args, opts, extra)\n  }\n\n  let proc\n\n  const p = new Promise((res, rej) => {\n    proc = spawn(cmd, args, opts)\n\n    const stdout = []\n    const stderr = []\n\n    const reject = er => rej(Object.assign(er, {\n      cmd,\n      args,\n      ...stdioResult(stdout, stderr, opts),\n      ...extra,\n    }))\n\n    proc.on('error', reject)\n\n    if (proc.stdout) {\n      proc.stdout.on('data', c => stdout.push(c)).on('error', reject)\n      proc.stdout.on('error', er => reject(er))\n    }\n\n    if (proc.stderr) {\n      proc.stderr.on('data', c => stderr.push(c)).on('error', reject)\n      proc.stderr.on('error', er => reject(er))\n    }\n\n    proc.on('close', (code, signal) => {\n      const result = {\n        cmd,\n        args,\n        code,\n        signal,\n        ...stdioResult(stdout, stderr, opts),\n        ...extra,\n      }\n\n      if (code || signal) {\n        rej(Object.assign(new Error('command failed'), result))\n      } else {\n        res(result)\n      }\n    })\n  })\n\n  p.stdin = proc.stdin\n  p.process = proc\n  return p\n}\n\nconst spawnWithShell = (cmd, args, opts, extra) => {\n  let command = opts.shell\n  // if shell is set to true, we use a platform default. we can't let the core\n  // spawn method decide this for us because we need to know what shell is in use\n  // ahead of time so that we can escape arguments properly. we don't need coverage here.\n  if (command === true) {\n    // istanbul ignore next\n    command = process.platform === 'win32' ? process.env.ComSpec : 'sh'\n  }\n\n  const options = { ...opts, shell: false }\n  const realArgs = []\n  let script = cmd\n\n  // first, determine if we're in windows because if we are we need to know if we're\n  // running an .exe or a .cmd/.bat since the latter requires extra escaping\n  const isCmd = /(?:^|\\\\)cmd(?:\\.exe)?$/i.test(command)\n  if (isCmd) {\n    let doubleEscape = false\n\n    // find the actual command we're running\n    let initialCmd = ''\n    let insideQuotes = false\n    for (let i = 0; i < cmd.length; ++i) {\n      const char = cmd.charAt(i)\n      if (char === ' ' && !insideQuotes) {\n        break\n      }\n\n      initialCmd += char\n      if (char === '\"' || char === \"'\") {\n        insideQuotes = !insideQuotes\n      }\n    }\n\n    let pathToInitial\n    try {\n      pathToInitial = which.sync(initialCmd, {\n        path: (options.env && options.env.PATH) || process.env.PATH,\n        pathext: (options.env && options.env.PATHEXT) || process.env.PATHEXT,\n      }).toLowerCase()\n    } catch (err) {\n      pathToInitial = initialCmd.toLowerCase()\n    }\n\n    doubleEscape = pathToInitial.endsWith('.cmd') || pathToInitial.endsWith('.bat')\n    for (const arg of args) {\n      script += ` ${escape.cmd(arg, doubleEscape)}`\n    }\n    realArgs.push('/d', '/s', '/c', script)\n    options.windowsVerbatimArguments = true\n  } else {\n    for (const arg of args) {\n      script += ` ${escape.sh(arg)}`\n    }\n    realArgs.push('-c', script)\n  }\n\n  return promiseSpawn(command, realArgs, options, extra)\n}\n\n// open a file with the default application as defined by the user's OS\nconst open = (_args, opts = {}, extra = {}) => {\n  const options = { ...opts, shell: true }\n  const args = [].concat(_args)\n\n  let platform = process.platform\n  // process.platform === 'linux' may actually indicate WSL, if that's the case\n  // we want to treat things as win32 anyway so the host can open the argument\n  if (platform === 'linux' && os.release().toLowerCase().includes('microsoft')) {\n    platform = 'win32'\n  }\n\n  let command = options.command\n  if (!command) {\n    if (platform === 'win32') {\n      // spawnWithShell does not do the additional os.release() check, so we\n      // have to force the shell here to make sure we treat WSL as windows.\n      options.shell = process.env.ComSpec\n      // also, the start command accepts a title so to make sure that we don't\n      // accidentally interpret the first arg as the title, we stick an empty\n      // string immediately after the start command\n      command = 'start \"\"'\n    } else if (platform === 'darwin') {\n      command = 'open'\n    } else {\n      command = 'xdg-open'\n    }\n  }\n\n  return spawnWithShell(command, args, options, extra)\n}\npromiseSpawn.open = open\n\nconst isPipe = (stdio = 'pipe', fd) => {\n  if (stdio === 'pipe' || stdio === null) {\n    return true\n  }\n\n  if (Array.isArray(stdio)) {\n    return isPipe(stdio[fd], fd)\n  }\n\n  return false\n}\n\nconst stdioResult = (stdout, stderr, { stdioString = true, stdio }) => {\n  const result = {\n    stdout: null,\n    stderr: null,\n  }\n\n  // stdio is [stdin, stdout, stderr]\n  if (isPipe(stdio, 1)) {\n    result.stdout = Buffer.concat(stdout)\n    if (stdioString) {\n      result.stdout = result.stdout.toString().trim()\n    }\n  }\n\n  if (isPipe(stdio, 2)) {\n    result.stderr = Buffer.concat(stderr)\n    if (stdioString) {\n      result.stderr = result.stderr.toString().trim()\n    }\n  }\n\n  return result\n}\n\nmodule.exports = promiseSpawn\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}