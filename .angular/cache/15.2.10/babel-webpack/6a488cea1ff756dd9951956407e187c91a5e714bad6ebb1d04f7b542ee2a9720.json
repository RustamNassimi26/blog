{"ast":null,"code":"'use strict';\n\nconst INDENT = Symbol.for('indent');\nconst NEWLINE = Symbol.for('newline');\nconst DEFAULT_NEWLINE = '\\n';\nconst DEFAULT_INDENT = '  ';\nconst BOM = /^\\uFEFF/;\n\n// only respect indentation if we got a line break, otherwise squash it\n// things other than objects and arrays aren't indented, so ignore those\n// Important: in both of these regexps, the $1 capture group is the newline\n// or undefined, and the $2 capture group is the indent, or undefined.\nconst FORMAT = /^\\s*[{[]((?:\\r?\\n)+)([\\s\\t]*)/;\nconst EMPTY = /^(?:\\{\\}|\\[\\])((?:\\r?\\n)+)?$/;\n\n// Node 20 puts single quotes around the token and a comma after it\nconst UNEXPECTED_TOKEN = /^Unexpected token '?(.)'?(,)? /i;\nconst hexify = char => {\n  const h = char.charCodeAt(0).toString(16).toUpperCase();\n  return `0x${h.length % 2 ? '0' : ''}${h}`;\n};\n\n// Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n// because the buffer-to-string conversion in `fs.readFileSync()`\n// translates it to FEFF, the UTF-16 BOM.\nconst stripBOM = txt => String(txt).replace(BOM, '');\nconst makeParsedError = (msg, parsing, position = 0) => ({\n  message: `${msg} while parsing ${parsing}`,\n  position\n});\nconst parseError = (e, txt, context = 20) => {\n  let msg = e.message;\n  if (!txt) {\n    return makeParsedError(msg, 'empty string');\n  }\n  const badTokenMatch = msg.match(UNEXPECTED_TOKEN);\n  const badIndexMatch = msg.match(/ position\\s+(\\d+)/i);\n  if (badTokenMatch) {\n    msg = msg.replace(UNEXPECTED_TOKEN, `Unexpected token ${JSON.stringify(badTokenMatch[1])} (${hexify(badTokenMatch[1])})$2 `);\n  }\n  let errIdx;\n  if (badIndexMatch) {\n    errIdx = +badIndexMatch[1];\n  } else if (msg.match(/^Unexpected end of JSON.*/i)) {\n    errIdx = txt.length - 1;\n  }\n  if (errIdx == null) {\n    return makeParsedError(msg, `'${txt.slice(0, context * 2)}'`);\n  }\n  const start = errIdx <= context ? 0 : errIdx - context;\n  const end = errIdx + context >= txt.length ? txt.length : errIdx + context;\n  const slice = `${start ? '...' : ''}${txt.slice(start, end)}${end === txt.length ? '' : '...'}`;\n  return makeParsedError(msg, `${txt === slice ? '' : 'near '}${JSON.stringify(slice)}`, errIdx);\n};\nclass JSONParseError extends SyntaxError {\n  constructor(er, txt, context, caller) {\n    const metadata = parseError(er, txt, context);\n    super(metadata.message);\n    Object.assign(this, metadata);\n    this.code = 'EJSONPARSE';\n    this.systemError = er;\n    Error.captureStackTrace(this, caller || this.constructor);\n  }\n  get name() {\n    return this.constructor.name;\n  }\n  set name(n) {}\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n}\nconst parseJson = (txt, reviver) => {\n  const result = JSON.parse(txt, reviver);\n  if (result && typeof result === 'object') {\n    // get the indentation so that we can save it back nicely\n    // if the file starts with {\" then we have an indent of '', ie, none\n    // otherwise, pick the indentation of the next line after the first \\n If the\n    // pattern doesn't match, then it means no indentation. JSON.stringify ignores\n    // symbols, so this is reasonably safe. if the string is '{}' or '[]', then\n    // use the default 2-space indent.\n    const match = txt.match(EMPTY) || txt.match(FORMAT) || [null, '', ''];\n    result[NEWLINE] = match[1] ?? DEFAULT_NEWLINE;\n    result[INDENT] = match[2] ?? DEFAULT_INDENT;\n  }\n  return result;\n};\nconst parseJsonError = (raw, reviver, context) => {\n  const txt = stripBOM(raw);\n  try {\n    return parseJson(txt, reviver);\n  } catch (e) {\n    if (typeof raw !== 'string' && !Buffer.isBuffer(raw)) {\n      const msg = Array.isArray(raw) && raw.length === 0 ? 'an empty array' : String(raw);\n      throw Object.assign(new TypeError(`Cannot parse ${msg}`), {\n        code: 'EJSONPARSE',\n        systemError: e\n      });\n    }\n    throw new JSONParseError(e, txt, context, parseJsonError);\n  }\n};\nmodule.exports = parseJsonError;\nparseJsonError.JSONParseError = JSONParseError;\nparseJsonError.noExceptions = (raw, reviver) => {\n  try {\n    return parseJson(stripBOM(raw), reviver);\n  } catch {\n    // no exceptions\n  }\n};","map":{"version":3,"names":["INDENT","Symbol","for","NEWLINE","DEFAULT_NEWLINE","DEFAULT_INDENT","BOM","FORMAT","EMPTY","UNEXPECTED_TOKEN","hexify","char","h","charCodeAt","toString","toUpperCase","length","stripBOM","txt","String","replace","makeParsedError","msg","parsing","position","message","parseError","e","context","badTokenMatch","match","badIndexMatch","JSON","stringify","errIdx","slice","start","end","JSONParseError","SyntaxError","constructor","er","caller","metadata","Object","assign","code","systemError","Error","captureStackTrace","name","n","toStringTag","parseJson","reviver","result","parse","parseJsonError","raw","Buffer","isBuffer","Array","isArray","TypeError","module","exports","noExceptions"],"sources":["I:/Angular/angular-blog/node_modules/read-package-json-fast/node_modules/json-parse-even-better-errors/lib/index.js"],"sourcesContent":["'use strict'\n\nconst INDENT = Symbol.for('indent')\nconst NEWLINE = Symbol.for('newline')\n\nconst DEFAULT_NEWLINE = '\\n'\nconst DEFAULT_INDENT = '  '\nconst BOM = /^\\uFEFF/\n\n// only respect indentation if we got a line break, otherwise squash it\n// things other than objects and arrays aren't indented, so ignore those\n// Important: in both of these regexps, the $1 capture group is the newline\n// or undefined, and the $2 capture group is the indent, or undefined.\nconst FORMAT = /^\\s*[{[]((?:\\r?\\n)+)([\\s\\t]*)/\nconst EMPTY = /^(?:\\{\\}|\\[\\])((?:\\r?\\n)+)?$/\n\n// Node 20 puts single quotes around the token and a comma after it\nconst UNEXPECTED_TOKEN = /^Unexpected token '?(.)'?(,)? /i\n\nconst hexify = (char) => {\n  const h = char.charCodeAt(0).toString(16).toUpperCase()\n  return `0x${h.length % 2 ? '0' : ''}${h}`\n}\n\n// Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n// because the buffer-to-string conversion in `fs.readFileSync()`\n// translates it to FEFF, the UTF-16 BOM.\nconst stripBOM = (txt) => String(txt).replace(BOM, '')\n\nconst makeParsedError = (msg, parsing, position = 0) => ({\n  message: `${msg} while parsing ${parsing}`,\n  position,\n})\n\nconst parseError = (e, txt, context = 20) => {\n  let msg = e.message\n\n  if (!txt) {\n    return makeParsedError(msg, 'empty string')\n  }\n\n  const badTokenMatch = msg.match(UNEXPECTED_TOKEN)\n  const badIndexMatch = msg.match(/ position\\s+(\\d+)/i)\n\n  if (badTokenMatch) {\n    msg = msg.replace(\n      UNEXPECTED_TOKEN,\n      `Unexpected token ${JSON.stringify(badTokenMatch[1])} (${hexify(badTokenMatch[1])})$2 `\n    )\n  }\n\n  let errIdx\n  if (badIndexMatch) {\n    errIdx = +badIndexMatch[1]\n  } else if (msg.match(/^Unexpected end of JSON.*/i)) {\n    errIdx = txt.length - 1\n  }\n\n  if (errIdx == null) {\n    return makeParsedError(msg, `'${txt.slice(0, context * 2)}'`)\n  }\n\n  const start = errIdx <= context ? 0 : errIdx - context\n  const end = errIdx + context >= txt.length ? txt.length : errIdx + context\n  const slice = `${start ? '...' : ''}${txt.slice(start, end)}${end === txt.length ? '' : '...'}`\n\n  return makeParsedError(\n    msg,\n    `${txt === slice ? '' : 'near '}${JSON.stringify(slice)}`,\n    errIdx\n  )\n}\n\nclass JSONParseError extends SyntaxError {\n  constructor (er, txt, context, caller) {\n    const metadata = parseError(er, txt, context)\n    super(metadata.message)\n    Object.assign(this, metadata)\n    this.code = 'EJSONPARSE'\n    this.systemError = er\n    Error.captureStackTrace(this, caller || this.constructor)\n  }\n\n  get name () {\n    return this.constructor.name\n  }\n\n  set name (n) {}\n\n  get [Symbol.toStringTag] () {\n    return this.constructor.name\n  }\n}\n\nconst parseJson = (txt, reviver) => {\n  const result = JSON.parse(txt, reviver)\n  if (result && typeof result === 'object') {\n    // get the indentation so that we can save it back nicely\n    // if the file starts with {\" then we have an indent of '', ie, none\n    // otherwise, pick the indentation of the next line after the first \\n If the\n    // pattern doesn't match, then it means no indentation. JSON.stringify ignores\n    // symbols, so this is reasonably safe. if the string is '{}' or '[]', then\n    // use the default 2-space indent.\n    const match = txt.match(EMPTY) || txt.match(FORMAT) || [null, '', '']\n    result[NEWLINE] = match[1] ?? DEFAULT_NEWLINE\n    result[INDENT] = match[2] ?? DEFAULT_INDENT\n  }\n  return result\n}\n\nconst parseJsonError = (raw, reviver, context) => {\n  const txt = stripBOM(raw)\n  try {\n    return parseJson(txt, reviver)\n  } catch (e) {\n    if (typeof raw !== 'string' && !Buffer.isBuffer(raw)) {\n      const msg = Array.isArray(raw) && raw.length === 0 ? 'an empty array' : String(raw)\n      throw Object.assign(\n        new TypeError(`Cannot parse ${msg}`),\n        { code: 'EJSONPARSE', systemError: e }\n      )\n    }\n    throw new JSONParseError(e, txt, context, parseJsonError)\n  }\n}\n\nmodule.exports = parseJsonError\nparseJsonError.JSONParseError = JSONParseError\nparseJsonError.noExceptions = (raw, reviver) => {\n  try {\n    return parseJson(stripBOM(raw), reviver)\n  } catch {\n    // no exceptions\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}