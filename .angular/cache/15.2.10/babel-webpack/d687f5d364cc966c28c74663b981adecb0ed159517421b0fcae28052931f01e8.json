{"ast":null,"code":"\"use strict\";\n\n/**\n * @module LRUCache\n */\nvar _asyncToGenerator = require(\"I:/Angular/angular-blog/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LRUCache = void 0;\nconst perf = typeof performance === 'object' && performance && typeof performance.now === 'function' ? performance : Date;\nconst warned = new Set();\n/* c8 ignore start */\nconst PROCESS = typeof process === 'object' && !!process ? process : {};\n/* c8 ignore start */\nconst emitWarning = (msg, type, code, fn) => {\n  typeof PROCESS.emitWarning === 'function' ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);\n};\nlet AC = globalThis.AbortController;\nlet AS = globalThis.AbortSignal;\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n  //@ts-ignore\n  AS = class AbortSignal {\n    onabort;\n    _onabort = [];\n    reason;\n    aborted = false;\n    addEventListener(_, fn) {\n      this._onabort.push(fn);\n    }\n  };\n  //@ts-ignore\n  AC = class AbortController {\n    constructor() {\n      warnACPolyfill();\n    }\n    signal = new AS();\n    abort(reason) {\n      if (this.signal.aborted) return;\n      //@ts-ignore\n      this.signal.reason = reason;\n      //@ts-ignore\n      this.signal.aborted = true;\n      //@ts-ignore\n      for (const fn of this.signal._onabort) {\n        fn(reason);\n      }\n      this.signal.onabort?.(reason);\n    }\n  };\n  let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';\n  const warnACPolyfill = () => {\n    if (!printACPolyfillWarning) return;\n    printACPolyfillWarning = false;\n    emitWarning('AbortController is not defined. If using lru-cache in ' + 'node 14, load an AbortController polyfill from the ' + '`node-abort-controller` package. A minimal polyfill is ' + 'provided for use by LRUCache.fetch(), but it should not be ' + 'relied upon in other contexts (eg, passing it to other APIs that ' + 'use AbortController/AbortSignal might have undesirable effects). ' + 'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);\n  };\n}\n/* c8 ignore stop */\nconst shouldWarn = code => !warned.has(code);\nconst TYPE = Symbol('type');\nconst isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = max => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;\n/* c8 ignore stop */\nclass ZeroArray extends Array {\n  constructor(size) {\n    super(size);\n    this.fill(0);\n  }\n}\nclass Stack {\n  heap;\n  length;\n  // private constructor\n  static #constructing = false;\n  static create(max) {\n    const HeapCls = getUintArray(max);\n    if (!HeapCls) return [];\n    Stack.#constructing = true;\n    const s = new Stack(max, HeapCls);\n    Stack.#constructing = false;\n    return s;\n  }\n  constructor(max, HeapCls) {\n    /* c8 ignore start */\n    if (!Stack.#constructing) {\n      throw new TypeError('instantiate Stack using Stack.create(n)');\n    }\n    /* c8 ignore stop */\n    this.heap = new HeapCls(max);\n    this.length = 0;\n  }\n  push(n) {\n    this.heap[this.length++] = n;\n  }\n  pop() {\n    return this.heap[--this.length];\n  }\n}\n/**\n * Default export, the thing you're using this module to get.\n *\n * All properties from the options object (with the exception of\n * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as\n * normal public members. (`max` and `maxBase` are read-only getters.)\n * Changing any of these will alter the defaults for subsequent method calls,\n * but is otherwise safe.\n */\nclass LRUCache {\n  // properties coming in from the options of these, only max and maxSize\n  // really *need* to be protected. The rest can be modified, as they just\n  // set defaults for various methods.\n  #max;\n  #maxSize;\n  #dispose;\n  #disposeAfter;\n  #fetchMethod;\n  /**\n   * {@link LRUCache.OptionsBase.ttl}\n   */\n  ttl;\n  /**\n   * {@link LRUCache.OptionsBase.ttlResolution}\n   */\n  ttlResolution;\n  /**\n   * {@link LRUCache.OptionsBase.ttlAutopurge}\n   */\n  ttlAutopurge;\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnGet}\n   */\n  updateAgeOnGet;\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnHas}\n   */\n  updateAgeOnHas;\n  /**\n   * {@link LRUCache.OptionsBase.allowStale}\n   */\n  allowStale;\n  /**\n   * {@link LRUCache.OptionsBase.noDisposeOnSet}\n   */\n  noDisposeOnSet;\n  /**\n   * {@link LRUCache.OptionsBase.noUpdateTTL}\n   */\n  noUpdateTTL;\n  /**\n   * {@link LRUCache.OptionsBase.maxEntrySize}\n   */\n  maxEntrySize;\n  /**\n   * {@link LRUCache.OptionsBase.sizeCalculation}\n   */\n  sizeCalculation;\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n   */\n  noDeleteOnFetchRejection;\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n   */\n  noDeleteOnStaleGet;\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n   */\n  allowStaleOnFetchAbort;\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n   */\n  allowStaleOnFetchRejection;\n  /**\n   * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n   */\n  ignoreFetchAbort;\n  // computed properties\n  #size;\n  #calculatedSize;\n  #keyMap;\n  #keyList;\n  #valList;\n  #next;\n  #prev;\n  #head;\n  #tail;\n  #free;\n  #disposed;\n  #sizes;\n  #starts;\n  #ttls;\n  #hasDispose;\n  #hasFetchMethod;\n  #hasDisposeAfter;\n  /**\n   * Do not call this method unless you need to inspect the\n   * inner workings of the cache.  If anything returned by this\n   * object is modified in any way, strange breakage may occur.\n   *\n   * These fields are private for a reason!\n   *\n   * @internal\n   */\n  static unsafeExposeInternals(c) {\n    return {\n      // properties\n      starts: c.#starts,\n      ttls: c.#ttls,\n      sizes: c.#sizes,\n      keyMap: c.#keyMap,\n      keyList: c.#keyList,\n      valList: c.#valList,\n      next: c.#next,\n      prev: c.#prev,\n      get head() {\n        return c.#head;\n      },\n      get tail() {\n        return c.#tail;\n      },\n      free: c.#free,\n      // methods\n      isBackgroundFetch: p => c.#isBackgroundFetch(p),\n      backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),\n      moveToTail: index => c.#moveToTail(index),\n      indexes: options => c.#indexes(options),\n      rindexes: options => c.#rindexes(options),\n      isStale: index => c.#isStale(index)\n    };\n  }\n  // Protected read-only members\n  /**\n   * {@link LRUCache.OptionsBase.max} (read-only)\n   */\n  get max() {\n    return this.#max;\n  }\n  /**\n   * {@link LRUCache.OptionsBase.maxSize} (read-only)\n   */\n  get maxSize() {\n    return this.#maxSize;\n  }\n  /**\n   * The total computed size of items in the cache (read-only)\n   */\n  get calculatedSize() {\n    return this.#calculatedSize;\n  }\n  /**\n   * The number of items stored in the cache (read-only)\n   */\n  get size() {\n    return this.#size;\n  }\n  /**\n   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n   */\n  get fetchMethod() {\n    return this.#fetchMethod;\n  }\n  /**\n   * {@link LRUCache.OptionsBase.dispose} (read-only)\n   */\n  get dispose() {\n    return this.#dispose;\n  }\n  /**\n   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n   */\n  get disposeAfter() {\n    return this.#disposeAfter;\n  }\n  constructor(options) {\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort\n    } = options;\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer');\n    }\n    const UintArray = max ? getUintArray(max) : Array;\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max);\n    }\n    this.#max = max;\n    this.#maxSize = maxSize;\n    this.maxEntrySize = maxEntrySize || this.#maxSize;\n    this.sizeCalculation = sizeCalculation;\n    if (this.sizeCalculation) {\n      if (!this.#maxSize && !this.maxEntrySize) {\n        throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function');\n      }\n    }\n    if (fetchMethod !== undefined && typeof fetchMethod !== 'function') {\n      throw new TypeError('fetchMethod must be a function if specified');\n    }\n    this.#fetchMethod = fetchMethod;\n    this.#hasFetchMethod = !!fetchMethod;\n    this.#keyMap = new Map();\n    this.#keyList = new Array(max).fill(undefined);\n    this.#valList = new Array(max).fill(undefined);\n    this.#next = new UintArray(max);\n    this.#prev = new UintArray(max);\n    this.#head = 0;\n    this.#tail = 0;\n    this.#free = Stack.create(max);\n    this.#size = 0;\n    this.#calculatedSize = 0;\n    if (typeof dispose === 'function') {\n      this.#dispose = dispose;\n    }\n    if (typeof disposeAfter === 'function') {\n      this.#disposeAfter = disposeAfter;\n      this.#disposed = [];\n    } else {\n      this.#disposeAfter = undefined;\n      this.#disposed = undefined;\n    }\n    this.#hasDispose = !!this.#dispose;\n    this.#hasDisposeAfter = !!this.#disposeAfter;\n    this.noDisposeOnSet = !!noDisposeOnSet;\n    this.noUpdateTTL = !!noUpdateTTL;\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n    this.ignoreFetchAbort = !!ignoreFetchAbort;\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (this.#maxSize !== 0) {\n        if (!isPosInt(this.#maxSize)) {\n          throw new TypeError('maxSize must be a positive integer if specified');\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError('maxEntrySize must be a positive integer if specified');\n      }\n      this.#initializeSizeTracking();\n    }\n    this.allowStale = !!allowStale;\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n    this.updateAgeOnGet = !!updateAgeOnGet;\n    this.updateAgeOnHas = !!updateAgeOnHas;\n    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;\n    this.ttlAutopurge = !!ttlAutopurge;\n    this.ttl = ttl || 0;\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError('ttl must be a positive integer if specified');\n      }\n      this.#initializeTTLTracking();\n    }\n    // do not allow completely unbounded caches\n    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n      throw new TypeError('At least one of max, maxSize, or ttl is required');\n    }\n    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED';\n      if (shouldWarn(code)) {\n        warned.add(code);\n        const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' + 'result in unbounded memory consumption.';\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);\n      }\n    }\n  }\n  /**\n   * Return the remaining TTL time for a given entry key\n   */\n  getRemainingTTL(key) {\n    return this.#keyMap.has(key) ? Infinity : 0;\n  }\n  #initializeTTLTracking() {\n    const ttls = new ZeroArray(this.#max);\n    const starts = new ZeroArray(this.#max);\n    this.#ttls = ttls;\n    this.#starts = starts;\n    this.#setItemTTL = (index, ttl, start = perf.now()) => {\n      starts[index] = ttl !== 0 ? start : 0;\n      ttls[index] = ttl;\n      if (ttl !== 0 && this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          if (this.#isStale(index)) {\n            this.delete(this.#keyList[index]);\n          }\n        }, ttl + 1);\n        // unref() not supported on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref();\n        }\n        /* c8 ignore stop */\n      }\n    };\n\n    this.#updateItemAge = index => {\n      starts[index] = ttls[index] !== 0 ? perf.now() : 0;\n    };\n    this.#statusTTL = (status, index) => {\n      if (ttls[index]) {\n        const ttl = ttls[index];\n        const start = starts[index];\n        /* c8 ignore next */\n        if (!ttl || !start) return;\n        status.ttl = ttl;\n        status.start = start;\n        status.now = cachedNow || getNow();\n        const age = status.now - start;\n        status.remainingTTL = ttl - age;\n      }\n    };\n    // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n    let cachedNow = 0;\n    const getNow = () => {\n      const n = perf.now();\n      if (this.ttlResolution > 0) {\n        cachedNow = n;\n        const t = setTimeout(() => cachedNow = 0, this.ttlResolution);\n        // not available on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref();\n        }\n        /* c8 ignore stop */\n      }\n\n      return n;\n    };\n    this.getRemainingTTL = key => {\n      const index = this.#keyMap.get(key);\n      if (index === undefined) {\n        return 0;\n      }\n      const ttl = ttls[index];\n      const start = starts[index];\n      if (!ttl || !start) {\n        return Infinity;\n      }\n      const age = (cachedNow || getNow()) - start;\n      return ttl - age;\n    };\n    this.#isStale = index => {\n      const s = starts[index];\n      const t = ttls[index];\n      return !!t && !!s && (cachedNow || getNow()) - s > t;\n    };\n  }\n  // conditionally set private methods related to TTL\n  #updateItemAge = () => {};\n  #statusTTL = () => {};\n  #setItemTTL = () => {};\n  /* c8 ignore stop */\n  #isStale = () => false;\n  #initializeSizeTracking() {\n    const sizes = new ZeroArray(this.#max);\n    this.#calculatedSize = 0;\n    this.#sizes = sizes;\n    this.#removeItemSize = index => {\n      this.#calculatedSize -= sizes[index];\n      sizes[index] = 0;\n    };\n    this.#requireSize = (k, v, size, sizeCalculation) => {\n      // provisionally accept background fetches.\n      // actual value size will be checked when they return.\n      if (this.#isBackgroundFetch(v)) {\n        return 0;\n      }\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function');\n          }\n          size = sizeCalculation(v, k);\n          if (!isPosInt(size)) {\n            throw new TypeError('sizeCalculation return invalid (expect positive integer)');\n          }\n        } else {\n          throw new TypeError('invalid size value (must be positive integer). ' + 'When maxSize or maxEntrySize is used, sizeCalculation ' + 'or size must be set.');\n        }\n      }\n      return size;\n    };\n    this.#addItemSize = (index, size, status) => {\n      sizes[index] = size;\n      if (this.#maxSize) {\n        const maxSize = this.#maxSize - sizes[index];\n        while (this.#calculatedSize > maxSize) {\n          this.#evict(true);\n        }\n      }\n      this.#calculatedSize += sizes[index];\n      if (status) {\n        status.entrySize = size;\n        status.totalCalculatedSize = this.#calculatedSize;\n      }\n    };\n  }\n  #removeItemSize = _i => {};\n  #addItemSize = (_i, _s, _st) => {};\n  #requireSize = (_k, _v, size, sizeCalculation) => {\n    if (size || sizeCalculation) {\n      throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');\n    }\n    return 0;\n  };\n  *#indexes({\n    allowStale = this.allowStale\n  } = {}) {\n    if (this.#size) {\n      for (let i = this.#tail; true;) {\n        if (!this.#isValidIndex(i)) {\n          break;\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i;\n        }\n        if (i === this.#head) {\n          break;\n        } else {\n          i = this.#prev[i];\n        }\n      }\n    }\n  }\n  *#rindexes({\n    allowStale = this.allowStale\n  } = {}) {\n    if (this.#size) {\n      for (let i = this.#head; true;) {\n        if (!this.#isValidIndex(i)) {\n          break;\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i;\n        }\n        if (i === this.#tail) {\n          break;\n        } else {\n          i = this.#next[i];\n        }\n      }\n    }\n  }\n  #isValidIndex(index) {\n    return index !== undefined && this.#keyMap.get(this.#keyList[index]) === index;\n  }\n  /**\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from most recently used to least recently used.\n   */\n  *entries() {\n    for (const i of this.#indexes()) {\n      if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n        yield [this.#keyList[i], this.#valList[i]];\n      }\n    }\n  }\n  /**\n   * Inverse order version of {@link LRUCache.entries}\n   *\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from least recently used to most recently used.\n   */\n  *rentries() {\n    for (const i of this.#rindexes()) {\n      if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n        yield [this.#keyList[i], this.#valList[i]];\n      }\n    }\n  }\n  /**\n   * Return a generator yielding the keys in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *keys() {\n    for (const i of this.#indexes()) {\n      const k = this.#keyList[i];\n      if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n        yield k;\n      }\n    }\n  }\n  /**\n   * Inverse order version of {@link LRUCache.keys}\n   *\n   * Return a generator yielding the keys in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rkeys() {\n    for (const i of this.#rindexes()) {\n      const k = this.#keyList[i];\n      if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n        yield k;\n      }\n    }\n  }\n  /**\n   * Return a generator yielding the values in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *values() {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i];\n      if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n        yield this.#valList[i];\n      }\n    }\n  }\n  /**\n   * Inverse order version of {@link LRUCache.values}\n   *\n   * Return a generator yielding the values in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rvalues() {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i];\n      if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n        yield this.#valList[i];\n      }\n    }\n  }\n  /**\n   * Iterating over the cache itself yields the same results as\n   * {@link LRUCache.entries}\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Find a value for which the supplied fn method returns a truthy value,\n   * similar to Array.find().  fn is called as fn(value, key, cache).\n   */\n  find(fn, getOptions = {}) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i];\n      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n      if (value === undefined) continue;\n      if (fn(value, this.#keyList[i], this)) {\n        return this.get(this.#keyList[i], getOptions);\n      }\n    }\n  }\n  /**\n   * Call the supplied function on each item in the cache, in order from\n   * most recently used to least recently used.  fn is called as\n   * fn(value, key, cache).  Does not update age or recenty of use.\n   * Does not iterate over stale values.\n   */\n  forEach(fn, thisp = this) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i];\n      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n      if (value === undefined) continue;\n      fn.call(thisp, value, this.#keyList[i], this);\n    }\n  }\n  /**\n   * The same as {@link LRUCache.forEach} but items are iterated over in\n   * reverse order.  (ie, less recently used items are iterated over first.)\n   */\n  rforEach(fn, thisp = this) {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i];\n      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n      if (value === undefined) continue;\n      fn.call(thisp, value, this.#keyList[i], this);\n    }\n  }\n  /**\n   * Delete any stale entries. Returns true if anything was removed,\n   * false otherwise.\n   */\n  purgeStale() {\n    let deleted = false;\n    for (const i of this.#rindexes({\n      allowStale: true\n    })) {\n      if (this.#isStale(i)) {\n        this.delete(this.#keyList[i]);\n        deleted = true;\n      }\n    }\n    return deleted;\n  }\n  /**\n   * Get the extended info about a given entry, to get its value, size, and\n   * TTL info simultaneously. Like {@link LRUCache#dump}, but just for a\n   * single key. Always returns stale values, if their info is found in the\n   * cache, so be sure to check for expired TTLs if relevant.\n   */\n  info(key) {\n    const i = this.#keyMap.get(key);\n    if (i === undefined) return undefined;\n    const v = this.#valList[i];\n    const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n    if (value === undefined) return undefined;\n    const entry = {\n      value\n    };\n    if (this.#ttls && this.#starts) {\n      const ttl = this.#ttls[i];\n      const start = this.#starts[i];\n      if (ttl && start) {\n        const remain = ttl - (perf.now() - start);\n        entry.ttl = remain;\n        entry.start = Date.now();\n      }\n    }\n    if (this.#sizes) {\n      entry.size = this.#sizes[i];\n    }\n    return entry;\n  }\n  /**\n   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n   * passed to cache.load()\n   */\n  dump() {\n    const arr = [];\n    for (const i of this.#indexes({\n      allowStale: true\n    })) {\n      const key = this.#keyList[i];\n      const v = this.#valList[i];\n      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n      if (value === undefined || key === undefined) continue;\n      const entry = {\n        value\n      };\n      if (this.#ttls && this.#starts) {\n        entry.ttl = this.#ttls[i];\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - this.#starts[i];\n        entry.start = Math.floor(Date.now() - age);\n      }\n      if (this.#sizes) {\n        entry.size = this.#sizes[i];\n      }\n      arr.unshift([key, entry]);\n    }\n    return arr;\n  }\n  /**\n   * Reset the cache and load in the items in entries in the order listed.\n   * Note that the shape of the resulting cache may be different if the\n   * same options are not used in both caches.\n   */\n  load(arr) {\n    this.clear();\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset, so that\n        // we get the intended remaining TTL, no matter how long it's\n        // been on ice.\n        //\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start;\n        entry.start = perf.now() - age;\n      }\n      this.set(key, entry.value, entry);\n    }\n  }\n  /**\n   * Add a value to the cache.\n   *\n   * Note: if `undefined` is specified as a value, this is an alias for\n   * {@link LRUCache#delete}\n   */\n  set(k, v, setOptions = {}) {\n    if (v === undefined) {\n      this.delete(k);\n      return this;\n    }\n    const {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      sizeCalculation = this.sizeCalculation,\n      status\n    } = setOptions;\n    let {\n      noUpdateTTL = this.noUpdateTTL\n    } = setOptions;\n    const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss';\n        status.maxEntrySizeExceeded = true;\n      }\n      // have to delete, in case something is there already.\n      this.delete(k);\n      return this;\n    }\n    let index = this.#size === 0 ? undefined : this.#keyMap.get(k);\n    if (index === undefined) {\n      // addition\n      index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;\n      this.#keyList[index] = k;\n      this.#valList[index] = v;\n      this.#keyMap.set(k, index);\n      this.#next[this.#tail] = index;\n      this.#prev[index] = this.#tail;\n      this.#tail = index;\n      this.#size++;\n      this.#addItemSize(index, size, status);\n      if (status) status.set = 'add';\n      noUpdateTTL = false;\n    } else {\n      // update\n      this.#moveToTail(index);\n      const oldVal = this.#valList[index];\n      if (v !== oldVal) {\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'));\n          const {\n            __staleWhileFetching: s\n          } = oldVal;\n          if (s !== undefined && !noDisposeOnSet) {\n            if (this.#hasDispose) {\n              this.#dispose?.(s, k, 'set');\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([s, k, 'set']);\n            }\n          }\n        } else if (!noDisposeOnSet) {\n          if (this.#hasDispose) {\n            this.#dispose?.(oldVal, k, 'set');\n          }\n          if (this.#hasDisposeAfter) {\n            this.#disposed?.push([oldVal, k, 'set']);\n          }\n        }\n        this.#removeItemSize(index);\n        this.#addItemSize(index, size, status);\n        this.#valList[index] = v;\n        if (status) {\n          status.set = 'replace';\n          const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;\n          if (oldValue !== undefined) status.oldValue = oldValue;\n        }\n      } else if (status) {\n        status.set = 'update';\n      }\n    }\n    if (ttl !== 0 && !this.#ttls) {\n      this.#initializeTTLTracking();\n    }\n    if (this.#ttls) {\n      if (!noUpdateTTL) {\n        this.#setItemTTL(index, ttl, start);\n      }\n      if (status) this.#statusTTL(status, index);\n    }\n    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed;\n      let task;\n      while (task = dt?.shift()) {\n        this.#disposeAfter?.(...task);\n      }\n    }\n    return this;\n  }\n  /**\n   * Evict the least recently used item, returning its value or\n   * `undefined` if cache is empty.\n   */\n  pop() {\n    try {\n      while (this.#size) {\n        const val = this.#valList[this.#head];\n        this.#evict(true);\n        if (this.#isBackgroundFetch(val)) {\n          if (val.__staleWhileFetching) {\n            return val.__staleWhileFetching;\n          }\n        } else if (val !== undefined) {\n          return val;\n        }\n      }\n    } finally {\n      if (this.#hasDisposeAfter && this.#disposed) {\n        const dt = this.#disposed;\n        let task;\n        while (task = dt?.shift()) {\n          this.#disposeAfter?.(...task);\n        }\n      }\n    }\n  }\n  #evict(free) {\n    const head = this.#head;\n    const k = this.#keyList[head];\n    const v = this.#valList[head];\n    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n      v.__abortController.abort(new Error('evicted'));\n    } else if (this.#hasDispose || this.#hasDisposeAfter) {\n      if (this.#hasDispose) {\n        this.#dispose?.(v, k, 'evict');\n      }\n      if (this.#hasDisposeAfter) {\n        this.#disposed?.push([v, k, 'evict']);\n      }\n    }\n    this.#removeItemSize(head);\n    // if we aren't about to use the index, then null these out\n    if (free) {\n      this.#keyList[head] = undefined;\n      this.#valList[head] = undefined;\n      this.#free.push(head);\n    }\n    if (this.#size === 1) {\n      this.#head = this.#tail = 0;\n      this.#free.length = 0;\n    } else {\n      this.#head = this.#next[head];\n    }\n    this.#keyMap.delete(k);\n    this.#size--;\n    return head;\n  }\n  /**\n   * Check if a key is in the cache, without updating the recency of use.\n   * Will return false if the item is stale, even though it is technically\n   * in the cache.\n   *\n   * Will not update item age unless\n   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n   */\n  has(k, hasOptions = {}) {\n    const {\n      updateAgeOnHas = this.updateAgeOnHas,\n      status\n    } = hasOptions;\n    const index = this.#keyMap.get(k);\n    if (index !== undefined) {\n      const v = this.#valList[index];\n      if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === undefined) {\n        return false;\n      }\n      if (!this.#isStale(index)) {\n        if (updateAgeOnHas) {\n          this.#updateItemAge(index);\n        }\n        if (status) {\n          status.has = 'hit';\n          this.#statusTTL(status, index);\n        }\n        return true;\n      } else if (status) {\n        status.has = 'stale';\n        this.#statusTTL(status, index);\n      }\n    } else if (status) {\n      status.has = 'miss';\n    }\n    return false;\n  }\n  /**\n   * Like {@link LRUCache#get} but doesn't update recency or delete stale\n   * items.\n   *\n   * Returns `undefined` if the item is stale, unless\n   * {@link LRUCache.OptionsBase.allowStale} is set.\n   */\n  peek(k, peekOptions = {}) {\n    const {\n      allowStale = this.allowStale\n    } = peekOptions;\n    const index = this.#keyMap.get(k);\n    if (index === undefined || !allowStale && this.#isStale(index)) {\n      return;\n    }\n    const v = this.#valList[index];\n    // either stale and allowed, or forcing a refresh of non-stale value\n    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n  }\n  #backgroundFetch(k, index, options, context) {\n    const v = index === undefined ? undefined : this.#valList[index];\n    if (this.#isBackgroundFetch(v)) {\n      return v;\n    }\n    const ac = new AC();\n    const {\n      signal\n    } = options;\n    // when/if our AC signals, then stop listening to theirs.\n    signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n      signal: ac.signal\n    });\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context\n    };\n    const cb = (v, updateCache = false) => {\n      const {\n        aborted\n      } = ac.signal;\n      const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n      if (options.status) {\n        if (aborted && !updateCache) {\n          options.status.fetchAborted = true;\n          options.status.fetchError = ac.signal.reason;\n          if (ignoreAbort) options.status.fetchAbortIgnored = true;\n        } else {\n          options.status.fetchResolved = true;\n        }\n      }\n      if (aborted && !ignoreAbort && !updateCache) {\n        return fetchFail(ac.signal.reason);\n      }\n      // either we didn't abort, and are still here, or we did, and ignored\n      const bf = p;\n      if (this.#valList[index] === p) {\n        if (v === undefined) {\n          if (bf.__staleWhileFetching) {\n            this.#valList[index] = bf.__staleWhileFetching;\n          } else {\n            this.delete(k);\n          }\n        } else {\n          if (options.status) options.status.fetchUpdated = true;\n          this.set(k, v, fetchOpts.options);\n        }\n      }\n      return v;\n    };\n    const eb = er => {\n      if (options.status) {\n        options.status.fetchRejected = true;\n        options.status.fetchError = er;\n      }\n      return fetchFail(er);\n    };\n    const fetchFail = er => {\n      const {\n        aborted\n      } = ac.signal;\n      const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n      const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n      const noDelete = allowStale || options.noDeleteOnFetchRejection;\n      const bf = p;\n      if (this.#valList[index] === p) {\n        // if we allow stale on fetch rejections, then we need to ensure that\n        // the stale value is not removed from the cache when the fetch fails.\n        const del = !noDelete || bf.__staleWhileFetching === undefined;\n        if (del) {\n          this.delete(k);\n        } else if (!allowStaleAborted) {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          // leave it untouched if we're still waiting for an\n          // aborted background fetch that hasn't yet returned.\n          this.#valList[index] = bf.__staleWhileFetching;\n        }\n      }\n      if (allowStale) {\n        if (options.status && bf.__staleWhileFetching !== undefined) {\n          options.status.returnedStale = true;\n        }\n        return bf.__staleWhileFetching;\n      } else if (bf.__returned === bf) {\n        throw er;\n      }\n    };\n    const pcall = (res, rej) => {\n      const fmp = this.#fetchMethod?.(k, v, fetchOpts);\n      if (fmp && fmp instanceof Promise) {\n        fmp.then(v => res(v === undefined ? undefined : v), rej);\n      }\n      // ignored, we go until we finish, regardless.\n      // defer check until we are actually aborting,\n      // so fetchMethod can override.\n      ac.signal.addEventListener('abort', () => {\n        if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {\n          res(undefined);\n          // when it eventually resolves, update the cache.\n          if (options.allowStaleOnFetchAbort) {\n            res = v => cb(v, true);\n          }\n        }\n      });\n    };\n    if (options.status) options.status.fetchDispatched = true;\n    const p = new Promise(pcall).then(cb, eb);\n    const bf = Object.assign(p, {\n      __abortController: ac,\n      __staleWhileFetching: v,\n      __returned: undefined\n    });\n    if (index === undefined) {\n      // internal, don't expose status.\n      this.set(k, bf, {\n        ...fetchOpts.options,\n        status: undefined\n      });\n      index = this.#keyMap.get(k);\n    } else {\n      this.#valList[index] = bf;\n    }\n    return bf;\n  }\n  #isBackgroundFetch(p) {\n    if (!this.#hasFetchMethod) return false;\n    const b = p;\n    return !!b && b instanceof Promise && b.hasOwnProperty('__staleWhileFetching') && b.__abortController instanceof AC;\n  }\n  fetch(k, fetchOptions = {}) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const {\n        // get options\n        allowStale = _this.allowStale,\n        updateAgeOnGet = _this.updateAgeOnGet,\n        noDeleteOnStaleGet = _this.noDeleteOnStaleGet,\n        // set options\n        ttl = _this.ttl,\n        noDisposeOnSet = _this.noDisposeOnSet,\n        size = 0,\n        sizeCalculation = _this.sizeCalculation,\n        noUpdateTTL = _this.noUpdateTTL,\n        // fetch exclusive options\n        noDeleteOnFetchRejection = _this.noDeleteOnFetchRejection,\n        allowStaleOnFetchRejection = _this.allowStaleOnFetchRejection,\n        ignoreFetchAbort = _this.ignoreFetchAbort,\n        allowStaleOnFetchAbort = _this.allowStaleOnFetchAbort,\n        context,\n        forceRefresh = false,\n        status,\n        signal\n      } = fetchOptions;\n      if (!_this.#hasFetchMethod) {\n        if (status) status.fetch = 'get';\n        return _this.get(k, {\n          allowStale,\n          updateAgeOnGet,\n          noDeleteOnStaleGet,\n          status\n        });\n      }\n      const options = {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        ttl,\n        noDisposeOnSet,\n        size,\n        sizeCalculation,\n        noUpdateTTL,\n        noDeleteOnFetchRejection,\n        allowStaleOnFetchRejection,\n        allowStaleOnFetchAbort,\n        ignoreFetchAbort,\n        status,\n        signal\n      };\n      let index = _this.#keyMap.get(k);\n      if (index === undefined) {\n        if (status) status.fetch = 'miss';\n        const p = _this.#backgroundFetch(k, index, options, context);\n        return p.__returned = p;\n      } else {\n        // in cache, maybe already fetching\n        const v = _this.#valList[index];\n        if (_this.#isBackgroundFetch(v)) {\n          const stale = allowStale && v.__staleWhileFetching !== undefined;\n          if (status) {\n            status.fetch = 'inflight';\n            if (stale) status.returnedStale = true;\n          }\n          return stale ? v.__staleWhileFetching : v.__returned = v;\n        }\n        // if we force a refresh, that means do NOT serve the cached value,\n        // unless we are already in the process of refreshing the cache.\n        const isStale = _this.#isStale(index);\n        if (!forceRefresh && !isStale) {\n          if (status) status.fetch = 'hit';\n          _this.#moveToTail(index);\n          if (updateAgeOnGet) {\n            _this.#updateItemAge(index);\n          }\n          if (status) _this.#statusTTL(status, index);\n          return v;\n        }\n        // ok, it is stale or a forced refresh, and not already fetching.\n        // refresh the cache.\n        const p = _this.#backgroundFetch(k, index, options, context);\n        const hasStale = p.__staleWhileFetching !== undefined;\n        const staleVal = hasStale && allowStale;\n        if (status) {\n          status.fetch = isStale ? 'stale' : 'refresh';\n          if (staleVal && isStale) status.returnedStale = true;\n        }\n        return staleVal ? p.__staleWhileFetching : p.__returned = p;\n      }\n    })();\n  }\n  /**\n   * Return a value from the cache. Will update the recency of the cache\n   * entry found.\n   *\n   * If the key is not found, get() will return `undefined`.\n   */\n  get(k, getOptions = {}) {\n    const {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status\n    } = getOptions;\n    const index = this.#keyMap.get(k);\n    if (index !== undefined) {\n      const value = this.#valList[index];\n      const fetching = this.#isBackgroundFetch(value);\n      if (status) this.#statusTTL(status, index);\n      if (this.#isStale(index)) {\n        if (status) status.get = 'stale';\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.delete(k);\n          }\n          if (status && allowStale) status.returnedStale = true;\n          return allowStale ? value : undefined;\n        } else {\n          if (status && allowStale && value.__staleWhileFetching !== undefined) {\n            status.returnedStale = true;\n          }\n          return allowStale ? value.__staleWhileFetching : undefined;\n        }\n      } else {\n        if (status) status.get = 'hit';\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching;\n        }\n        this.#moveToTail(index);\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index);\n        }\n        return value;\n      }\n    } else if (status) {\n      status.get = 'miss';\n    }\n  }\n  #connect(p, n) {\n    this.#prev[n] = p;\n    this.#next[p] = n;\n  }\n  #moveToTail(index) {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.#tail) {\n      if (index === this.#head) {\n        this.#head = this.#next[index];\n      } else {\n        this.#connect(this.#prev[index], this.#next[index]);\n      }\n      this.#connect(this.#tail, index);\n      this.#tail = index;\n    }\n  }\n  /**\n   * Deletes a key out of the cache.\n   * Returns true if the key was deleted, false otherwise.\n   */\n  delete(k) {\n    let deleted = false;\n    if (this.#size !== 0) {\n      const index = this.#keyMap.get(k);\n      if (index !== undefined) {\n        deleted = true;\n        if (this.#size === 1) {\n          this.clear();\n        } else {\n          this.#removeItemSize(index);\n          const v = this.#valList[index];\n          if (this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('deleted'));\n          } else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n              this.#dispose?.(v, k, 'delete');\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([v, k, 'delete']);\n            }\n          }\n          this.#keyMap.delete(k);\n          this.#keyList[index] = undefined;\n          this.#valList[index] = undefined;\n          if (index === this.#tail) {\n            this.#tail = this.#prev[index];\n          } else if (index === this.#head) {\n            this.#head = this.#next[index];\n          } else {\n            const pi = this.#prev[index];\n            this.#next[pi] = this.#next[index];\n            const ni = this.#next[index];\n            this.#prev[ni] = this.#prev[index];\n          }\n          this.#size--;\n          this.#free.push(index);\n        }\n      }\n    }\n    if (this.#hasDisposeAfter && this.#disposed?.length) {\n      const dt = this.#disposed;\n      let task;\n      while (task = dt?.shift()) {\n        this.#disposeAfter?.(...task);\n      }\n    }\n    return deleted;\n  }\n  /**\n   * Clear the cache entirely, throwing away all values.\n   */\n  clear() {\n    for (const index of this.#rindexes({\n      allowStale: true\n    })) {\n      const v = this.#valList[index];\n      if (this.#isBackgroundFetch(v)) {\n        v.__abortController.abort(new Error('deleted'));\n      } else {\n        const k = this.#keyList[index];\n        if (this.#hasDispose) {\n          this.#dispose?.(v, k, 'delete');\n        }\n        if (this.#hasDisposeAfter) {\n          this.#disposed?.push([v, k, 'delete']);\n        }\n      }\n    }\n    this.#keyMap.clear();\n    this.#valList.fill(undefined);\n    this.#keyList.fill(undefined);\n    if (this.#ttls && this.#starts) {\n      this.#ttls.fill(0);\n      this.#starts.fill(0);\n    }\n    if (this.#sizes) {\n      this.#sizes.fill(0);\n    }\n    this.#head = 0;\n    this.#tail = 0;\n    this.#free.length = 0;\n    this.#calculatedSize = 0;\n    this.#size = 0;\n    if (this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed;\n      let task;\n      while (task = dt?.shift()) {\n        this.#disposeAfter?.(...task);\n      }\n    }\n  }\n}\nexports.LRUCache = LRUCache;","map":{"version":3,"names":["Object","defineProperty","exports","value","LRUCache","perf","performance","now","Date","warned","Set","PROCESS","process","emitWarning","msg","type","code","fn","console","error","AC","globalThis","AbortController","AS","AbortSignal","onabort","_onabort","reason","aborted","addEventListener","_","push","constructor","warnACPolyfill","signal","abort","printACPolyfillWarning","env","LRU_CACHE_IGNORE_AC_WARNING","shouldWarn","has","TYPE","Symbol","isPosInt","n","Math","floor","isFinite","getUintArray","max","pow","Uint8Array","Uint16Array","Uint32Array","Number","MAX_SAFE_INTEGER","ZeroArray","Array","size","fill","Stack","heap","length","constructing","create","HeapCls","s","TypeError","pop","maxSize","dispose","disposeAfter","fetchMethod","ttl","ttlResolution","ttlAutopurge","updateAgeOnGet","updateAgeOnHas","allowStale","noDisposeOnSet","noUpdateTTL","maxEntrySize","sizeCalculation","noDeleteOnFetchRejection","noDeleteOnStaleGet","allowStaleOnFetchAbort","allowStaleOnFetchRejection","ignoreFetchAbort","calculatedSize","keyMap","keyList","valList","next","prev","head","tail","free","disposed","sizes","starts","ttls","hasDispose","hasFetchMethod","hasDisposeAfter","unsafeExposeInternals","c","isBackgroundFetch","p","backgroundFetch","k","index","options","context","moveToTail","indexes","rindexes","isStale","UintArray","Error","undefined","Map","initializeSizeTracking","initializeTTLTracking","add","getRemainingTTL","key","Infinity","setItemTTL","start","t","setTimeout","delete","unref","updateItemAge","statusTTL","status","cachedNow","getNow","age","remainingTTL","get","removeItemSize","requireSize","v","addItemSize","evict","entrySize","totalCalculatedSize","_i","_s","_st","_k","_v","i","isValidIndex","entries","rentries","keys","rkeys","values","rvalues","iterator","find","getOptions","__staleWhileFetching","forEach","thisp","call","rforEach","purgeStale","deleted","info","entry","remain","dump","arr","unshift","load","clear","set","setOptions","maxEntrySizeExceeded","oldVal","__abortController","oldValue","dt","task","shift","val","hasOptions","peek","peekOptions","ac","fetchOpts","cb","updateCache","ignoreAbort","fetchAborted","fetchError","fetchAbortIgnored","fetchResolved","fetchFail","bf","fetchUpdated","eb","er","fetchRejected","allowStaleAborted","noDelete","del","returnedStale","__returned","pcall","res","rej","fmp","Promise","then","fetchDispatched","assign","b","hasOwnProperty","fetch","fetchOptions","forceRefresh","stale","hasStale","staleVal","fetching","connect","pi","ni"],"sources":["I:/Angular/angular-blog/node_modules/path-scurry/node_modules/lru-cache/dist/commonjs/index.js"],"sourcesContent":["\"use strict\";\n/**\n * @module LRUCache\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LRUCache = void 0;\nconst perf = typeof performance === 'object' &&\n    performance &&\n    typeof performance.now === 'function'\n    ? performance\n    : Date;\nconst warned = new Set();\n/* c8 ignore start */\nconst PROCESS = (typeof process === 'object' && !!process ? process : {});\n/* c8 ignore start */\nconst emitWarning = (msg, type, code, fn) => {\n    typeof PROCESS.emitWarning === 'function'\n        ? PROCESS.emitWarning(msg, type, code, fn)\n        : console.error(`[${code}] ${type}: ${msg}`);\n};\nlet AC = globalThis.AbortController;\nlet AS = globalThis.AbortSignal;\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n    //@ts-ignore\n    AS = class AbortSignal {\n        onabort;\n        _onabort = [];\n        reason;\n        aborted = false;\n        addEventListener(_, fn) {\n            this._onabort.push(fn);\n        }\n    };\n    //@ts-ignore\n    AC = class AbortController {\n        constructor() {\n            warnACPolyfill();\n        }\n        signal = new AS();\n        abort(reason) {\n            if (this.signal.aborted)\n                return;\n            //@ts-ignore\n            this.signal.reason = reason;\n            //@ts-ignore\n            this.signal.aborted = true;\n            //@ts-ignore\n            for (const fn of this.signal._onabort) {\n                fn(reason);\n            }\n            this.signal.onabort?.(reason);\n        }\n    };\n    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';\n    const warnACPolyfill = () => {\n        if (!printACPolyfillWarning)\n            return;\n        printACPolyfillWarning = false;\n        emitWarning('AbortController is not defined. If using lru-cache in ' +\n            'node 14, load an AbortController polyfill from the ' +\n            '`node-abort-controller` package. A minimal polyfill is ' +\n            'provided for use by LRUCache.fetch(), but it should not be ' +\n            'relied upon in other contexts (eg, passing it to other APIs that ' +\n            'use AbortController/AbortSignal might have undesirable effects). ' +\n            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);\n    };\n}\n/* c8 ignore stop */\nconst shouldWarn = (code) => !warned.has(code);\nconst TYPE = Symbol('type');\nconst isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max) => !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n        ? Uint8Array\n        : max <= Math.pow(2, 16)\n            ? Uint16Array\n            : max <= Math.pow(2, 32)\n                ? Uint32Array\n                : max <= Number.MAX_SAFE_INTEGER\n                    ? ZeroArray\n                    : null;\n/* c8 ignore stop */\nclass ZeroArray extends Array {\n    constructor(size) {\n        super(size);\n        this.fill(0);\n    }\n}\nclass Stack {\n    heap;\n    length;\n    // private constructor\n    static #constructing = false;\n    static create(max) {\n        const HeapCls = getUintArray(max);\n        if (!HeapCls)\n            return [];\n        Stack.#constructing = true;\n        const s = new Stack(max, HeapCls);\n        Stack.#constructing = false;\n        return s;\n    }\n    constructor(max, HeapCls) {\n        /* c8 ignore start */\n        if (!Stack.#constructing) {\n            throw new TypeError('instantiate Stack using Stack.create(n)');\n        }\n        /* c8 ignore stop */\n        this.heap = new HeapCls(max);\n        this.length = 0;\n    }\n    push(n) {\n        this.heap[this.length++] = n;\n    }\n    pop() {\n        return this.heap[--this.length];\n    }\n}\n/**\n * Default export, the thing you're using this module to get.\n *\n * All properties from the options object (with the exception of\n * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as\n * normal public members. (`max` and `maxBase` are read-only getters.)\n * Changing any of these will alter the defaults for subsequent method calls,\n * but is otherwise safe.\n */\nclass LRUCache {\n    // properties coming in from the options of these, only max and maxSize\n    // really *need* to be protected. The rest can be modified, as they just\n    // set defaults for various methods.\n    #max;\n    #maxSize;\n    #dispose;\n    #disposeAfter;\n    #fetchMethod;\n    /**\n     * {@link LRUCache.OptionsBase.ttl}\n     */\n    ttl;\n    /**\n     * {@link LRUCache.OptionsBase.ttlResolution}\n     */\n    ttlResolution;\n    /**\n     * {@link LRUCache.OptionsBase.ttlAutopurge}\n     */\n    ttlAutopurge;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnGet}\n     */\n    updateAgeOnGet;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnHas}\n     */\n    updateAgeOnHas;\n    /**\n     * {@link LRUCache.OptionsBase.allowStale}\n     */\n    allowStale;\n    /**\n     * {@link LRUCache.OptionsBase.noDisposeOnSet}\n     */\n    noDisposeOnSet;\n    /**\n     * {@link LRUCache.OptionsBase.noUpdateTTL}\n     */\n    noUpdateTTL;\n    /**\n     * {@link LRUCache.OptionsBase.maxEntrySize}\n     */\n    maxEntrySize;\n    /**\n     * {@link LRUCache.OptionsBase.sizeCalculation}\n     */\n    sizeCalculation;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n     */\n    noDeleteOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n     */\n    noDeleteOnStaleGet;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n     */\n    allowStaleOnFetchAbort;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n     */\n    allowStaleOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n     */\n    ignoreFetchAbort;\n    // computed properties\n    #size;\n    #calculatedSize;\n    #keyMap;\n    #keyList;\n    #valList;\n    #next;\n    #prev;\n    #head;\n    #tail;\n    #free;\n    #disposed;\n    #sizes;\n    #starts;\n    #ttls;\n    #hasDispose;\n    #hasFetchMethod;\n    #hasDisposeAfter;\n    /**\n     * Do not call this method unless you need to inspect the\n     * inner workings of the cache.  If anything returned by this\n     * object is modified in any way, strange breakage may occur.\n     *\n     * These fields are private for a reason!\n     *\n     * @internal\n     */\n    static unsafeExposeInternals(c) {\n        return {\n            // properties\n            starts: c.#starts,\n            ttls: c.#ttls,\n            sizes: c.#sizes,\n            keyMap: c.#keyMap,\n            keyList: c.#keyList,\n            valList: c.#valList,\n            next: c.#next,\n            prev: c.#prev,\n            get head() {\n                return c.#head;\n            },\n            get tail() {\n                return c.#tail;\n            },\n            free: c.#free,\n            // methods\n            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),\n            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),\n            moveToTail: (index) => c.#moveToTail(index),\n            indexes: (options) => c.#indexes(options),\n            rindexes: (options) => c.#rindexes(options),\n            isStale: (index) => c.#isStale(index),\n        };\n    }\n    // Protected read-only members\n    /**\n     * {@link LRUCache.OptionsBase.max} (read-only)\n     */\n    get max() {\n        return this.#max;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.maxSize} (read-only)\n     */\n    get maxSize() {\n        return this.#maxSize;\n    }\n    /**\n     * The total computed size of items in the cache (read-only)\n     */\n    get calculatedSize() {\n        return this.#calculatedSize;\n    }\n    /**\n     * The number of items stored in the cache (read-only)\n     */\n    get size() {\n        return this.#size;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n     */\n    get fetchMethod() {\n        return this.#fetchMethod;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.dispose} (read-only)\n     */\n    get dispose() {\n        return this.#dispose;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n     */\n    get disposeAfter() {\n        return this.#disposeAfter;\n    }\n    constructor(options) {\n        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;\n        if (max !== 0 && !isPosInt(max)) {\n            throw new TypeError('max option must be a nonnegative integer');\n        }\n        const UintArray = max ? getUintArray(max) : Array;\n        if (!UintArray) {\n            throw new Error('invalid max value: ' + max);\n        }\n        this.#max = max;\n        this.#maxSize = maxSize;\n        this.maxEntrySize = maxEntrySize || this.#maxSize;\n        this.sizeCalculation = sizeCalculation;\n        if (this.sizeCalculation) {\n            if (!this.#maxSize && !this.maxEntrySize) {\n                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');\n            }\n            if (typeof this.sizeCalculation !== 'function') {\n                throw new TypeError('sizeCalculation set to non-function');\n            }\n        }\n        if (fetchMethod !== undefined &&\n            typeof fetchMethod !== 'function') {\n            throw new TypeError('fetchMethod must be a function if specified');\n        }\n        this.#fetchMethod = fetchMethod;\n        this.#hasFetchMethod = !!fetchMethod;\n        this.#keyMap = new Map();\n        this.#keyList = new Array(max).fill(undefined);\n        this.#valList = new Array(max).fill(undefined);\n        this.#next = new UintArray(max);\n        this.#prev = new UintArray(max);\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free = Stack.create(max);\n        this.#size = 0;\n        this.#calculatedSize = 0;\n        if (typeof dispose === 'function') {\n            this.#dispose = dispose;\n        }\n        if (typeof disposeAfter === 'function') {\n            this.#disposeAfter = disposeAfter;\n            this.#disposed = [];\n        }\n        else {\n            this.#disposeAfter = undefined;\n            this.#disposed = undefined;\n        }\n        this.#hasDispose = !!this.#dispose;\n        this.#hasDisposeAfter = !!this.#disposeAfter;\n        this.noDisposeOnSet = !!noDisposeOnSet;\n        this.noUpdateTTL = !!noUpdateTTL;\n        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n        this.ignoreFetchAbort = !!ignoreFetchAbort;\n        // NB: maxEntrySize is set to maxSize if it's set\n        if (this.maxEntrySize !== 0) {\n            if (this.#maxSize !== 0) {\n                if (!isPosInt(this.#maxSize)) {\n                    throw new TypeError('maxSize must be a positive integer if specified');\n                }\n            }\n            if (!isPosInt(this.maxEntrySize)) {\n                throw new TypeError('maxEntrySize must be a positive integer if specified');\n            }\n            this.#initializeSizeTracking();\n        }\n        this.allowStale = !!allowStale;\n        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n        this.updateAgeOnGet = !!updateAgeOnGet;\n        this.updateAgeOnHas = !!updateAgeOnHas;\n        this.ttlResolution =\n            isPosInt(ttlResolution) || ttlResolution === 0\n                ? ttlResolution\n                : 1;\n        this.ttlAutopurge = !!ttlAutopurge;\n        this.ttl = ttl || 0;\n        if (this.ttl) {\n            if (!isPosInt(this.ttl)) {\n                throw new TypeError('ttl must be a positive integer if specified');\n            }\n            this.#initializeTTLTracking();\n        }\n        // do not allow completely unbounded caches\n        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n            throw new TypeError('At least one of max, maxSize, or ttl is required');\n        }\n        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n            const code = 'LRU_CACHE_UNBOUNDED';\n            if (shouldWarn(code)) {\n                warned.add(code);\n                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +\n                    'result in unbounded memory consumption.';\n                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);\n            }\n        }\n    }\n    /**\n     * Return the remaining TTL time for a given entry key\n     */\n    getRemainingTTL(key) {\n        return this.#keyMap.has(key) ? Infinity : 0;\n    }\n    #initializeTTLTracking() {\n        const ttls = new ZeroArray(this.#max);\n        const starts = new ZeroArray(this.#max);\n        this.#ttls = ttls;\n        this.#starts = starts;\n        this.#setItemTTL = (index, ttl, start = perf.now()) => {\n            starts[index] = ttl !== 0 ? start : 0;\n            ttls[index] = ttl;\n            if (ttl !== 0 && this.ttlAutopurge) {\n                const t = setTimeout(() => {\n                    if (this.#isStale(index)) {\n                        this.delete(this.#keyList[index]);\n                    }\n                }, ttl + 1);\n                // unref() not supported on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n        };\n        this.#updateItemAge = index => {\n            starts[index] = ttls[index] !== 0 ? perf.now() : 0;\n        };\n        this.#statusTTL = (status, index) => {\n            if (ttls[index]) {\n                const ttl = ttls[index];\n                const start = starts[index];\n                /* c8 ignore next */\n                if (!ttl || !start)\n                    return;\n                status.ttl = ttl;\n                status.start = start;\n                status.now = cachedNow || getNow();\n                const age = status.now - start;\n                status.remainingTTL = ttl - age;\n            }\n        };\n        // debounce calls to perf.now() to 1s so we're not hitting\n        // that costly call repeatedly.\n        let cachedNow = 0;\n        const getNow = () => {\n            const n = perf.now();\n            if (this.ttlResolution > 0) {\n                cachedNow = n;\n                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);\n                // not available on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n            return n;\n        };\n        this.getRemainingTTL = key => {\n            const index = this.#keyMap.get(key);\n            if (index === undefined) {\n                return 0;\n            }\n            const ttl = ttls[index];\n            const start = starts[index];\n            if (!ttl || !start) {\n                return Infinity;\n            }\n            const age = (cachedNow || getNow()) - start;\n            return ttl - age;\n        };\n        this.#isStale = index => {\n            const s = starts[index];\n            const t = ttls[index];\n            return !!t && !!s && (cachedNow || getNow()) - s > t;\n        };\n    }\n    // conditionally set private methods related to TTL\n    #updateItemAge = () => { };\n    #statusTTL = () => { };\n    #setItemTTL = () => { };\n    /* c8 ignore stop */\n    #isStale = () => false;\n    #initializeSizeTracking() {\n        const sizes = new ZeroArray(this.#max);\n        this.#calculatedSize = 0;\n        this.#sizes = sizes;\n        this.#removeItemSize = index => {\n            this.#calculatedSize -= sizes[index];\n            sizes[index] = 0;\n        };\n        this.#requireSize = (k, v, size, sizeCalculation) => {\n            // provisionally accept background fetches.\n            // actual value size will be checked when they return.\n            if (this.#isBackgroundFetch(v)) {\n                return 0;\n            }\n            if (!isPosInt(size)) {\n                if (sizeCalculation) {\n                    if (typeof sizeCalculation !== 'function') {\n                        throw new TypeError('sizeCalculation must be a function');\n                    }\n                    size = sizeCalculation(v, k);\n                    if (!isPosInt(size)) {\n                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');\n                    }\n                }\n                else {\n                    throw new TypeError('invalid size value (must be positive integer). ' +\n                        'When maxSize or maxEntrySize is used, sizeCalculation ' +\n                        'or size must be set.');\n                }\n            }\n            return size;\n        };\n        this.#addItemSize = (index, size, status) => {\n            sizes[index] = size;\n            if (this.#maxSize) {\n                const maxSize = this.#maxSize - sizes[index];\n                while (this.#calculatedSize > maxSize) {\n                    this.#evict(true);\n                }\n            }\n            this.#calculatedSize += sizes[index];\n            if (status) {\n                status.entrySize = size;\n                status.totalCalculatedSize = this.#calculatedSize;\n            }\n        };\n    }\n    #removeItemSize = _i => { };\n    #addItemSize = (_i, _s, _st) => { };\n    #requireSize = (_k, _v, size, sizeCalculation) => {\n        if (size || sizeCalculation) {\n            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');\n        }\n        return 0;\n    };\n    *#indexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#tail; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#head) {\n                    break;\n                }\n                else {\n                    i = this.#prev[i];\n                }\n            }\n        }\n    }\n    *#rindexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#head; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#tail) {\n                    break;\n                }\n                else {\n                    i = this.#next[i];\n                }\n            }\n        }\n    }\n    #isValidIndex(index) {\n        return (index !== undefined &&\n            this.#keyMap.get(this.#keyList[index]) === index);\n    }\n    /**\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from most recently used to least recently used.\n     */\n    *entries() {\n        for (const i of this.#indexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.entries}\n     *\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from least recently used to most recently used.\n     */\n    *rentries() {\n        for (const i of this.#rindexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the keys in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *keys() {\n        for (const i of this.#indexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.keys}\n     *\n     * Return a generator yielding the keys in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rkeys() {\n        for (const i of this.#rindexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the values in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *values() {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.values}\n     *\n     * Return a generator yielding the values in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rvalues() {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Iterating over the cache itself yields the same results as\n     * {@link LRUCache.entries}\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * Find a value for which the supplied fn method returns a truthy value,\n     * similar to Array.find().  fn is called as fn(value, key, cache).\n     */\n    find(fn, getOptions = {}) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            if (fn(value, this.#keyList[i], this)) {\n                return this.get(this.#keyList[i], getOptions);\n            }\n        }\n    }\n    /**\n     * Call the supplied function on each item in the cache, in order from\n     * most recently used to least recently used.  fn is called as\n     * fn(value, key, cache).  Does not update age or recenty of use.\n     * Does not iterate over stale values.\n     */\n    forEach(fn, thisp = this) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * The same as {@link LRUCache.forEach} but items are iterated over in\n     * reverse order.  (ie, less recently used items are iterated over first.)\n     */\n    rforEach(fn, thisp = this) {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * Delete any stale entries. Returns true if anything was removed,\n     * false otherwise.\n     */\n    purgeStale() {\n        let deleted = false;\n        for (const i of this.#rindexes({ allowStale: true })) {\n            if (this.#isStale(i)) {\n                this.delete(this.#keyList[i]);\n                deleted = true;\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Get the extended info about a given entry, to get its value, size, and\n     * TTL info simultaneously. Like {@link LRUCache#dump}, but just for a\n     * single key. Always returns stale values, if their info is found in the\n     * cache, so be sure to check for expired TTLs if relevant.\n     */\n    info(key) {\n        const i = this.#keyMap.get(key);\n        if (i === undefined)\n            return undefined;\n        const v = this.#valList[i];\n        const value = this.#isBackgroundFetch(v)\n            ? v.__staleWhileFetching\n            : v;\n        if (value === undefined)\n            return undefined;\n        const entry = { value };\n        if (this.#ttls && this.#starts) {\n            const ttl = this.#ttls[i];\n            const start = this.#starts[i];\n            if (ttl && start) {\n                const remain = ttl - (perf.now() - start);\n                entry.ttl = remain;\n                entry.start = Date.now();\n            }\n        }\n        if (this.#sizes) {\n            entry.size = this.#sizes[i];\n        }\n        return entry;\n    }\n    /**\n     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n     * passed to cache.load()\n     */\n    dump() {\n        const arr = [];\n        for (const i of this.#indexes({ allowStale: true })) {\n            const key = this.#keyList[i];\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined || key === undefined)\n                continue;\n            const entry = { value };\n            if (this.#ttls && this.#starts) {\n                entry.ttl = this.#ttls[i];\n                // always dump the start relative to a portable timestamp\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = perf.now() - this.#starts[i];\n                entry.start = Math.floor(Date.now() - age);\n            }\n            if (this.#sizes) {\n                entry.size = this.#sizes[i];\n            }\n            arr.unshift([key, entry]);\n        }\n        return arr;\n    }\n    /**\n     * Reset the cache and load in the items in entries in the order listed.\n     * Note that the shape of the resulting cache may be different if the\n     * same options are not used in both caches.\n     */\n    load(arr) {\n        this.clear();\n        for (const [key, entry] of arr) {\n            if (entry.start) {\n                // entry.start is a portable timestamp, but we may be using\n                // node's performance.now(), so calculate the offset, so that\n                // we get the intended remaining TTL, no matter how long it's\n                // been on ice.\n                //\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = Date.now() - entry.start;\n                entry.start = perf.now() - age;\n            }\n            this.set(key, entry.value, entry);\n        }\n    }\n    /**\n     * Add a value to the cache.\n     *\n     * Note: if `undefined` is specified as a value, this is an alias for\n     * {@link LRUCache#delete}\n     */\n    set(k, v, setOptions = {}) {\n        if (v === undefined) {\n            this.delete(k);\n            return this;\n        }\n        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;\n        let { noUpdateTTL = this.noUpdateTTL } = setOptions;\n        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);\n        // if the item doesn't fit, don't do anything\n        // NB: maxEntrySize set to maxSize by default\n        if (this.maxEntrySize && size > this.maxEntrySize) {\n            if (status) {\n                status.set = 'miss';\n                status.maxEntrySizeExceeded = true;\n            }\n            // have to delete, in case something is there already.\n            this.delete(k);\n            return this;\n        }\n        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);\n        if (index === undefined) {\n            // addition\n            index = (this.#size === 0\n                ? this.#tail\n                : this.#free.length !== 0\n                    ? this.#free.pop()\n                    : this.#size === this.#max\n                        ? this.#evict(false)\n                        : this.#size);\n            this.#keyList[index] = k;\n            this.#valList[index] = v;\n            this.#keyMap.set(k, index);\n            this.#next[this.#tail] = index;\n            this.#prev[index] = this.#tail;\n            this.#tail = index;\n            this.#size++;\n            this.#addItemSize(index, size, status);\n            if (status)\n                status.set = 'add';\n            noUpdateTTL = false;\n        }\n        else {\n            // update\n            this.#moveToTail(index);\n            const oldVal = this.#valList[index];\n            if (v !== oldVal) {\n                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n                    oldVal.__abortController.abort(new Error('replaced'));\n                    const { __staleWhileFetching: s } = oldVal;\n                    if (s !== undefined && !noDisposeOnSet) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(s, k, 'set');\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([s, k, 'set']);\n                        }\n                    }\n                }\n                else if (!noDisposeOnSet) {\n                    if (this.#hasDispose) {\n                        this.#dispose?.(oldVal, k, 'set');\n                    }\n                    if (this.#hasDisposeAfter) {\n                        this.#disposed?.push([oldVal, k, 'set']);\n                    }\n                }\n                this.#removeItemSize(index);\n                this.#addItemSize(index, size, status);\n                this.#valList[index] = v;\n                if (status) {\n                    status.set = 'replace';\n                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)\n                        ? oldVal.__staleWhileFetching\n                        : oldVal;\n                    if (oldValue !== undefined)\n                        status.oldValue = oldValue;\n                }\n            }\n            else if (status) {\n                status.set = 'update';\n            }\n        }\n        if (ttl !== 0 && !this.#ttls) {\n            this.#initializeTTLTracking();\n        }\n        if (this.#ttls) {\n            if (!noUpdateTTL) {\n                this.#setItemTTL(index, ttl, start);\n            }\n            if (status)\n                this.#statusTTL(status, index);\n        }\n        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return this;\n    }\n    /**\n     * Evict the least recently used item, returning its value or\n     * `undefined` if cache is empty.\n     */\n    pop() {\n        try {\n            while (this.#size) {\n                const val = this.#valList[this.#head];\n                this.#evict(true);\n                if (this.#isBackgroundFetch(val)) {\n                    if (val.__staleWhileFetching) {\n                        return val.__staleWhileFetching;\n                    }\n                }\n                else if (val !== undefined) {\n                    return val;\n                }\n            }\n        }\n        finally {\n            if (this.#hasDisposeAfter && this.#disposed) {\n                const dt = this.#disposed;\n                let task;\n                while ((task = dt?.shift())) {\n                    this.#disposeAfter?.(...task);\n                }\n            }\n        }\n    }\n    #evict(free) {\n        const head = this.#head;\n        const k = this.#keyList[head];\n        const v = this.#valList[head];\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('evicted'));\n        }\n        else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n                this.#dispose?.(v, k, 'evict');\n            }\n            if (this.#hasDisposeAfter) {\n                this.#disposed?.push([v, k, 'evict']);\n            }\n        }\n        this.#removeItemSize(head);\n        // if we aren't about to use the index, then null these out\n        if (free) {\n            this.#keyList[head] = undefined;\n            this.#valList[head] = undefined;\n            this.#free.push(head);\n        }\n        if (this.#size === 1) {\n            this.#head = this.#tail = 0;\n            this.#free.length = 0;\n        }\n        else {\n            this.#head = this.#next[head];\n        }\n        this.#keyMap.delete(k);\n        this.#size--;\n        return head;\n    }\n    /**\n     * Check if a key is in the cache, without updating the recency of use.\n     * Will return false if the item is stale, even though it is technically\n     * in the cache.\n     *\n     * Will not update item age unless\n     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n     */\n    has(k, hasOptions = {}) {\n        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v) &&\n                v.__staleWhileFetching === undefined) {\n                return false;\n            }\n            if (!this.#isStale(index)) {\n                if (updateAgeOnHas) {\n                    this.#updateItemAge(index);\n                }\n                if (status) {\n                    status.has = 'hit';\n                    this.#statusTTL(status, index);\n                }\n                return true;\n            }\n            else if (status) {\n                status.has = 'stale';\n                this.#statusTTL(status, index);\n            }\n        }\n        else if (status) {\n            status.has = 'miss';\n        }\n        return false;\n    }\n    /**\n     * Like {@link LRUCache#get} but doesn't update recency or delete stale\n     * items.\n     *\n     * Returns `undefined` if the item is stale, unless\n     * {@link LRUCache.OptionsBase.allowStale} is set.\n     */\n    peek(k, peekOptions = {}) {\n        const { allowStale = this.allowStale } = peekOptions;\n        const index = this.#keyMap.get(k);\n        if (index === undefined ||\n            (!allowStale && this.#isStale(index))) {\n            return;\n        }\n        const v = this.#valList[index];\n        // either stale and allowed, or forcing a refresh of non-stale value\n        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n    }\n    #backgroundFetch(k, index, options, context) {\n        const v = index === undefined ? undefined : this.#valList[index];\n        if (this.#isBackgroundFetch(v)) {\n            return v;\n        }\n        const ac = new AC();\n        const { signal } = options;\n        // when/if our AC signals, then stop listening to theirs.\n        signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n            signal: ac.signal,\n        });\n        const fetchOpts = {\n            signal: ac.signal,\n            options,\n            context,\n        };\n        const cb = (v, updateCache = false) => {\n            const { aborted } = ac.signal;\n            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n            if (options.status) {\n                if (aborted && !updateCache) {\n                    options.status.fetchAborted = true;\n                    options.status.fetchError = ac.signal.reason;\n                    if (ignoreAbort)\n                        options.status.fetchAbortIgnored = true;\n                }\n                else {\n                    options.status.fetchResolved = true;\n                }\n            }\n            if (aborted && !ignoreAbort && !updateCache) {\n                return fetchFail(ac.signal.reason);\n            }\n            // either we didn't abort, and are still here, or we did, and ignored\n            const bf = p;\n            if (this.#valList[index] === p) {\n                if (v === undefined) {\n                    if (bf.__staleWhileFetching) {\n                        this.#valList[index] = bf.__staleWhileFetching;\n                    }\n                    else {\n                        this.delete(k);\n                    }\n                }\n                else {\n                    if (options.status)\n                        options.status.fetchUpdated = true;\n                    this.set(k, v, fetchOpts.options);\n                }\n            }\n            return v;\n        };\n        const eb = (er) => {\n            if (options.status) {\n                options.status.fetchRejected = true;\n                options.status.fetchError = er;\n            }\n            return fetchFail(er);\n        };\n        const fetchFail = (er) => {\n            const { aborted } = ac.signal;\n            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n            const noDelete = allowStale || options.noDeleteOnFetchRejection;\n            const bf = p;\n            if (this.#valList[index] === p) {\n                // if we allow stale on fetch rejections, then we need to ensure that\n                // the stale value is not removed from the cache when the fetch fails.\n                const del = !noDelete || bf.__staleWhileFetching === undefined;\n                if (del) {\n                    this.delete(k);\n                }\n                else if (!allowStaleAborted) {\n                    // still replace the *promise* with the stale value,\n                    // since we are done with the promise at this point.\n                    // leave it untouched if we're still waiting for an\n                    // aborted background fetch that hasn't yet returned.\n                    this.#valList[index] = bf.__staleWhileFetching;\n                }\n            }\n            if (allowStale) {\n                if (options.status && bf.__staleWhileFetching !== undefined) {\n                    options.status.returnedStale = true;\n                }\n                return bf.__staleWhileFetching;\n            }\n            else if (bf.__returned === bf) {\n                throw er;\n            }\n        };\n        const pcall = (res, rej) => {\n            const fmp = this.#fetchMethod?.(k, v, fetchOpts);\n            if (fmp && fmp instanceof Promise) {\n                fmp.then(v => res(v === undefined ? undefined : v), rej);\n            }\n            // ignored, we go until we finish, regardless.\n            // defer check until we are actually aborting,\n            // so fetchMethod can override.\n            ac.signal.addEventListener('abort', () => {\n                if (!options.ignoreFetchAbort ||\n                    options.allowStaleOnFetchAbort) {\n                    res(undefined);\n                    // when it eventually resolves, update the cache.\n                    if (options.allowStaleOnFetchAbort) {\n                        res = v => cb(v, true);\n                    }\n                }\n            });\n        };\n        if (options.status)\n            options.status.fetchDispatched = true;\n        const p = new Promise(pcall).then(cb, eb);\n        const bf = Object.assign(p, {\n            __abortController: ac,\n            __staleWhileFetching: v,\n            __returned: undefined,\n        });\n        if (index === undefined) {\n            // internal, don't expose status.\n            this.set(k, bf, { ...fetchOpts.options, status: undefined });\n            index = this.#keyMap.get(k);\n        }\n        else {\n            this.#valList[index] = bf;\n        }\n        return bf;\n    }\n    #isBackgroundFetch(p) {\n        if (!this.#hasFetchMethod)\n            return false;\n        const b = p;\n        return (!!b &&\n            b instanceof Promise &&\n            b.hasOwnProperty('__staleWhileFetching') &&\n            b.__abortController instanceof AC);\n    }\n    async fetch(k, fetchOptions = {}) {\n        const { \n        // get options\n        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, \n        // set options\n        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, \n        // fetch exclusive options\n        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;\n        if (!this.#hasFetchMethod) {\n            if (status)\n                status.fetch = 'get';\n            return this.get(k, {\n                allowStale,\n                updateAgeOnGet,\n                noDeleteOnStaleGet,\n                status,\n            });\n        }\n        const options = {\n            allowStale,\n            updateAgeOnGet,\n            noDeleteOnStaleGet,\n            ttl,\n            noDisposeOnSet,\n            size,\n            sizeCalculation,\n            noUpdateTTL,\n            noDeleteOnFetchRejection,\n            allowStaleOnFetchRejection,\n            allowStaleOnFetchAbort,\n            ignoreFetchAbort,\n            status,\n            signal,\n        };\n        let index = this.#keyMap.get(k);\n        if (index === undefined) {\n            if (status)\n                status.fetch = 'miss';\n            const p = this.#backgroundFetch(k, index, options, context);\n            return (p.__returned = p);\n        }\n        else {\n            // in cache, maybe already fetching\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                const stale = allowStale && v.__staleWhileFetching !== undefined;\n                if (status) {\n                    status.fetch = 'inflight';\n                    if (stale)\n                        status.returnedStale = true;\n                }\n                return stale ? v.__staleWhileFetching : (v.__returned = v);\n            }\n            // if we force a refresh, that means do NOT serve the cached value,\n            // unless we are already in the process of refreshing the cache.\n            const isStale = this.#isStale(index);\n            if (!forceRefresh && !isStale) {\n                if (status)\n                    status.fetch = 'hit';\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                if (status)\n                    this.#statusTTL(status, index);\n                return v;\n            }\n            // ok, it is stale or a forced refresh, and not already fetching.\n            // refresh the cache.\n            const p = this.#backgroundFetch(k, index, options, context);\n            const hasStale = p.__staleWhileFetching !== undefined;\n            const staleVal = hasStale && allowStale;\n            if (status) {\n                status.fetch = isStale ? 'stale' : 'refresh';\n                if (staleVal && isStale)\n                    status.returnedStale = true;\n            }\n            return staleVal ? p.__staleWhileFetching : (p.__returned = p);\n        }\n    }\n    /**\n     * Return a value from the cache. Will update the recency of the cache\n     * entry found.\n     *\n     * If the key is not found, get() will return `undefined`.\n     */\n    get(k, getOptions = {}) {\n        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const value = this.#valList[index];\n            const fetching = this.#isBackgroundFetch(value);\n            if (status)\n                this.#statusTTL(status, index);\n            if (this.#isStale(index)) {\n                if (status)\n                    status.get = 'stale';\n                // delete only if not an in-flight background fetch\n                if (!fetching) {\n                    if (!noDeleteOnStaleGet) {\n                        this.delete(k);\n                    }\n                    if (status && allowStale)\n                        status.returnedStale = true;\n                    return allowStale ? value : undefined;\n                }\n                else {\n                    if (status &&\n                        allowStale &&\n                        value.__staleWhileFetching !== undefined) {\n                        status.returnedStale = true;\n                    }\n                    return allowStale ? value.__staleWhileFetching : undefined;\n                }\n            }\n            else {\n                if (status)\n                    status.get = 'hit';\n                // if we're currently fetching it, we don't actually have it yet\n                // it's not stale, which means this isn't a staleWhileRefetching.\n                // If it's not stale, and fetching, AND has a __staleWhileFetching\n                // value, then that means the user fetched with {forceRefresh:true},\n                // so it's safe to return that value.\n                if (fetching) {\n                    return value.__staleWhileFetching;\n                }\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                return value;\n            }\n        }\n        else if (status) {\n            status.get = 'miss';\n        }\n    }\n    #connect(p, n) {\n        this.#prev[n] = p;\n        this.#next[p] = n;\n    }\n    #moveToTail(index) {\n        // if tail already, nothing to do\n        // if head, move head to next[index]\n        // else\n        //   move next[prev[index]] to next[index] (head has no prev)\n        //   move prev[next[index]] to prev[index]\n        // prev[index] = tail\n        // next[tail] = index\n        // tail = index\n        if (index !== this.#tail) {\n            if (index === this.#head) {\n                this.#head = this.#next[index];\n            }\n            else {\n                this.#connect(this.#prev[index], this.#next[index]);\n            }\n            this.#connect(this.#tail, index);\n            this.#tail = index;\n        }\n    }\n    /**\n     * Deletes a key out of the cache.\n     * Returns true if the key was deleted, false otherwise.\n     */\n    delete(k) {\n        let deleted = false;\n        if (this.#size !== 0) {\n            const index = this.#keyMap.get(k);\n            if (index !== undefined) {\n                deleted = true;\n                if (this.#size === 1) {\n                    this.clear();\n                }\n                else {\n                    this.#removeItemSize(index);\n                    const v = this.#valList[index];\n                    if (this.#isBackgroundFetch(v)) {\n                        v.__abortController.abort(new Error('deleted'));\n                    }\n                    else if (this.#hasDispose || this.#hasDisposeAfter) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(v, k, 'delete');\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([v, k, 'delete']);\n                        }\n                    }\n                    this.#keyMap.delete(k);\n                    this.#keyList[index] = undefined;\n                    this.#valList[index] = undefined;\n                    if (index === this.#tail) {\n                        this.#tail = this.#prev[index];\n                    }\n                    else if (index === this.#head) {\n                        this.#head = this.#next[index];\n                    }\n                    else {\n                        const pi = this.#prev[index];\n                        this.#next[pi] = this.#next[index];\n                        const ni = this.#next[index];\n                        this.#prev[ni] = this.#prev[index];\n                    }\n                    this.#size--;\n                    this.#free.push(index);\n                }\n            }\n        }\n        if (this.#hasDisposeAfter && this.#disposed?.length) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Clear the cache entirely, throwing away all values.\n     */\n    clear() {\n        for (const index of this.#rindexes({ allowStale: true })) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                v.__abortController.abort(new Error('deleted'));\n            }\n            else {\n                const k = this.#keyList[index];\n                if (this.#hasDispose) {\n                    this.#dispose?.(v, k, 'delete');\n                }\n                if (this.#hasDisposeAfter) {\n                    this.#disposed?.push([v, k, 'delete']);\n                }\n            }\n        }\n        this.#keyMap.clear();\n        this.#valList.fill(undefined);\n        this.#keyList.fill(undefined);\n        if (this.#ttls && this.#starts) {\n            this.#ttls.fill(0);\n            this.#starts.fill(0);\n        }\n        if (this.#sizes) {\n            this.#sizes.fill(0);\n        }\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free.length = 0;\n        this.#calculatedSize = 0;\n        this.#size = 0;\n        if (this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n    }\n}\nexports.LRUCache = LRUCache;\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AAFA;AAGAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,QAAQ,GAAG,KAAK,CAAC;AACzB,MAAMC,IAAI,GAAG,OAAOC,WAAW,KAAK,QAAQ,IACxCA,WAAW,IACX,OAAOA,WAAW,CAACC,GAAG,KAAK,UAAU,GACnCD,WAAW,GACXE,IAAI;AACV,MAAMC,MAAM,GAAG,IAAIC,GAAG,EAAE;AACxB;AACA,MAAMC,OAAO,GAAI,OAAOC,OAAO,KAAK,QAAQ,IAAI,CAAC,CAACA,OAAO,GAAGA,OAAO,GAAG,CAAC,CAAE;AACzE;AACA,MAAMC,WAAW,GAAG,CAACC,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAEC,EAAE,KAAK;EACzC,OAAON,OAAO,CAACE,WAAW,KAAK,UAAU,GACnCF,OAAO,CAACE,WAAW,CAACC,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAEC,EAAE,CAAC,GACxCC,OAAO,CAACC,KAAK,CAAE,IAAGH,IAAK,KAAID,IAAK,KAAID,GAAI,EAAC,CAAC;AACpD,CAAC;AACD,IAAIM,EAAE,GAAGC,UAAU,CAACC,eAAe;AACnC,IAAIC,EAAE,GAAGF,UAAU,CAACG,WAAW;AAC/B;AACA,IAAI,OAAOJ,EAAE,KAAK,WAAW,EAAE;EAC3B;EACAG,EAAE,GAAG,MAAMC,WAAW,CAAC;IACnBC,OAAO;IACPC,QAAQ,GAAG,EAAE;IACbC,MAAM;IACNC,OAAO,GAAG,KAAK;IACfC,gBAAgB,CAACC,CAAC,EAAEb,EAAE,EAAE;MACpB,IAAI,CAACS,QAAQ,CAACK,IAAI,CAACd,EAAE,CAAC;IAC1B;EACJ,CAAC;EACD;EACAG,EAAE,GAAG,MAAME,eAAe,CAAC;IACvBU,WAAW,GAAG;MACVC,cAAc,EAAE;IACpB;IACAC,MAAM,GAAG,IAAIX,EAAE,EAAE;IACjBY,KAAK,CAACR,MAAM,EAAE;MACV,IAAI,IAAI,CAACO,MAAM,CAACN,OAAO,EACnB;MACJ;MACA,IAAI,CAACM,MAAM,CAACP,MAAM,GAAGA,MAAM;MAC3B;MACA,IAAI,CAACO,MAAM,CAACN,OAAO,GAAG,IAAI;MAC1B;MACA,KAAK,MAAMX,EAAE,IAAI,IAAI,CAACiB,MAAM,CAACR,QAAQ,EAAE;QACnCT,EAAE,CAACU,MAAM,CAAC;MACd;MACA,IAAI,CAACO,MAAM,CAACT,OAAO,GAAGE,MAAM,CAAC;IACjC;EACJ,CAAC;EACD,IAAIS,sBAAsB,GAAGzB,OAAO,CAAC0B,GAAG,EAAEC,2BAA2B,KAAK,GAAG;EAC7E,MAAML,cAAc,GAAG,MAAM;IACzB,IAAI,CAACG,sBAAsB,EACvB;IACJA,sBAAsB,GAAG,KAAK;IAC9BvB,WAAW,CAAC,wDAAwD,GAChE,qDAAqD,GACrD,yDAAyD,GACzD,6DAA6D,GAC7D,mEAAmE,GACnE,mEAAmE,GACnE,qEAAqE,EAAE,qBAAqB,EAAE,SAAS,EAAEoB,cAAc,CAAC;EAChI,CAAC;AACL;AACA;AACA,MAAMM,UAAU,GAAIvB,IAAI,IAAK,CAACP,MAAM,CAAC+B,GAAG,CAACxB,IAAI,CAAC;AAC9C,MAAMyB,IAAI,GAAGC,MAAM,CAAC,MAAM,CAAC;AAC3B,MAAMC,QAAQ,GAAIC,CAAC,IAAKA,CAAC,IAAIA,CAAC,KAAKC,IAAI,CAACC,KAAK,CAACF,CAAC,CAAC,IAAIA,CAAC,GAAG,CAAC,IAAIG,QAAQ,CAACH,CAAC,CAAC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMI,YAAY,GAAIC,GAAG,IAAK,CAACN,QAAQ,CAACM,GAAG,CAAC,GACtC,IAAI,GACJA,GAAG,IAAIJ,IAAI,CAACK,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,GACjBC,UAAU,GACVF,GAAG,IAAIJ,IAAI,CAACK,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAClBE,WAAW,GACXH,GAAG,IAAIJ,IAAI,CAACK,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAClBG,WAAW,GACXJ,GAAG,IAAIK,MAAM,CAACC,gBAAgB,GAC1BC,SAAS,GACT,IAAI;AAC1B;AACA,MAAMA,SAAS,SAASC,KAAK,CAAC;EAC1BzB,WAAW,CAAC0B,IAAI,EAAE;IACd,KAAK,CAACA,IAAI,CAAC;IACX,IAAI,CAACC,IAAI,CAAC,CAAC,CAAC;EAChB;AACJ;AACA,MAAMC,KAAK,CAAC;EACRC,IAAI;EACJC,MAAM;EACN;EACA,OAAO,CAACC,YAAY,GAAG,KAAK;EAC5B,OAAOC,MAAM,CAACf,GAAG,EAAE;IACf,MAAMgB,OAAO,GAAGjB,YAAY,CAACC,GAAG,CAAC;IACjC,IAAI,CAACgB,OAAO,EACR,OAAO,EAAE;IACbL,KAAK,CAAC,CAACG,YAAY,GAAG,IAAI;IAC1B,MAAMG,CAAC,GAAG,IAAIN,KAAK,CAACX,GAAG,EAAEgB,OAAO,CAAC;IACjCL,KAAK,CAAC,CAACG,YAAY,GAAG,KAAK;IAC3B,OAAOG,CAAC;EACZ;EACAlC,WAAW,CAACiB,GAAG,EAAEgB,OAAO,EAAE;IACtB;IACA,IAAI,CAACL,KAAK,CAAC,CAACG,YAAY,EAAE;MACtB,MAAM,IAAII,SAAS,CAAC,yCAAyC,CAAC;IAClE;IACA;IACA,IAAI,CAACN,IAAI,GAAG,IAAII,OAAO,CAAChB,GAAG,CAAC;IAC5B,IAAI,CAACa,MAAM,GAAG,CAAC;EACnB;EACA/B,IAAI,CAACa,CAAC,EAAE;IACJ,IAAI,CAACiB,IAAI,CAAC,IAAI,CAACC,MAAM,EAAE,CAAC,GAAGlB,CAAC;EAChC;EACAwB,GAAG,GAAG;IACF,OAAO,IAAI,CAACP,IAAI,CAAC,EAAE,IAAI,CAACC,MAAM,CAAC;EACnC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM1D,QAAQ,CAAC;EACX;EACA;EACA;EACA,CAAC6C,GAAG;EACJ,CAACoB,OAAO;EACR,CAACC,OAAO;EACR,CAACC,YAAY;EACb,CAACC,WAAW;EACZ;AACJ;AACA;EACIC,GAAG;EACH;AACJ;AACA;EACIC,aAAa;EACb;AACJ;AACA;EACIC,YAAY;EACZ;AACJ;AACA;EACIC,cAAc;EACd;AACJ;AACA;EACIC,cAAc;EACd;AACJ;AACA;EACIC,UAAU;EACV;AACJ;AACA;EACIC,cAAc;EACd;AACJ;AACA;EACIC,WAAW;EACX;AACJ;AACA;EACIC,YAAY;EACZ;AACJ;AACA;EACIC,eAAe;EACf;AACJ;AACA;EACIC,wBAAwB;EACxB;AACJ;AACA;EACIC,kBAAkB;EAClB;AACJ;AACA;EACIC,sBAAsB;EACtB;AACJ;AACA;EACIC,0BAA0B;EAC1B;AACJ;AACA;EACIC,gBAAgB;EAChB;EACA,CAAC7B,IAAI;EACL,CAAC8B,cAAc;EACf,CAACC,MAAM;EACP,CAACC,OAAO;EACR,CAACC,OAAO;EACR,CAACC,IAAI;EACL,CAACC,IAAI;EACL,CAACC,IAAI;EACL,CAACC,IAAI;EACL,CAACC,IAAI;EACL,CAACC,QAAQ;EACT,CAACC,KAAK;EACN,CAACC,MAAM;EACP,CAACC,IAAI;EACL,CAACC,UAAU;EACX,CAACC,cAAc;EACf,CAACC,eAAe;EAChB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOC,qBAAqB,CAACC,CAAC,EAAE;IAC5B,OAAO;MACH;MACAN,MAAM,EAAEM,CAAC,CAAC,CAACN,MAAM;MACjBC,IAAI,EAAEK,CAAC,CAAC,CAACL,IAAI;MACbF,KAAK,EAAEO,CAAC,CAAC,CAACP,KAAK;MACfT,MAAM,EAAEgB,CAAC,CAAC,CAAChB,MAAM;MACjBC,OAAO,EAAEe,CAAC,CAAC,CAACf,OAAO;MACnBC,OAAO,EAAEc,CAAC,CAAC,CAACd,OAAO;MACnBC,IAAI,EAAEa,CAAC,CAAC,CAACb,IAAI;MACbC,IAAI,EAAEY,CAAC,CAAC,CAACZ,IAAI;MACb,IAAIC,IAAI,GAAG;QACP,OAAOW,CAAC,CAAC,CAACX,IAAI;MAClB,CAAC;MACD,IAAIC,IAAI,GAAG;QACP,OAAOU,CAAC,CAAC,CAACV,IAAI;MAClB,CAAC;MACDC,IAAI,EAAES,CAAC,CAAC,CAACT,IAAI;MACb;MACAU,iBAAiB,EAAGC,CAAC,IAAKF,CAAC,CAAC,CAACC,iBAAiB,CAACC,CAAC,CAAC;MACjDC,eAAe,EAAE,CAACC,CAAC,EAAEC,KAAK,EAAEC,OAAO,EAAEC,OAAO,KAAKP,CAAC,CAAC,CAACG,eAAe,CAACC,CAAC,EAAEC,KAAK,EAAEC,OAAO,EAAEC,OAAO,CAAC;MAC/FC,UAAU,EAAGH,KAAK,IAAKL,CAAC,CAAC,CAACQ,UAAU,CAACH,KAAK,CAAC;MAC3CI,OAAO,EAAGH,OAAO,IAAKN,CAAC,CAAC,CAACS,OAAO,CAACH,OAAO,CAAC;MACzCI,QAAQ,EAAGJ,OAAO,IAAKN,CAAC,CAAC,CAACU,QAAQ,CAACJ,OAAO,CAAC;MAC3CK,OAAO,EAAGN,KAAK,IAAKL,CAAC,CAAC,CAACW,OAAO,CAACN,KAAK;IACxC,CAAC;EACL;EACA;EACA;AACJ;AACA;EACI,IAAI7D,GAAG,GAAG;IACN,OAAO,IAAI,CAAC,CAACA,GAAG;EACpB;EACA;AACJ;AACA;EACI,IAAIoB,OAAO,GAAG;IACV,OAAO,IAAI,CAAC,CAACA,OAAO;EACxB;EACA;AACJ;AACA;EACI,IAAImB,cAAc,GAAG;IACjB,OAAO,IAAI,CAAC,CAACA,cAAc;EAC/B;EACA;AACJ;AACA;EACI,IAAI9B,IAAI,GAAG;IACP,OAAO,IAAI,CAAC,CAACA,IAAI;EACrB;EACA;AACJ;AACA;EACI,IAAIc,WAAW,GAAG;IACd,OAAO,IAAI,CAAC,CAACA,WAAW;EAC5B;EACA;AACJ;AACA;EACI,IAAIF,OAAO,GAAG;IACV,OAAO,IAAI,CAAC,CAACA,OAAO;EACxB;EACA;AACJ;AACA;EACI,IAAIC,YAAY,GAAG;IACf,OAAO,IAAI,CAAC,CAACA,YAAY;EAC7B;EACAvC,WAAW,CAAC+E,OAAO,EAAE;IACjB,MAAM;MAAE9D,GAAG,GAAG,CAAC;MAAEwB,GAAG;MAAEC,aAAa,GAAG,CAAC;MAAEC,YAAY;MAAEC,cAAc;MAAEC,cAAc;MAAEC,UAAU;MAAER,OAAO;MAAEC,YAAY;MAAEQ,cAAc;MAAEC,WAAW;MAAEX,OAAO,GAAG,CAAC;MAAEY,YAAY,GAAG,CAAC;MAAEC,eAAe;MAAEV,WAAW;MAAEW,wBAAwB;MAAEC,kBAAkB;MAAEE,0BAA0B;MAAED,sBAAsB;MAAEE;IAAkB,CAAC,GAAGwB,OAAO;IACnV,IAAI9D,GAAG,KAAK,CAAC,IAAI,CAACN,QAAQ,CAACM,GAAG,CAAC,EAAE;MAC7B,MAAM,IAAIkB,SAAS,CAAC,0CAA0C,CAAC;IACnE;IACA,MAAMkD,SAAS,GAAGpE,GAAG,GAAGD,YAAY,CAACC,GAAG,CAAC,GAAGQ,KAAK;IACjD,IAAI,CAAC4D,SAAS,EAAE;MACZ,MAAM,IAAIC,KAAK,CAAC,qBAAqB,GAAGrE,GAAG,CAAC;IAChD;IACA,IAAI,CAAC,CAACA,GAAG,GAAGA,GAAG;IACf,IAAI,CAAC,CAACoB,OAAO,GAAGA,OAAO;IACvB,IAAI,CAACY,YAAY,GAAGA,YAAY,IAAI,IAAI,CAAC,CAACZ,OAAO;IACjD,IAAI,CAACa,eAAe,GAAGA,eAAe;IACtC,IAAI,IAAI,CAACA,eAAe,EAAE;MACtB,IAAI,CAAC,IAAI,CAAC,CAACb,OAAO,IAAI,CAAC,IAAI,CAACY,YAAY,EAAE;QACtC,MAAM,IAAId,SAAS,CAAC,oEAAoE,CAAC;MAC7F;MACA,IAAI,OAAO,IAAI,CAACe,eAAe,KAAK,UAAU,EAAE;QAC5C,MAAM,IAAIf,SAAS,CAAC,qCAAqC,CAAC;MAC9D;IACJ;IACA,IAAIK,WAAW,KAAK+C,SAAS,IACzB,OAAO/C,WAAW,KAAK,UAAU,EAAE;MACnC,MAAM,IAAIL,SAAS,CAAC,6CAA6C,CAAC;IACtE;IACA,IAAI,CAAC,CAACK,WAAW,GAAGA,WAAW;IAC/B,IAAI,CAAC,CAAC8B,cAAc,GAAG,CAAC,CAAC9B,WAAW;IACpC,IAAI,CAAC,CAACiB,MAAM,GAAG,IAAI+B,GAAG,EAAE;IACxB,IAAI,CAAC,CAAC9B,OAAO,GAAG,IAAIjC,KAAK,CAACR,GAAG,CAAC,CAACU,IAAI,CAAC4D,SAAS,CAAC;IAC9C,IAAI,CAAC,CAAC5B,OAAO,GAAG,IAAIlC,KAAK,CAACR,GAAG,CAAC,CAACU,IAAI,CAAC4D,SAAS,CAAC;IAC9C,IAAI,CAAC,CAAC3B,IAAI,GAAG,IAAIyB,SAAS,CAACpE,GAAG,CAAC;IAC/B,IAAI,CAAC,CAAC4C,IAAI,GAAG,IAAIwB,SAAS,CAACpE,GAAG,CAAC;IAC/B,IAAI,CAAC,CAAC6C,IAAI,GAAG,CAAC;IACd,IAAI,CAAC,CAACC,IAAI,GAAG,CAAC;IACd,IAAI,CAAC,CAACC,IAAI,GAAGpC,KAAK,CAACI,MAAM,CAACf,GAAG,CAAC;IAC9B,IAAI,CAAC,CAACS,IAAI,GAAG,CAAC;IACd,IAAI,CAAC,CAAC8B,cAAc,GAAG,CAAC;IACxB,IAAI,OAAOlB,OAAO,KAAK,UAAU,EAAE;MAC/B,IAAI,CAAC,CAACA,OAAO,GAAGA,OAAO;IAC3B;IACA,IAAI,OAAOC,YAAY,KAAK,UAAU,EAAE;MACpC,IAAI,CAAC,CAACA,YAAY,GAAGA,YAAY;MACjC,IAAI,CAAC,CAAC0B,QAAQ,GAAG,EAAE;IACvB,CAAC,MACI;MACD,IAAI,CAAC,CAAC1B,YAAY,GAAGgD,SAAS;MAC9B,IAAI,CAAC,CAACtB,QAAQ,GAAGsB,SAAS;IAC9B;IACA,IAAI,CAAC,CAAClB,UAAU,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC/B,OAAO;IAClC,IAAI,CAAC,CAACiC,eAAe,GAAG,CAAC,CAAC,IAAI,CAAC,CAAChC,YAAY;IAC5C,IAAI,CAACQ,cAAc,GAAG,CAAC,CAACA,cAAc;IACtC,IAAI,CAACC,WAAW,GAAG,CAAC,CAACA,WAAW;IAChC,IAAI,CAACG,wBAAwB,GAAG,CAAC,CAACA,wBAAwB;IAC1D,IAAI,CAACG,0BAA0B,GAAG,CAAC,CAACA,0BAA0B;IAC9D,IAAI,CAACD,sBAAsB,GAAG,CAAC,CAACA,sBAAsB;IACtD,IAAI,CAACE,gBAAgB,GAAG,CAAC,CAACA,gBAAgB;IAC1C;IACA,IAAI,IAAI,CAACN,YAAY,KAAK,CAAC,EAAE;MACzB,IAAI,IAAI,CAAC,CAACZ,OAAO,KAAK,CAAC,EAAE;QACrB,IAAI,CAAC1B,QAAQ,CAAC,IAAI,CAAC,CAAC0B,OAAO,CAAC,EAAE;UAC1B,MAAM,IAAIF,SAAS,CAAC,iDAAiD,CAAC;QAC1E;MACJ;MACA,IAAI,CAACxB,QAAQ,CAAC,IAAI,CAACsC,YAAY,CAAC,EAAE;QAC9B,MAAM,IAAId,SAAS,CAAC,sDAAsD,CAAC;MAC/E;MACA,IAAI,CAAC,CAACsD,sBAAsB,EAAE;IAClC;IACA,IAAI,CAAC3C,UAAU,GAAG,CAAC,CAACA,UAAU;IAC9B,IAAI,CAACM,kBAAkB,GAAG,CAAC,CAACA,kBAAkB;IAC9C,IAAI,CAACR,cAAc,GAAG,CAAC,CAACA,cAAc;IACtC,IAAI,CAACC,cAAc,GAAG,CAAC,CAACA,cAAc;IACtC,IAAI,CAACH,aAAa,GACd/B,QAAQ,CAAC+B,aAAa,CAAC,IAAIA,aAAa,KAAK,CAAC,GACxCA,aAAa,GACb,CAAC;IACX,IAAI,CAACC,YAAY,GAAG,CAAC,CAACA,YAAY;IAClC,IAAI,CAACF,GAAG,GAAGA,GAAG,IAAI,CAAC;IACnB,IAAI,IAAI,CAACA,GAAG,EAAE;MACV,IAAI,CAAC9B,QAAQ,CAAC,IAAI,CAAC8B,GAAG,CAAC,EAAE;QACrB,MAAM,IAAIN,SAAS,CAAC,6CAA6C,CAAC;MACtE;MACA,IAAI,CAAC,CAACuD,qBAAqB,EAAE;IACjC;IACA;IACA,IAAI,IAAI,CAAC,CAACzE,GAAG,KAAK,CAAC,IAAI,IAAI,CAACwB,GAAG,KAAK,CAAC,IAAI,IAAI,CAAC,CAACJ,OAAO,KAAK,CAAC,EAAE;MAC1D,MAAM,IAAIF,SAAS,CAAC,kDAAkD,CAAC;IAC3E;IACA,IAAI,CAAC,IAAI,CAACQ,YAAY,IAAI,CAAC,IAAI,CAAC,CAAC1B,GAAG,IAAI,CAAC,IAAI,CAAC,CAACoB,OAAO,EAAE;MACpD,MAAMrD,IAAI,GAAG,qBAAqB;MAClC,IAAIuB,UAAU,CAACvB,IAAI,CAAC,EAAE;QAClBP,MAAM,CAACkH,GAAG,CAAC3G,IAAI,CAAC;QAChB,MAAMF,GAAG,GAAG,wDAAwD,GAChE,yCAAyC;QAC7CD,WAAW,CAACC,GAAG,EAAE,uBAAuB,EAAEE,IAAI,EAAEZ,QAAQ,CAAC;MAC7D;IACJ;EACJ;EACA;AACJ;AACA;EACIwH,eAAe,CAACC,GAAG,EAAE;IACjB,OAAO,IAAI,CAAC,CAACpC,MAAM,CAACjD,GAAG,CAACqF,GAAG,CAAC,GAAGC,QAAQ,GAAG,CAAC;EAC/C;EACA,CAACJ,qBAAqB,GAAG;IACrB,MAAMtB,IAAI,GAAG,IAAI5C,SAAS,CAAC,IAAI,CAAC,CAACP,GAAG,CAAC;IACrC,MAAMkD,MAAM,GAAG,IAAI3C,SAAS,CAAC,IAAI,CAAC,CAACP,GAAG,CAAC;IACvC,IAAI,CAAC,CAACmD,IAAI,GAAGA,IAAI;IACjB,IAAI,CAAC,CAACD,MAAM,GAAGA,MAAM;IACrB,IAAI,CAAC,CAAC4B,UAAU,GAAG,CAACjB,KAAK,EAAErC,GAAG,EAAEuD,KAAK,GAAG3H,IAAI,CAACE,GAAG,EAAE,KAAK;MACnD4F,MAAM,CAACW,KAAK,CAAC,GAAGrC,GAAG,KAAK,CAAC,GAAGuD,KAAK,GAAG,CAAC;MACrC5B,IAAI,CAACU,KAAK,CAAC,GAAGrC,GAAG;MACjB,IAAIA,GAAG,KAAK,CAAC,IAAI,IAAI,CAACE,YAAY,EAAE;QAChC,MAAMsD,CAAC,GAAGC,UAAU,CAAC,MAAM;UACvB,IAAI,IAAI,CAAC,CAACd,OAAO,CAACN,KAAK,CAAC,EAAE;YACtB,IAAI,CAACqB,MAAM,CAAC,IAAI,CAAC,CAACzC,OAAO,CAACoB,KAAK,CAAC,CAAC;UACrC;QACJ,CAAC,EAAErC,GAAG,GAAG,CAAC,CAAC;QACX;QACA;QACA,IAAIwD,CAAC,CAACG,KAAK,EAAE;UACTH,CAAC,CAACG,KAAK,EAAE;QACb;QACA;MACJ;IACJ,CAAC;;IACD,IAAI,CAAC,CAACC,aAAa,GAAGvB,KAAK,IAAI;MAC3BX,MAAM,CAACW,KAAK,CAAC,GAAGV,IAAI,CAACU,KAAK,CAAC,KAAK,CAAC,GAAGzG,IAAI,CAACE,GAAG,EAAE,GAAG,CAAC;IACtD,CAAC;IACD,IAAI,CAAC,CAAC+H,SAAS,GAAG,CAACC,MAAM,EAAEzB,KAAK,KAAK;MACjC,IAAIV,IAAI,CAACU,KAAK,CAAC,EAAE;QACb,MAAMrC,GAAG,GAAG2B,IAAI,CAACU,KAAK,CAAC;QACvB,MAAMkB,KAAK,GAAG7B,MAAM,CAACW,KAAK,CAAC;QAC3B;QACA,IAAI,CAACrC,GAAG,IAAI,CAACuD,KAAK,EACd;QACJO,MAAM,CAAC9D,GAAG,GAAGA,GAAG;QAChB8D,MAAM,CAACP,KAAK,GAAGA,KAAK;QACpBO,MAAM,CAAChI,GAAG,GAAGiI,SAAS,IAAIC,MAAM,EAAE;QAClC,MAAMC,GAAG,GAAGH,MAAM,CAAChI,GAAG,GAAGyH,KAAK;QAC9BO,MAAM,CAACI,YAAY,GAAGlE,GAAG,GAAGiE,GAAG;MACnC;IACJ,CAAC;IACD;IACA;IACA,IAAIF,SAAS,GAAG,CAAC;IACjB,MAAMC,MAAM,GAAG,MAAM;MACjB,MAAM7F,CAAC,GAAGvC,IAAI,CAACE,GAAG,EAAE;MACpB,IAAI,IAAI,CAACmE,aAAa,GAAG,CAAC,EAAE;QACxB8D,SAAS,GAAG5F,CAAC;QACb,MAAMqF,CAAC,GAAGC,UAAU,CAAC,MAAOM,SAAS,GAAG,CAAE,EAAE,IAAI,CAAC9D,aAAa,CAAC;QAC/D;QACA;QACA,IAAIuD,CAAC,CAACG,KAAK,EAAE;UACTH,CAAC,CAACG,KAAK,EAAE;QACb;QACA;MACJ;;MACA,OAAOxF,CAAC;IACZ,CAAC;IACD,IAAI,CAACgF,eAAe,GAAGC,GAAG,IAAI;MAC1B,MAAMf,KAAK,GAAG,IAAI,CAAC,CAACrB,MAAM,CAACmD,GAAG,CAACf,GAAG,CAAC;MACnC,IAAIf,KAAK,KAAKS,SAAS,EAAE;QACrB,OAAO,CAAC;MACZ;MACA,MAAM9C,GAAG,GAAG2B,IAAI,CAACU,KAAK,CAAC;MACvB,MAAMkB,KAAK,GAAG7B,MAAM,CAACW,KAAK,CAAC;MAC3B,IAAI,CAACrC,GAAG,IAAI,CAACuD,KAAK,EAAE;QAChB,OAAOF,QAAQ;MACnB;MACA,MAAMY,GAAG,GAAG,CAACF,SAAS,IAAIC,MAAM,EAAE,IAAIT,KAAK;MAC3C,OAAOvD,GAAG,GAAGiE,GAAG;IACpB,CAAC;IACD,IAAI,CAAC,CAACtB,OAAO,GAAGN,KAAK,IAAI;MACrB,MAAM5C,CAAC,GAAGiC,MAAM,CAACW,KAAK,CAAC;MACvB,MAAMmB,CAAC,GAAG7B,IAAI,CAACU,KAAK,CAAC;MACrB,OAAO,CAAC,CAACmB,CAAC,IAAI,CAAC,CAAC/D,CAAC,IAAI,CAACsE,SAAS,IAAIC,MAAM,EAAE,IAAIvE,CAAC,GAAG+D,CAAC;IACxD,CAAC;EACL;EACA;EACA,CAACI,aAAa,GAAG,MAAM,CAAE,CAAC;EAC1B,CAACC,SAAS,GAAG,MAAM,CAAE,CAAC;EACtB,CAACP,UAAU,GAAG,MAAM,CAAE,CAAC;EACvB;EACA,CAACX,OAAO,GAAG,MAAM,KAAK;EACtB,CAACK,sBAAsB,GAAG;IACtB,MAAMvB,KAAK,GAAG,IAAI1C,SAAS,CAAC,IAAI,CAAC,CAACP,GAAG,CAAC;IACtC,IAAI,CAAC,CAACuC,cAAc,GAAG,CAAC;IACxB,IAAI,CAAC,CAACU,KAAK,GAAGA,KAAK;IACnB,IAAI,CAAC,CAAC2C,cAAc,GAAG/B,KAAK,IAAI;MAC5B,IAAI,CAAC,CAACtB,cAAc,IAAIU,KAAK,CAACY,KAAK,CAAC;MACpCZ,KAAK,CAACY,KAAK,CAAC,GAAG,CAAC;IACpB,CAAC;IACD,IAAI,CAAC,CAACgC,WAAW,GAAG,CAACjC,CAAC,EAAEkC,CAAC,EAAErF,IAAI,EAAEwB,eAAe,KAAK;MACjD;MACA;MACA,IAAI,IAAI,CAAC,CAACwB,iBAAiB,CAACqC,CAAC,CAAC,EAAE;QAC5B,OAAO,CAAC;MACZ;MACA,IAAI,CAACpG,QAAQ,CAACe,IAAI,CAAC,EAAE;QACjB,IAAIwB,eAAe,EAAE;UACjB,IAAI,OAAOA,eAAe,KAAK,UAAU,EAAE;YACvC,MAAM,IAAIf,SAAS,CAAC,oCAAoC,CAAC;UAC7D;UACAT,IAAI,GAAGwB,eAAe,CAAC6D,CAAC,EAAElC,CAAC,CAAC;UAC5B,IAAI,CAAClE,QAAQ,CAACe,IAAI,CAAC,EAAE;YACjB,MAAM,IAAIS,SAAS,CAAC,0DAA0D,CAAC;UACnF;QACJ,CAAC,MACI;UACD,MAAM,IAAIA,SAAS,CAAC,iDAAiD,GACjE,wDAAwD,GACxD,sBAAsB,CAAC;QAC/B;MACJ;MACA,OAAOT,IAAI;IACf,CAAC;IACD,IAAI,CAAC,CAACsF,WAAW,GAAG,CAAClC,KAAK,EAAEpD,IAAI,EAAE6E,MAAM,KAAK;MACzCrC,KAAK,CAACY,KAAK,CAAC,GAAGpD,IAAI;MACnB,IAAI,IAAI,CAAC,CAACW,OAAO,EAAE;QACf,MAAMA,OAAO,GAAG,IAAI,CAAC,CAACA,OAAO,GAAG6B,KAAK,CAACY,KAAK,CAAC;QAC5C,OAAO,IAAI,CAAC,CAACtB,cAAc,GAAGnB,OAAO,EAAE;UACnC,IAAI,CAAC,CAAC4E,KAAK,CAAC,IAAI,CAAC;QACrB;MACJ;MACA,IAAI,CAAC,CAACzD,cAAc,IAAIU,KAAK,CAACY,KAAK,CAAC;MACpC,IAAIyB,MAAM,EAAE;QACRA,MAAM,CAACW,SAAS,GAAGxF,IAAI;QACvB6E,MAAM,CAACY,mBAAmB,GAAG,IAAI,CAAC,CAAC3D,cAAc;MACrD;IACJ,CAAC;EACL;EACA,CAACqD,cAAc,GAAGO,EAAE,IAAI,CAAE,CAAC;EAC3B,CAACJ,WAAW,GAAG,CAACI,EAAE,EAAEC,EAAE,EAAEC,GAAG,KAAK,CAAE,CAAC;EACnC,CAACR,WAAW,GAAG,CAACS,EAAE,EAAEC,EAAE,EAAE9F,IAAI,EAAEwB,eAAe,KAAK;IAC9C,IAAIxB,IAAI,IAAIwB,eAAe,EAAE;MACzB,MAAM,IAAIf,SAAS,CAAC,kEAAkE,CAAC;IAC3F;IACA,OAAO,CAAC;EACZ,CAAC;EACD,CAAC,CAAC+C,OAAO,CAAC;IAAEpC,UAAU,GAAG,IAAI,CAACA;EAAW,CAAC,GAAG,CAAC,CAAC,EAAE;IAC7C,IAAI,IAAI,CAAC,CAACpB,IAAI,EAAE;MACZ,KAAK,IAAI+F,CAAC,GAAG,IAAI,CAAC,CAAC1D,IAAI,EAAE,IAAI,GAAG;QAC5B,IAAI,CAAC,IAAI,CAAC,CAAC2D,YAAY,CAACD,CAAC,CAAC,EAAE;UACxB;QACJ;QACA,IAAI3E,UAAU,IAAI,CAAC,IAAI,CAAC,CAACsC,OAAO,CAACqC,CAAC,CAAC,EAAE;UACjC,MAAMA,CAAC;QACX;QACA,IAAIA,CAAC,KAAK,IAAI,CAAC,CAAC3D,IAAI,EAAE;UAClB;QACJ,CAAC,MACI;UACD2D,CAAC,GAAG,IAAI,CAAC,CAAC5D,IAAI,CAAC4D,CAAC,CAAC;QACrB;MACJ;IACJ;EACJ;EACA,CAAC,CAACtC,QAAQ,CAAC;IAAErC,UAAU,GAAG,IAAI,CAACA;EAAW,CAAC,GAAG,CAAC,CAAC,EAAE;IAC9C,IAAI,IAAI,CAAC,CAACpB,IAAI,EAAE;MACZ,KAAK,IAAI+F,CAAC,GAAG,IAAI,CAAC,CAAC3D,IAAI,EAAE,IAAI,GAAG;QAC5B,IAAI,CAAC,IAAI,CAAC,CAAC4D,YAAY,CAACD,CAAC,CAAC,EAAE;UACxB;QACJ;QACA,IAAI3E,UAAU,IAAI,CAAC,IAAI,CAAC,CAACsC,OAAO,CAACqC,CAAC,CAAC,EAAE;UACjC,MAAMA,CAAC;QACX;QACA,IAAIA,CAAC,KAAK,IAAI,CAAC,CAAC1D,IAAI,EAAE;UAClB;QACJ,CAAC,MACI;UACD0D,CAAC,GAAG,IAAI,CAAC,CAAC7D,IAAI,CAAC6D,CAAC,CAAC;QACrB;MACJ;IACJ;EACJ;EACA,CAACC,YAAY,CAAC5C,KAAK,EAAE;IACjB,OAAQA,KAAK,KAAKS,SAAS,IACvB,IAAI,CAAC,CAAC9B,MAAM,CAACmD,GAAG,CAAC,IAAI,CAAC,CAAClD,OAAO,CAACoB,KAAK,CAAC,CAAC,KAAKA,KAAK;EACxD;EACA;AACJ;AACA;AACA;EACI,CAAC6C,OAAO,GAAG;IACP,KAAK,MAAMF,CAAC,IAAI,IAAI,CAAC,CAACvC,OAAO,EAAE,EAAE;MAC7B,IAAI,IAAI,CAAC,CAACvB,OAAO,CAAC8D,CAAC,CAAC,KAAKlC,SAAS,IAC9B,IAAI,CAAC,CAAC7B,OAAO,CAAC+D,CAAC,CAAC,KAAKlC,SAAS,IAC9B,CAAC,IAAI,CAAC,CAACb,iBAAiB,CAAC,IAAI,CAAC,CAACf,OAAO,CAAC8D,CAAC,CAAC,CAAC,EAAE;QAC5C,MAAM,CAAC,IAAI,CAAC,CAAC/D,OAAO,CAAC+D,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC9D,OAAO,CAAC8D,CAAC,CAAC,CAAC;MAC9C;IACJ;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,CAACG,QAAQ,GAAG;IACR,KAAK,MAAMH,CAAC,IAAI,IAAI,CAAC,CAACtC,QAAQ,EAAE,EAAE;MAC9B,IAAI,IAAI,CAAC,CAACxB,OAAO,CAAC8D,CAAC,CAAC,KAAKlC,SAAS,IAC9B,IAAI,CAAC,CAAC7B,OAAO,CAAC+D,CAAC,CAAC,KAAKlC,SAAS,IAC9B,CAAC,IAAI,CAAC,CAACb,iBAAiB,CAAC,IAAI,CAAC,CAACf,OAAO,CAAC8D,CAAC,CAAC,CAAC,EAAE;QAC5C,MAAM,CAAC,IAAI,CAAC,CAAC/D,OAAO,CAAC+D,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC9D,OAAO,CAAC8D,CAAC,CAAC,CAAC;MAC9C;IACJ;EACJ;EACA;AACJ;AACA;AACA;EACI,CAACI,IAAI,GAAG;IACJ,KAAK,MAAMJ,CAAC,IAAI,IAAI,CAAC,CAACvC,OAAO,EAAE,EAAE;MAC7B,MAAML,CAAC,GAAG,IAAI,CAAC,CAACnB,OAAO,CAAC+D,CAAC,CAAC;MAC1B,IAAI5C,CAAC,KAAKU,SAAS,IACf,CAAC,IAAI,CAAC,CAACb,iBAAiB,CAAC,IAAI,CAAC,CAACf,OAAO,CAAC8D,CAAC,CAAC,CAAC,EAAE;QAC5C,MAAM5C,CAAC;MACX;IACJ;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,CAACiD,KAAK,GAAG;IACL,KAAK,MAAML,CAAC,IAAI,IAAI,CAAC,CAACtC,QAAQ,EAAE,EAAE;MAC9B,MAAMN,CAAC,GAAG,IAAI,CAAC,CAACnB,OAAO,CAAC+D,CAAC,CAAC;MAC1B,IAAI5C,CAAC,KAAKU,SAAS,IACf,CAAC,IAAI,CAAC,CAACb,iBAAiB,CAAC,IAAI,CAAC,CAACf,OAAO,CAAC8D,CAAC,CAAC,CAAC,EAAE;QAC5C,MAAM5C,CAAC;MACX;IACJ;EACJ;EACA;AACJ;AACA;AACA;EACI,CAACkD,MAAM,GAAG;IACN,KAAK,MAAMN,CAAC,IAAI,IAAI,CAAC,CAACvC,OAAO,EAAE,EAAE;MAC7B,MAAM6B,CAAC,GAAG,IAAI,CAAC,CAACpD,OAAO,CAAC8D,CAAC,CAAC;MAC1B,IAAIV,CAAC,KAAKxB,SAAS,IACf,CAAC,IAAI,CAAC,CAACb,iBAAiB,CAAC,IAAI,CAAC,CAACf,OAAO,CAAC8D,CAAC,CAAC,CAAC,EAAE;QAC5C,MAAM,IAAI,CAAC,CAAC9D,OAAO,CAAC8D,CAAC,CAAC;MAC1B;IACJ;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,CAACO,OAAO,GAAG;IACP,KAAK,MAAMP,CAAC,IAAI,IAAI,CAAC,CAACtC,QAAQ,EAAE,EAAE;MAC9B,MAAM4B,CAAC,GAAG,IAAI,CAAC,CAACpD,OAAO,CAAC8D,CAAC,CAAC;MAC1B,IAAIV,CAAC,KAAKxB,SAAS,IACf,CAAC,IAAI,CAAC,CAACb,iBAAiB,CAAC,IAAI,CAAC,CAACf,OAAO,CAAC8D,CAAC,CAAC,CAAC,EAAE;QAC5C,MAAM,IAAI,CAAC,CAAC9D,OAAO,CAAC8D,CAAC,CAAC;MAC1B;IACJ;EACJ;EACA;AACJ;AACA;AACA;EACI,CAAC/G,MAAM,CAACuH,QAAQ,IAAI;IAChB,OAAO,IAAI,CAACN,OAAO,EAAE;EACzB;EACA;AACJ;AACA;AACA;EACIO,IAAI,CAACjJ,EAAE,EAAEkJ,UAAU,GAAG,CAAC,CAAC,EAAE;IACtB,KAAK,MAAMV,CAAC,IAAI,IAAI,CAAC,CAACvC,OAAO,EAAE,EAAE;MAC7B,MAAM6B,CAAC,GAAG,IAAI,CAAC,CAACpD,OAAO,CAAC8D,CAAC,CAAC;MAC1B,MAAMtJ,KAAK,GAAG,IAAI,CAAC,CAACuG,iBAAiB,CAACqC,CAAC,CAAC,GAClCA,CAAC,CAACqB,oBAAoB,GACtBrB,CAAC;MACP,IAAI5I,KAAK,KAAKoH,SAAS,EACnB;MACJ,IAAItG,EAAE,CAACd,KAAK,EAAE,IAAI,CAAC,CAACuF,OAAO,CAAC+D,CAAC,CAAC,EAAE,IAAI,CAAC,EAAE;QACnC,OAAO,IAAI,CAACb,GAAG,CAAC,IAAI,CAAC,CAAClD,OAAO,CAAC+D,CAAC,CAAC,EAAEU,UAAU,CAAC;MACjD;IACJ;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;EACIE,OAAO,CAACpJ,EAAE,EAAEqJ,KAAK,GAAG,IAAI,EAAE;IACtB,KAAK,MAAMb,CAAC,IAAI,IAAI,CAAC,CAACvC,OAAO,EAAE,EAAE;MAC7B,MAAM6B,CAAC,GAAG,IAAI,CAAC,CAACpD,OAAO,CAAC8D,CAAC,CAAC;MAC1B,MAAMtJ,KAAK,GAAG,IAAI,CAAC,CAACuG,iBAAiB,CAACqC,CAAC,CAAC,GAClCA,CAAC,CAACqB,oBAAoB,GACtBrB,CAAC;MACP,IAAI5I,KAAK,KAAKoH,SAAS,EACnB;MACJtG,EAAE,CAACsJ,IAAI,CAACD,KAAK,EAAEnK,KAAK,EAAE,IAAI,CAAC,CAACuF,OAAO,CAAC+D,CAAC,CAAC,EAAE,IAAI,CAAC;IACjD;EACJ;EACA;AACJ;AACA;AACA;EACIe,QAAQ,CAACvJ,EAAE,EAAEqJ,KAAK,GAAG,IAAI,EAAE;IACvB,KAAK,MAAMb,CAAC,IAAI,IAAI,CAAC,CAACtC,QAAQ,EAAE,EAAE;MAC9B,MAAM4B,CAAC,GAAG,IAAI,CAAC,CAACpD,OAAO,CAAC8D,CAAC,CAAC;MAC1B,MAAMtJ,KAAK,GAAG,IAAI,CAAC,CAACuG,iBAAiB,CAACqC,CAAC,CAAC,GAClCA,CAAC,CAACqB,oBAAoB,GACtBrB,CAAC;MACP,IAAI5I,KAAK,KAAKoH,SAAS,EACnB;MACJtG,EAAE,CAACsJ,IAAI,CAACD,KAAK,EAAEnK,KAAK,EAAE,IAAI,CAAC,CAACuF,OAAO,CAAC+D,CAAC,CAAC,EAAE,IAAI,CAAC;IACjD;EACJ;EACA;AACJ;AACA;AACA;EACIgB,UAAU,GAAG;IACT,IAAIC,OAAO,GAAG,KAAK;IACnB,KAAK,MAAMjB,CAAC,IAAI,IAAI,CAAC,CAACtC,QAAQ,CAAC;MAAErC,UAAU,EAAE;IAAK,CAAC,CAAC,EAAE;MAClD,IAAI,IAAI,CAAC,CAACsC,OAAO,CAACqC,CAAC,CAAC,EAAE;QAClB,IAAI,CAACtB,MAAM,CAAC,IAAI,CAAC,CAACzC,OAAO,CAAC+D,CAAC,CAAC,CAAC;QAC7BiB,OAAO,GAAG,IAAI;MAClB;IACJ;IACA,OAAOA,OAAO;EAClB;EACA;AACJ;AACA;AACA;AACA;AACA;EACIC,IAAI,CAAC9C,GAAG,EAAE;IACN,MAAM4B,CAAC,GAAG,IAAI,CAAC,CAAChE,MAAM,CAACmD,GAAG,CAACf,GAAG,CAAC;IAC/B,IAAI4B,CAAC,KAAKlC,SAAS,EACf,OAAOA,SAAS;IACpB,MAAMwB,CAAC,GAAG,IAAI,CAAC,CAACpD,OAAO,CAAC8D,CAAC,CAAC;IAC1B,MAAMtJ,KAAK,GAAG,IAAI,CAAC,CAACuG,iBAAiB,CAACqC,CAAC,CAAC,GAClCA,CAAC,CAACqB,oBAAoB,GACtBrB,CAAC;IACP,IAAI5I,KAAK,KAAKoH,SAAS,EACnB,OAAOA,SAAS;IACpB,MAAMqD,KAAK,GAAG;MAAEzK;IAAM,CAAC;IACvB,IAAI,IAAI,CAAC,CAACiG,IAAI,IAAI,IAAI,CAAC,CAACD,MAAM,EAAE;MAC5B,MAAM1B,GAAG,GAAG,IAAI,CAAC,CAAC2B,IAAI,CAACqD,CAAC,CAAC;MACzB,MAAMzB,KAAK,GAAG,IAAI,CAAC,CAAC7B,MAAM,CAACsD,CAAC,CAAC;MAC7B,IAAIhF,GAAG,IAAIuD,KAAK,EAAE;QACd,MAAM6C,MAAM,GAAGpG,GAAG,IAAIpE,IAAI,CAACE,GAAG,EAAE,GAAGyH,KAAK,CAAC;QACzC4C,KAAK,CAACnG,GAAG,GAAGoG,MAAM;QAClBD,KAAK,CAAC5C,KAAK,GAAGxH,IAAI,CAACD,GAAG,EAAE;MAC5B;IACJ;IACA,IAAI,IAAI,CAAC,CAAC2F,KAAK,EAAE;MACb0E,KAAK,CAAClH,IAAI,GAAG,IAAI,CAAC,CAACwC,KAAK,CAACuD,CAAC,CAAC;IAC/B;IACA,OAAOmB,KAAK;EAChB;EACA;AACJ;AACA;AACA;EACIE,IAAI,GAAG;IACH,MAAMC,GAAG,GAAG,EAAE;IACd,KAAK,MAAMtB,CAAC,IAAI,IAAI,CAAC,CAACvC,OAAO,CAAC;MAAEpC,UAAU,EAAE;IAAK,CAAC,CAAC,EAAE;MACjD,MAAM+C,GAAG,GAAG,IAAI,CAAC,CAACnC,OAAO,CAAC+D,CAAC,CAAC;MAC5B,MAAMV,CAAC,GAAG,IAAI,CAAC,CAACpD,OAAO,CAAC8D,CAAC,CAAC;MAC1B,MAAMtJ,KAAK,GAAG,IAAI,CAAC,CAACuG,iBAAiB,CAACqC,CAAC,CAAC,GAClCA,CAAC,CAACqB,oBAAoB,GACtBrB,CAAC;MACP,IAAI5I,KAAK,KAAKoH,SAAS,IAAIM,GAAG,KAAKN,SAAS,EACxC;MACJ,MAAMqD,KAAK,GAAG;QAAEzK;MAAM,CAAC;MACvB,IAAI,IAAI,CAAC,CAACiG,IAAI,IAAI,IAAI,CAAC,CAACD,MAAM,EAAE;QAC5ByE,KAAK,CAACnG,GAAG,GAAG,IAAI,CAAC,CAAC2B,IAAI,CAACqD,CAAC,CAAC;QACzB;QACA;QACA,MAAMf,GAAG,GAAGrI,IAAI,CAACE,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC4F,MAAM,CAACsD,CAAC,CAAC;QACxCmB,KAAK,CAAC5C,KAAK,GAAGnF,IAAI,CAACC,KAAK,CAACtC,IAAI,CAACD,GAAG,EAAE,GAAGmI,GAAG,CAAC;MAC9C;MACA,IAAI,IAAI,CAAC,CAACxC,KAAK,EAAE;QACb0E,KAAK,CAAClH,IAAI,GAAG,IAAI,CAAC,CAACwC,KAAK,CAACuD,CAAC,CAAC;MAC/B;MACAsB,GAAG,CAACC,OAAO,CAAC,CAACnD,GAAG,EAAE+C,KAAK,CAAC,CAAC;IAC7B;IACA,OAAOG,GAAG;EACd;EACA;AACJ;AACA;AACA;AACA;EACIE,IAAI,CAACF,GAAG,EAAE;IACN,IAAI,CAACG,KAAK,EAAE;IACZ,KAAK,MAAM,CAACrD,GAAG,EAAE+C,KAAK,CAAC,IAAIG,GAAG,EAAE;MAC5B,IAAIH,KAAK,CAAC5C,KAAK,EAAE;QACb;QACA;QACA;QACA;QACA;QACA;QACA,MAAMU,GAAG,GAAGlI,IAAI,CAACD,GAAG,EAAE,GAAGqK,KAAK,CAAC5C,KAAK;QACpC4C,KAAK,CAAC5C,KAAK,GAAG3H,IAAI,CAACE,GAAG,EAAE,GAAGmI,GAAG;MAClC;MACA,IAAI,CAACyC,GAAG,CAACtD,GAAG,EAAE+C,KAAK,CAACzK,KAAK,EAAEyK,KAAK,CAAC;IACrC;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;EACIO,GAAG,CAACtE,CAAC,EAAEkC,CAAC,EAAEqC,UAAU,GAAG,CAAC,CAAC,EAAE;IACvB,IAAIrC,CAAC,KAAKxB,SAAS,EAAE;MACjB,IAAI,CAACY,MAAM,CAACtB,CAAC,CAAC;MACd,OAAO,IAAI;IACf;IACA,MAAM;MAAEpC,GAAG,GAAG,IAAI,CAACA,GAAG;MAAEuD,KAAK;MAAEjD,cAAc,GAAG,IAAI,CAACA,cAAc;MAAEG,eAAe,GAAG,IAAI,CAACA,eAAe;MAAEqD;IAAQ,CAAC,GAAG6C,UAAU;IACnI,IAAI;MAAEpG,WAAW,GAAG,IAAI,CAACA;IAAY,CAAC,GAAGoG,UAAU;IACnD,MAAM1H,IAAI,GAAG,IAAI,CAAC,CAACoF,WAAW,CAACjC,CAAC,EAAEkC,CAAC,EAAEqC,UAAU,CAAC1H,IAAI,IAAI,CAAC,EAAEwB,eAAe,CAAC;IAC3E;IACA;IACA,IAAI,IAAI,CAACD,YAAY,IAAIvB,IAAI,GAAG,IAAI,CAACuB,YAAY,EAAE;MAC/C,IAAIsD,MAAM,EAAE;QACRA,MAAM,CAAC4C,GAAG,GAAG,MAAM;QACnB5C,MAAM,CAAC8C,oBAAoB,GAAG,IAAI;MACtC;MACA;MACA,IAAI,CAAClD,MAAM,CAACtB,CAAC,CAAC;MACd,OAAO,IAAI;IACf;IACA,IAAIC,KAAK,GAAG,IAAI,CAAC,CAACpD,IAAI,KAAK,CAAC,GAAG6D,SAAS,GAAG,IAAI,CAAC,CAAC9B,MAAM,CAACmD,GAAG,CAAC/B,CAAC,CAAC;IAC9D,IAAIC,KAAK,KAAKS,SAAS,EAAE;MACrB;MACAT,KAAK,GAAI,IAAI,CAAC,CAACpD,IAAI,KAAK,CAAC,GACnB,IAAI,CAAC,CAACqC,IAAI,GACV,IAAI,CAAC,CAACC,IAAI,CAAClC,MAAM,KAAK,CAAC,GACnB,IAAI,CAAC,CAACkC,IAAI,CAAC5B,GAAG,EAAE,GAChB,IAAI,CAAC,CAACV,IAAI,KAAK,IAAI,CAAC,CAACT,GAAG,GACpB,IAAI,CAAC,CAACgG,KAAK,CAAC,KAAK,CAAC,GAClB,IAAI,CAAC,CAACvF,IAAK;MACzB,IAAI,CAAC,CAACgC,OAAO,CAACoB,KAAK,CAAC,GAAGD,CAAC;MACxB,IAAI,CAAC,CAAClB,OAAO,CAACmB,KAAK,CAAC,GAAGiC,CAAC;MACxB,IAAI,CAAC,CAACtD,MAAM,CAAC0F,GAAG,CAACtE,CAAC,EAAEC,KAAK,CAAC;MAC1B,IAAI,CAAC,CAAClB,IAAI,CAAC,IAAI,CAAC,CAACG,IAAI,CAAC,GAAGe,KAAK;MAC9B,IAAI,CAAC,CAACjB,IAAI,CAACiB,KAAK,CAAC,GAAG,IAAI,CAAC,CAACf,IAAI;MAC9B,IAAI,CAAC,CAACA,IAAI,GAAGe,KAAK;MAClB,IAAI,CAAC,CAACpD,IAAI,EAAE;MACZ,IAAI,CAAC,CAACsF,WAAW,CAAClC,KAAK,EAAEpD,IAAI,EAAE6E,MAAM,CAAC;MACtC,IAAIA,MAAM,EACNA,MAAM,CAAC4C,GAAG,GAAG,KAAK;MACtBnG,WAAW,GAAG,KAAK;IACvB,CAAC,MACI;MACD;MACA,IAAI,CAAC,CAACiC,UAAU,CAACH,KAAK,CAAC;MACvB,MAAMwE,MAAM,GAAG,IAAI,CAAC,CAAC3F,OAAO,CAACmB,KAAK,CAAC;MACnC,IAAIiC,CAAC,KAAKuC,MAAM,EAAE;QACd,IAAI,IAAI,CAAC,CAAChF,cAAc,IAAI,IAAI,CAAC,CAACI,iBAAiB,CAAC4E,MAAM,CAAC,EAAE;UACzDA,MAAM,CAACC,iBAAiB,CAACpJ,KAAK,CAAC,IAAImF,KAAK,CAAC,UAAU,CAAC,CAAC;UACrD,MAAM;YAAE8C,oBAAoB,EAAElG;UAAE,CAAC,GAAGoH,MAAM;UAC1C,IAAIpH,CAAC,KAAKqD,SAAS,IAAI,CAACxC,cAAc,EAAE;YACpC,IAAI,IAAI,CAAC,CAACsB,UAAU,EAAE;cAClB,IAAI,CAAC,CAAC/B,OAAO,GAAGJ,CAAC,EAAE2C,CAAC,EAAE,KAAK,CAAC;YAChC;YACA,IAAI,IAAI,CAAC,CAACN,eAAe,EAAE;cACvB,IAAI,CAAC,CAACN,QAAQ,EAAElE,IAAI,CAAC,CAACmC,CAAC,EAAE2C,CAAC,EAAE,KAAK,CAAC,CAAC;YACvC;UACJ;QACJ,CAAC,MACI,IAAI,CAAC9B,cAAc,EAAE;UACtB,IAAI,IAAI,CAAC,CAACsB,UAAU,EAAE;YAClB,IAAI,CAAC,CAAC/B,OAAO,GAAGgH,MAAM,EAAEzE,CAAC,EAAE,KAAK,CAAC;UACrC;UACA,IAAI,IAAI,CAAC,CAACN,eAAe,EAAE;YACvB,IAAI,CAAC,CAACN,QAAQ,EAAElE,IAAI,CAAC,CAACuJ,MAAM,EAAEzE,CAAC,EAAE,KAAK,CAAC,CAAC;UAC5C;QACJ;QACA,IAAI,CAAC,CAACgC,cAAc,CAAC/B,KAAK,CAAC;QAC3B,IAAI,CAAC,CAACkC,WAAW,CAAClC,KAAK,EAAEpD,IAAI,EAAE6E,MAAM,CAAC;QACtC,IAAI,CAAC,CAAC5C,OAAO,CAACmB,KAAK,CAAC,GAAGiC,CAAC;QACxB,IAAIR,MAAM,EAAE;UACRA,MAAM,CAAC4C,GAAG,GAAG,SAAS;UACtB,MAAMK,QAAQ,GAAGF,MAAM,IAAI,IAAI,CAAC,CAAC5E,iBAAiB,CAAC4E,MAAM,CAAC,GACpDA,MAAM,CAAClB,oBAAoB,GAC3BkB,MAAM;UACZ,IAAIE,QAAQ,KAAKjE,SAAS,EACtBgB,MAAM,CAACiD,QAAQ,GAAGA,QAAQ;QAClC;MACJ,CAAC,MACI,IAAIjD,MAAM,EAAE;QACbA,MAAM,CAAC4C,GAAG,GAAG,QAAQ;MACzB;IACJ;IACA,IAAI1G,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC2B,IAAI,EAAE;MAC1B,IAAI,CAAC,CAACsB,qBAAqB,EAAE;IACjC;IACA,IAAI,IAAI,CAAC,CAACtB,IAAI,EAAE;MACZ,IAAI,CAACpB,WAAW,EAAE;QACd,IAAI,CAAC,CAAC+C,UAAU,CAACjB,KAAK,EAAErC,GAAG,EAAEuD,KAAK,CAAC;MACvC;MACA,IAAIO,MAAM,EACN,IAAI,CAAC,CAACD,SAAS,CAACC,MAAM,EAAEzB,KAAK,CAAC;IACtC;IACA,IAAI,CAAC/B,cAAc,IAAI,IAAI,CAAC,CAACwB,eAAe,IAAI,IAAI,CAAC,CAACN,QAAQ,EAAE;MAC5D,MAAMwF,EAAE,GAAG,IAAI,CAAC,CAACxF,QAAQ;MACzB,IAAIyF,IAAI;MACR,OAAQA,IAAI,GAAGD,EAAE,EAAEE,KAAK,EAAE,EAAG;QACzB,IAAI,CAAC,CAACpH,YAAY,GAAG,GAAGmH,IAAI,CAAC;MACjC;IACJ;IACA,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;EACItH,GAAG,GAAG;IACF,IAAI;MACA,OAAO,IAAI,CAAC,CAACV,IAAI,EAAE;QACf,MAAMkI,GAAG,GAAG,IAAI,CAAC,CAACjG,OAAO,CAAC,IAAI,CAAC,CAACG,IAAI,CAAC;QACrC,IAAI,CAAC,CAACmD,KAAK,CAAC,IAAI,CAAC;QACjB,IAAI,IAAI,CAAC,CAACvC,iBAAiB,CAACkF,GAAG,CAAC,EAAE;UAC9B,IAAIA,GAAG,CAACxB,oBAAoB,EAAE;YAC1B,OAAOwB,GAAG,CAACxB,oBAAoB;UACnC;QACJ,CAAC,MACI,IAAIwB,GAAG,KAAKrE,SAAS,EAAE;UACxB,OAAOqE,GAAG;QACd;MACJ;IACJ,CAAC,SACO;MACJ,IAAI,IAAI,CAAC,CAACrF,eAAe,IAAI,IAAI,CAAC,CAACN,QAAQ,EAAE;QACzC,MAAMwF,EAAE,GAAG,IAAI,CAAC,CAACxF,QAAQ;QACzB,IAAIyF,IAAI;QACR,OAAQA,IAAI,GAAGD,EAAE,EAAEE,KAAK,EAAE,EAAG;UACzB,IAAI,CAAC,CAACpH,YAAY,GAAG,GAAGmH,IAAI,CAAC;QACjC;MACJ;IACJ;EACJ;EACA,CAACzC,KAAK,CAACjD,IAAI,EAAE;IACT,MAAMF,IAAI,GAAG,IAAI,CAAC,CAACA,IAAI;IACvB,MAAMe,CAAC,GAAG,IAAI,CAAC,CAACnB,OAAO,CAACI,IAAI,CAAC;IAC7B,MAAMiD,CAAC,GAAG,IAAI,CAAC,CAACpD,OAAO,CAACG,IAAI,CAAC;IAC7B,IAAI,IAAI,CAAC,CAACQ,cAAc,IAAI,IAAI,CAAC,CAACI,iBAAiB,CAACqC,CAAC,CAAC,EAAE;MACpDA,CAAC,CAACwC,iBAAiB,CAACpJ,KAAK,CAAC,IAAImF,KAAK,CAAC,SAAS,CAAC,CAAC;IACnD,CAAC,MACI,IAAI,IAAI,CAAC,CAACjB,UAAU,IAAI,IAAI,CAAC,CAACE,eAAe,EAAE;MAChD,IAAI,IAAI,CAAC,CAACF,UAAU,EAAE;QAClB,IAAI,CAAC,CAAC/B,OAAO,GAAGyE,CAAC,EAAElC,CAAC,EAAE,OAAO,CAAC;MAClC;MACA,IAAI,IAAI,CAAC,CAACN,eAAe,EAAE;QACvB,IAAI,CAAC,CAACN,QAAQ,EAAElE,IAAI,CAAC,CAACgH,CAAC,EAAElC,CAAC,EAAE,OAAO,CAAC,CAAC;MACzC;IACJ;IACA,IAAI,CAAC,CAACgC,cAAc,CAAC/C,IAAI,CAAC;IAC1B;IACA,IAAIE,IAAI,EAAE;MACN,IAAI,CAAC,CAACN,OAAO,CAACI,IAAI,CAAC,GAAGyB,SAAS;MAC/B,IAAI,CAAC,CAAC5B,OAAO,CAACG,IAAI,CAAC,GAAGyB,SAAS;MAC/B,IAAI,CAAC,CAACvB,IAAI,CAACjE,IAAI,CAAC+D,IAAI,CAAC;IACzB;IACA,IAAI,IAAI,CAAC,CAACpC,IAAI,KAAK,CAAC,EAAE;MAClB,IAAI,CAAC,CAACoC,IAAI,GAAG,IAAI,CAAC,CAACC,IAAI,GAAG,CAAC;MAC3B,IAAI,CAAC,CAACC,IAAI,CAAClC,MAAM,GAAG,CAAC;IACzB,CAAC,MACI;MACD,IAAI,CAAC,CAACgC,IAAI,GAAG,IAAI,CAAC,CAACF,IAAI,CAACE,IAAI,CAAC;IACjC;IACA,IAAI,CAAC,CAACL,MAAM,CAAC0C,MAAM,CAACtB,CAAC,CAAC;IACtB,IAAI,CAAC,CAACnD,IAAI,EAAE;IACZ,OAAOoC,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACItD,GAAG,CAACqE,CAAC,EAAEgF,UAAU,GAAG,CAAC,CAAC,EAAE;IACpB,MAAM;MAAEhH,cAAc,GAAG,IAAI,CAACA,cAAc;MAAE0D;IAAO,CAAC,GAAGsD,UAAU;IACnE,MAAM/E,KAAK,GAAG,IAAI,CAAC,CAACrB,MAAM,CAACmD,GAAG,CAAC/B,CAAC,CAAC;IACjC,IAAIC,KAAK,KAAKS,SAAS,EAAE;MACrB,MAAMwB,CAAC,GAAG,IAAI,CAAC,CAACpD,OAAO,CAACmB,KAAK,CAAC;MAC9B,IAAI,IAAI,CAAC,CAACJ,iBAAiB,CAACqC,CAAC,CAAC,IAC1BA,CAAC,CAACqB,oBAAoB,KAAK7C,SAAS,EAAE;QACtC,OAAO,KAAK;MAChB;MACA,IAAI,CAAC,IAAI,CAAC,CAACH,OAAO,CAACN,KAAK,CAAC,EAAE;QACvB,IAAIjC,cAAc,EAAE;UAChB,IAAI,CAAC,CAACwD,aAAa,CAACvB,KAAK,CAAC;QAC9B;QACA,IAAIyB,MAAM,EAAE;UACRA,MAAM,CAAC/F,GAAG,GAAG,KAAK;UAClB,IAAI,CAAC,CAAC8F,SAAS,CAACC,MAAM,EAAEzB,KAAK,CAAC;QAClC;QACA,OAAO,IAAI;MACf,CAAC,MACI,IAAIyB,MAAM,EAAE;QACbA,MAAM,CAAC/F,GAAG,GAAG,OAAO;QACpB,IAAI,CAAC,CAAC8F,SAAS,CAACC,MAAM,EAAEzB,KAAK,CAAC;MAClC;IACJ,CAAC,MACI,IAAIyB,MAAM,EAAE;MACbA,MAAM,CAAC/F,GAAG,GAAG,MAAM;IACvB;IACA,OAAO,KAAK;EAChB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIsJ,IAAI,CAACjF,CAAC,EAAEkF,WAAW,GAAG,CAAC,CAAC,EAAE;IACtB,MAAM;MAAEjH,UAAU,GAAG,IAAI,CAACA;IAAW,CAAC,GAAGiH,WAAW;IACpD,MAAMjF,KAAK,GAAG,IAAI,CAAC,CAACrB,MAAM,CAACmD,GAAG,CAAC/B,CAAC,CAAC;IACjC,IAAIC,KAAK,KAAKS,SAAS,IAClB,CAACzC,UAAU,IAAI,IAAI,CAAC,CAACsC,OAAO,CAACN,KAAK,CAAE,EAAE;MACvC;IACJ;IACA,MAAMiC,CAAC,GAAG,IAAI,CAAC,CAACpD,OAAO,CAACmB,KAAK,CAAC;IAC9B;IACA,OAAO,IAAI,CAAC,CAACJ,iBAAiB,CAACqC,CAAC,CAAC,GAAGA,CAAC,CAACqB,oBAAoB,GAAGrB,CAAC;EAClE;EACA,CAACnC,eAAe,CAACC,CAAC,EAAEC,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAE;IACzC,MAAM+B,CAAC,GAAGjC,KAAK,KAAKS,SAAS,GAAGA,SAAS,GAAG,IAAI,CAAC,CAAC5B,OAAO,CAACmB,KAAK,CAAC;IAChE,IAAI,IAAI,CAAC,CAACJ,iBAAiB,CAACqC,CAAC,CAAC,EAAE;MAC5B,OAAOA,CAAC;IACZ;IACA,MAAMiD,EAAE,GAAG,IAAI5K,EAAE,EAAE;IACnB,MAAM;MAAEc;IAAO,CAAC,GAAG6E,OAAO;IAC1B;IACA7E,MAAM,EAAEL,gBAAgB,CAAC,OAAO,EAAE,MAAMmK,EAAE,CAAC7J,KAAK,CAACD,MAAM,CAACP,MAAM,CAAC,EAAE;MAC7DO,MAAM,EAAE8J,EAAE,CAAC9J;IACf,CAAC,CAAC;IACF,MAAM+J,SAAS,GAAG;MACd/J,MAAM,EAAE8J,EAAE,CAAC9J,MAAM;MACjB6E,OAAO;MACPC;IACJ,CAAC;IACD,MAAMkF,EAAE,GAAG,CAACnD,CAAC,EAAEoD,WAAW,GAAG,KAAK,KAAK;MACnC,MAAM;QAAEvK;MAAQ,CAAC,GAAGoK,EAAE,CAAC9J,MAAM;MAC7B,MAAMkK,WAAW,GAAGrF,OAAO,CAACxB,gBAAgB,IAAIwD,CAAC,KAAKxB,SAAS;MAC/D,IAAIR,OAAO,CAACwB,MAAM,EAAE;QAChB,IAAI3G,OAAO,IAAI,CAACuK,WAAW,EAAE;UACzBpF,OAAO,CAACwB,MAAM,CAAC8D,YAAY,GAAG,IAAI;UAClCtF,OAAO,CAACwB,MAAM,CAAC+D,UAAU,GAAGN,EAAE,CAAC9J,MAAM,CAACP,MAAM;UAC5C,IAAIyK,WAAW,EACXrF,OAAO,CAACwB,MAAM,CAACgE,iBAAiB,GAAG,IAAI;QAC/C,CAAC,MACI;UACDxF,OAAO,CAACwB,MAAM,CAACiE,aAAa,GAAG,IAAI;QACvC;MACJ;MACA,IAAI5K,OAAO,IAAI,CAACwK,WAAW,IAAI,CAACD,WAAW,EAAE;QACzC,OAAOM,SAAS,CAACT,EAAE,CAAC9J,MAAM,CAACP,MAAM,CAAC;MACtC;MACA;MACA,MAAM+K,EAAE,GAAG/F,CAAC;MACZ,IAAI,IAAI,CAAC,CAAChB,OAAO,CAACmB,KAAK,CAAC,KAAKH,CAAC,EAAE;QAC5B,IAAIoC,CAAC,KAAKxB,SAAS,EAAE;UACjB,IAAImF,EAAE,CAACtC,oBAAoB,EAAE;YACzB,IAAI,CAAC,CAACzE,OAAO,CAACmB,KAAK,CAAC,GAAG4F,EAAE,CAACtC,oBAAoB;UAClD,CAAC,MACI;YACD,IAAI,CAACjC,MAAM,CAACtB,CAAC,CAAC;UAClB;QACJ,CAAC,MACI;UACD,IAAIE,OAAO,CAACwB,MAAM,EACdxB,OAAO,CAACwB,MAAM,CAACoE,YAAY,GAAG,IAAI;UACtC,IAAI,CAACxB,GAAG,CAACtE,CAAC,EAAEkC,CAAC,EAAEkD,SAAS,CAAClF,OAAO,CAAC;QACrC;MACJ;MACA,OAAOgC,CAAC;IACZ,CAAC;IACD,MAAM6D,EAAE,GAAIC,EAAE,IAAK;MACf,IAAI9F,OAAO,CAACwB,MAAM,EAAE;QAChBxB,OAAO,CAACwB,MAAM,CAACuE,aAAa,GAAG,IAAI;QACnC/F,OAAO,CAACwB,MAAM,CAAC+D,UAAU,GAAGO,EAAE;MAClC;MACA,OAAOJ,SAAS,CAACI,EAAE,CAAC;IACxB,CAAC;IACD,MAAMJ,SAAS,GAAII,EAAE,IAAK;MACtB,MAAM;QAAEjL;MAAQ,CAAC,GAAGoK,EAAE,CAAC9J,MAAM;MAC7B,MAAM6K,iBAAiB,GAAGnL,OAAO,IAAImF,OAAO,CAAC1B,sBAAsB;MACnE,MAAMP,UAAU,GAAGiI,iBAAiB,IAAIhG,OAAO,CAACzB,0BAA0B;MAC1E,MAAM0H,QAAQ,GAAGlI,UAAU,IAAIiC,OAAO,CAAC5B,wBAAwB;MAC/D,MAAMuH,EAAE,GAAG/F,CAAC;MACZ,IAAI,IAAI,CAAC,CAAChB,OAAO,CAACmB,KAAK,CAAC,KAAKH,CAAC,EAAE;QAC5B;QACA;QACA,MAAMsG,GAAG,GAAG,CAACD,QAAQ,IAAIN,EAAE,CAACtC,oBAAoB,KAAK7C,SAAS;QAC9D,IAAI0F,GAAG,EAAE;UACL,IAAI,CAAC9E,MAAM,CAACtB,CAAC,CAAC;QAClB,CAAC,MACI,IAAI,CAACkG,iBAAiB,EAAE;UACzB;UACA;UACA;UACA;UACA,IAAI,CAAC,CAACpH,OAAO,CAACmB,KAAK,CAAC,GAAG4F,EAAE,CAACtC,oBAAoB;QAClD;MACJ;MACA,IAAItF,UAAU,EAAE;QACZ,IAAIiC,OAAO,CAACwB,MAAM,IAAImE,EAAE,CAACtC,oBAAoB,KAAK7C,SAAS,EAAE;UACzDR,OAAO,CAACwB,MAAM,CAAC2E,aAAa,GAAG,IAAI;QACvC;QACA,OAAOR,EAAE,CAACtC,oBAAoB;MAClC,CAAC,MACI,IAAIsC,EAAE,CAACS,UAAU,KAAKT,EAAE,EAAE;QAC3B,MAAMG,EAAE;MACZ;IACJ,CAAC;IACD,MAAMO,KAAK,GAAG,CAACC,GAAG,EAAEC,GAAG,KAAK;MACxB,MAAMC,GAAG,GAAG,IAAI,CAAC,CAAC/I,WAAW,GAAGqC,CAAC,EAAEkC,CAAC,EAAEkD,SAAS,CAAC;MAChD,IAAIsB,GAAG,IAAIA,GAAG,YAAYC,OAAO,EAAE;QAC/BD,GAAG,CAACE,IAAI,CAAC1E,CAAC,IAAIsE,GAAG,CAACtE,CAAC,KAAKxB,SAAS,GAAGA,SAAS,GAAGwB,CAAC,CAAC,EAAEuE,GAAG,CAAC;MAC5D;MACA;MACA;MACA;MACAtB,EAAE,CAAC9J,MAAM,CAACL,gBAAgB,CAAC,OAAO,EAAE,MAAM;QACtC,IAAI,CAACkF,OAAO,CAACxB,gBAAgB,IACzBwB,OAAO,CAAC1B,sBAAsB,EAAE;UAChCgI,GAAG,CAAC9F,SAAS,CAAC;UACd;UACA,IAAIR,OAAO,CAAC1B,sBAAsB,EAAE;YAChCgI,GAAG,GAAGtE,CAAC,IAAImD,EAAE,CAACnD,CAAC,EAAE,IAAI,CAAC;UAC1B;QACJ;MACJ,CAAC,CAAC;IACN,CAAC;IACD,IAAIhC,OAAO,CAACwB,MAAM,EACdxB,OAAO,CAACwB,MAAM,CAACmF,eAAe,GAAG,IAAI;IACzC,MAAM/G,CAAC,GAAG,IAAI6G,OAAO,CAACJ,KAAK,CAAC,CAACK,IAAI,CAACvB,EAAE,EAAEU,EAAE,CAAC;IACzC,MAAMF,EAAE,GAAG1M,MAAM,CAAC2N,MAAM,CAAChH,CAAC,EAAE;MACxB4E,iBAAiB,EAAES,EAAE;MACrB5B,oBAAoB,EAAErB,CAAC;MACvBoE,UAAU,EAAE5F;IAChB,CAAC,CAAC;IACF,IAAIT,KAAK,KAAKS,SAAS,EAAE;MACrB;MACA,IAAI,CAAC4D,GAAG,CAACtE,CAAC,EAAE6F,EAAE,EAAE;QAAE,GAAGT,SAAS,CAAClF,OAAO;QAAEwB,MAAM,EAAEhB;MAAU,CAAC,CAAC;MAC5DT,KAAK,GAAG,IAAI,CAAC,CAACrB,MAAM,CAACmD,GAAG,CAAC/B,CAAC,CAAC;IAC/B,CAAC,MACI;MACD,IAAI,CAAC,CAAClB,OAAO,CAACmB,KAAK,CAAC,GAAG4F,EAAE;IAC7B;IACA,OAAOA,EAAE;EACb;EACA,CAAChG,iBAAiB,CAACC,CAAC,EAAE;IAClB,IAAI,CAAC,IAAI,CAAC,CAACL,cAAc,EACrB,OAAO,KAAK;IAChB,MAAMsH,CAAC,GAAGjH,CAAC;IACX,OAAQ,CAAC,CAACiH,CAAC,IACPA,CAAC,YAAYJ,OAAO,IACpBI,CAAC,CAACC,cAAc,CAAC,sBAAsB,CAAC,IACxCD,CAAC,CAACrC,iBAAiB,YAAYnK,EAAE;EACzC;EACM0M,KAAK,CAACjH,CAAC,EAAEkH,YAAY,GAAG,CAAC,CAAC,EAAE;IAAA;IAAA;MAC9B,MAAM;QACN;QACAjJ,UAAU,GAAG,KAAI,CAACA,UAAU;QAAEF,cAAc,GAAG,KAAI,CAACA,cAAc;QAAEQ,kBAAkB,GAAG,KAAI,CAACA,kBAAkB;QAChH;QACAX,GAAG,GAAG,KAAI,CAACA,GAAG;QAAEM,cAAc,GAAG,KAAI,CAACA,cAAc;QAAErB,IAAI,GAAG,CAAC;QAAEwB,eAAe,GAAG,KAAI,CAACA,eAAe;QAAEF,WAAW,GAAG,KAAI,CAACA,WAAW;QACtI;QACAG,wBAAwB,GAAG,KAAI,CAACA,wBAAwB;QAAEG,0BAA0B,GAAG,KAAI,CAACA,0BAA0B;QAAEC,gBAAgB,GAAG,KAAI,CAACA,gBAAgB;QAAEF,sBAAsB,GAAG,KAAI,CAACA,sBAAsB;QAAE2B,OAAO;QAAEgH,YAAY,GAAG,KAAK;QAAEzF,MAAM;QAAErG;MAAQ,CAAC,GAAG6L,YAAY;MACvR,IAAI,CAAC,KAAI,CAAC,CAACzH,cAAc,EAAE;QACvB,IAAIiC,MAAM,EACNA,MAAM,CAACuF,KAAK,GAAG,KAAK;QACxB,OAAO,KAAI,CAAClF,GAAG,CAAC/B,CAAC,EAAE;UACf/B,UAAU;UACVF,cAAc;UACdQ,kBAAkB;UAClBmD;QACJ,CAAC,CAAC;MACN;MACA,MAAMxB,OAAO,GAAG;QACZjC,UAAU;QACVF,cAAc;QACdQ,kBAAkB;QAClBX,GAAG;QACHM,cAAc;QACdrB,IAAI;QACJwB,eAAe;QACfF,WAAW;QACXG,wBAAwB;QACxBG,0BAA0B;QAC1BD,sBAAsB;QACtBE,gBAAgB;QAChBgD,MAAM;QACNrG;MACJ,CAAC;MACD,IAAI4E,KAAK,GAAG,KAAI,CAAC,CAACrB,MAAM,CAACmD,GAAG,CAAC/B,CAAC,CAAC;MAC/B,IAAIC,KAAK,KAAKS,SAAS,EAAE;QACrB,IAAIgB,MAAM,EACNA,MAAM,CAACuF,KAAK,GAAG,MAAM;QACzB,MAAMnH,CAAC,GAAG,KAAI,CAAC,CAACC,eAAe,CAACC,CAAC,EAAEC,KAAK,EAAEC,OAAO,EAAEC,OAAO,CAAC;QAC3D,OAAQL,CAAC,CAACwG,UAAU,GAAGxG,CAAC;MAC5B,CAAC,MACI;QACD;QACA,MAAMoC,CAAC,GAAG,KAAI,CAAC,CAACpD,OAAO,CAACmB,KAAK,CAAC;QAC9B,IAAI,KAAI,CAAC,CAACJ,iBAAiB,CAACqC,CAAC,CAAC,EAAE;UAC5B,MAAMkF,KAAK,GAAGnJ,UAAU,IAAIiE,CAAC,CAACqB,oBAAoB,KAAK7C,SAAS;UAChE,IAAIgB,MAAM,EAAE;YACRA,MAAM,CAACuF,KAAK,GAAG,UAAU;YACzB,IAAIG,KAAK,EACL1F,MAAM,CAAC2E,aAAa,GAAG,IAAI;UACnC;UACA,OAAOe,KAAK,GAAGlF,CAAC,CAACqB,oBAAoB,GAAIrB,CAAC,CAACoE,UAAU,GAAGpE,CAAE;QAC9D;QACA;QACA;QACA,MAAM3B,OAAO,GAAG,KAAI,CAAC,CAACA,OAAO,CAACN,KAAK,CAAC;QACpC,IAAI,CAACkH,YAAY,IAAI,CAAC5G,OAAO,EAAE;UAC3B,IAAImB,MAAM,EACNA,MAAM,CAACuF,KAAK,GAAG,KAAK;UACxB,KAAI,CAAC,CAAC7G,UAAU,CAACH,KAAK,CAAC;UACvB,IAAIlC,cAAc,EAAE;YAChB,KAAI,CAAC,CAACyD,aAAa,CAACvB,KAAK,CAAC;UAC9B;UACA,IAAIyB,MAAM,EACN,KAAI,CAAC,CAACD,SAAS,CAACC,MAAM,EAAEzB,KAAK,CAAC;UAClC,OAAOiC,CAAC;QACZ;QACA;QACA;QACA,MAAMpC,CAAC,GAAG,KAAI,CAAC,CAACC,eAAe,CAACC,CAAC,EAAEC,KAAK,EAAEC,OAAO,EAAEC,OAAO,CAAC;QAC3D,MAAMkH,QAAQ,GAAGvH,CAAC,CAACyD,oBAAoB,KAAK7C,SAAS;QACrD,MAAM4G,QAAQ,GAAGD,QAAQ,IAAIpJ,UAAU;QACvC,IAAIyD,MAAM,EAAE;UACRA,MAAM,CAACuF,KAAK,GAAG1G,OAAO,GAAG,OAAO,GAAG,SAAS;UAC5C,IAAI+G,QAAQ,IAAI/G,OAAO,EACnBmB,MAAM,CAAC2E,aAAa,GAAG,IAAI;QACnC;QACA,OAAOiB,QAAQ,GAAGxH,CAAC,CAACyD,oBAAoB,GAAIzD,CAAC,CAACwG,UAAU,GAAGxG,CAAE;MACjE;IAAC;EACL;EACA;AACJ;AACA;AACA;AACA;AACA;EACIiC,GAAG,CAAC/B,CAAC,EAAEsD,UAAU,GAAG,CAAC,CAAC,EAAE;IACpB,MAAM;MAAErF,UAAU,GAAG,IAAI,CAACA,UAAU;MAAEF,cAAc,GAAG,IAAI,CAACA,cAAc;MAAEQ,kBAAkB,GAAG,IAAI,CAACA,kBAAkB;MAAEmD;IAAQ,CAAC,GAAG4B,UAAU;IAChJ,MAAMrD,KAAK,GAAG,IAAI,CAAC,CAACrB,MAAM,CAACmD,GAAG,CAAC/B,CAAC,CAAC;IACjC,IAAIC,KAAK,KAAKS,SAAS,EAAE;MACrB,MAAMpH,KAAK,GAAG,IAAI,CAAC,CAACwF,OAAO,CAACmB,KAAK,CAAC;MAClC,MAAMsH,QAAQ,GAAG,IAAI,CAAC,CAAC1H,iBAAiB,CAACvG,KAAK,CAAC;MAC/C,IAAIoI,MAAM,EACN,IAAI,CAAC,CAACD,SAAS,CAACC,MAAM,EAAEzB,KAAK,CAAC;MAClC,IAAI,IAAI,CAAC,CAACM,OAAO,CAACN,KAAK,CAAC,EAAE;QACtB,IAAIyB,MAAM,EACNA,MAAM,CAACK,GAAG,GAAG,OAAO;QACxB;QACA,IAAI,CAACwF,QAAQ,EAAE;UACX,IAAI,CAAChJ,kBAAkB,EAAE;YACrB,IAAI,CAAC+C,MAAM,CAACtB,CAAC,CAAC;UAClB;UACA,IAAI0B,MAAM,IAAIzD,UAAU,EACpByD,MAAM,CAAC2E,aAAa,GAAG,IAAI;UAC/B,OAAOpI,UAAU,GAAG3E,KAAK,GAAGoH,SAAS;QACzC,CAAC,MACI;UACD,IAAIgB,MAAM,IACNzD,UAAU,IACV3E,KAAK,CAACiK,oBAAoB,KAAK7C,SAAS,EAAE;YAC1CgB,MAAM,CAAC2E,aAAa,GAAG,IAAI;UAC/B;UACA,OAAOpI,UAAU,GAAG3E,KAAK,CAACiK,oBAAoB,GAAG7C,SAAS;QAC9D;MACJ,CAAC,MACI;QACD,IAAIgB,MAAM,EACNA,MAAM,CAACK,GAAG,GAAG,KAAK;QACtB;QACA;QACA;QACA;QACA;QACA,IAAIwF,QAAQ,EAAE;UACV,OAAOjO,KAAK,CAACiK,oBAAoB;QACrC;QACA,IAAI,CAAC,CAACnD,UAAU,CAACH,KAAK,CAAC;QACvB,IAAIlC,cAAc,EAAE;UAChB,IAAI,CAAC,CAACyD,aAAa,CAACvB,KAAK,CAAC;QAC9B;QACA,OAAO3G,KAAK;MAChB;IACJ,CAAC,MACI,IAAIoI,MAAM,EAAE;MACbA,MAAM,CAACK,GAAG,GAAG,MAAM;IACvB;EACJ;EACA,CAACyF,OAAO,CAAC1H,CAAC,EAAE/D,CAAC,EAAE;IACX,IAAI,CAAC,CAACiD,IAAI,CAACjD,CAAC,CAAC,GAAG+D,CAAC;IACjB,IAAI,CAAC,CAACf,IAAI,CAACe,CAAC,CAAC,GAAG/D,CAAC;EACrB;EACA,CAACqE,UAAU,CAACH,KAAK,EAAE;IACf;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAIA,KAAK,KAAK,IAAI,CAAC,CAACf,IAAI,EAAE;MACtB,IAAIe,KAAK,KAAK,IAAI,CAAC,CAAChB,IAAI,EAAE;QACtB,IAAI,CAAC,CAACA,IAAI,GAAG,IAAI,CAAC,CAACF,IAAI,CAACkB,KAAK,CAAC;MAClC,CAAC,MACI;QACD,IAAI,CAAC,CAACuH,OAAO,CAAC,IAAI,CAAC,CAACxI,IAAI,CAACiB,KAAK,CAAC,EAAE,IAAI,CAAC,CAAClB,IAAI,CAACkB,KAAK,CAAC,CAAC;MACvD;MACA,IAAI,CAAC,CAACuH,OAAO,CAAC,IAAI,CAAC,CAACtI,IAAI,EAAEe,KAAK,CAAC;MAChC,IAAI,CAAC,CAACf,IAAI,GAAGe,KAAK;IACtB;EACJ;EACA;AACJ;AACA;AACA;EACIqB,MAAM,CAACtB,CAAC,EAAE;IACN,IAAI6D,OAAO,GAAG,KAAK;IACnB,IAAI,IAAI,CAAC,CAAChH,IAAI,KAAK,CAAC,EAAE;MAClB,MAAMoD,KAAK,GAAG,IAAI,CAAC,CAACrB,MAAM,CAACmD,GAAG,CAAC/B,CAAC,CAAC;MACjC,IAAIC,KAAK,KAAKS,SAAS,EAAE;QACrBmD,OAAO,GAAG,IAAI;QACd,IAAI,IAAI,CAAC,CAAChH,IAAI,KAAK,CAAC,EAAE;UAClB,IAAI,CAACwH,KAAK,EAAE;QAChB,CAAC,MACI;UACD,IAAI,CAAC,CAACrC,cAAc,CAAC/B,KAAK,CAAC;UAC3B,MAAMiC,CAAC,GAAG,IAAI,CAAC,CAACpD,OAAO,CAACmB,KAAK,CAAC;UAC9B,IAAI,IAAI,CAAC,CAACJ,iBAAiB,CAACqC,CAAC,CAAC,EAAE;YAC5BA,CAAC,CAACwC,iBAAiB,CAACpJ,KAAK,CAAC,IAAImF,KAAK,CAAC,SAAS,CAAC,CAAC;UACnD,CAAC,MACI,IAAI,IAAI,CAAC,CAACjB,UAAU,IAAI,IAAI,CAAC,CAACE,eAAe,EAAE;YAChD,IAAI,IAAI,CAAC,CAACF,UAAU,EAAE;cAClB,IAAI,CAAC,CAAC/B,OAAO,GAAGyE,CAAC,EAAElC,CAAC,EAAE,QAAQ,CAAC;YACnC;YACA,IAAI,IAAI,CAAC,CAACN,eAAe,EAAE;cACvB,IAAI,CAAC,CAACN,QAAQ,EAAElE,IAAI,CAAC,CAACgH,CAAC,EAAElC,CAAC,EAAE,QAAQ,CAAC,CAAC;YAC1C;UACJ;UACA,IAAI,CAAC,CAACpB,MAAM,CAAC0C,MAAM,CAACtB,CAAC,CAAC;UACtB,IAAI,CAAC,CAACnB,OAAO,CAACoB,KAAK,CAAC,GAAGS,SAAS;UAChC,IAAI,CAAC,CAAC5B,OAAO,CAACmB,KAAK,CAAC,GAAGS,SAAS;UAChC,IAAIT,KAAK,KAAK,IAAI,CAAC,CAACf,IAAI,EAAE;YACtB,IAAI,CAAC,CAACA,IAAI,GAAG,IAAI,CAAC,CAACF,IAAI,CAACiB,KAAK,CAAC;UAClC,CAAC,MACI,IAAIA,KAAK,KAAK,IAAI,CAAC,CAAChB,IAAI,EAAE;YAC3B,IAAI,CAAC,CAACA,IAAI,GAAG,IAAI,CAAC,CAACF,IAAI,CAACkB,KAAK,CAAC;UAClC,CAAC,MACI;YACD,MAAMwH,EAAE,GAAG,IAAI,CAAC,CAACzI,IAAI,CAACiB,KAAK,CAAC;YAC5B,IAAI,CAAC,CAAClB,IAAI,CAAC0I,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC1I,IAAI,CAACkB,KAAK,CAAC;YAClC,MAAMyH,EAAE,GAAG,IAAI,CAAC,CAAC3I,IAAI,CAACkB,KAAK,CAAC;YAC5B,IAAI,CAAC,CAACjB,IAAI,CAAC0I,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC1I,IAAI,CAACiB,KAAK,CAAC;UACtC;UACA,IAAI,CAAC,CAACpD,IAAI,EAAE;UACZ,IAAI,CAAC,CAACsC,IAAI,CAACjE,IAAI,CAAC+E,KAAK,CAAC;QAC1B;MACJ;IACJ;IACA,IAAI,IAAI,CAAC,CAACP,eAAe,IAAI,IAAI,CAAC,CAACN,QAAQ,EAAEnC,MAAM,EAAE;MACjD,MAAM2H,EAAE,GAAG,IAAI,CAAC,CAACxF,QAAQ;MACzB,IAAIyF,IAAI;MACR,OAAQA,IAAI,GAAGD,EAAE,EAAEE,KAAK,EAAE,EAAG;QACzB,IAAI,CAAC,CAACpH,YAAY,GAAG,GAAGmH,IAAI,CAAC;MACjC;IACJ;IACA,OAAOhB,OAAO;EAClB;EACA;AACJ;AACA;EACIQ,KAAK,GAAG;IACJ,KAAK,MAAMpE,KAAK,IAAI,IAAI,CAAC,CAACK,QAAQ,CAAC;MAAErC,UAAU,EAAE;IAAK,CAAC,CAAC,EAAE;MACtD,MAAMiE,CAAC,GAAG,IAAI,CAAC,CAACpD,OAAO,CAACmB,KAAK,CAAC;MAC9B,IAAI,IAAI,CAAC,CAACJ,iBAAiB,CAACqC,CAAC,CAAC,EAAE;QAC5BA,CAAC,CAACwC,iBAAiB,CAACpJ,KAAK,CAAC,IAAImF,KAAK,CAAC,SAAS,CAAC,CAAC;MACnD,CAAC,MACI;QACD,MAAMT,CAAC,GAAG,IAAI,CAAC,CAACnB,OAAO,CAACoB,KAAK,CAAC;QAC9B,IAAI,IAAI,CAAC,CAACT,UAAU,EAAE;UAClB,IAAI,CAAC,CAAC/B,OAAO,GAAGyE,CAAC,EAAElC,CAAC,EAAE,QAAQ,CAAC;QACnC;QACA,IAAI,IAAI,CAAC,CAACN,eAAe,EAAE;UACvB,IAAI,CAAC,CAACN,QAAQ,EAAElE,IAAI,CAAC,CAACgH,CAAC,EAAElC,CAAC,EAAE,QAAQ,CAAC,CAAC;QAC1C;MACJ;IACJ;IACA,IAAI,CAAC,CAACpB,MAAM,CAACyF,KAAK,EAAE;IACpB,IAAI,CAAC,CAACvF,OAAO,CAAChC,IAAI,CAAC4D,SAAS,CAAC;IAC7B,IAAI,CAAC,CAAC7B,OAAO,CAAC/B,IAAI,CAAC4D,SAAS,CAAC;IAC7B,IAAI,IAAI,CAAC,CAACnB,IAAI,IAAI,IAAI,CAAC,CAACD,MAAM,EAAE;MAC5B,IAAI,CAAC,CAACC,IAAI,CAACzC,IAAI,CAAC,CAAC,CAAC;MAClB,IAAI,CAAC,CAACwC,MAAM,CAACxC,IAAI,CAAC,CAAC,CAAC;IACxB;IACA,IAAI,IAAI,CAAC,CAACuC,KAAK,EAAE;MACb,IAAI,CAAC,CAACA,KAAK,CAACvC,IAAI,CAAC,CAAC,CAAC;IACvB;IACA,IAAI,CAAC,CAACmC,IAAI,GAAG,CAAC;IACd,IAAI,CAAC,CAACC,IAAI,GAAG,CAAC;IACd,IAAI,CAAC,CAACC,IAAI,CAAClC,MAAM,GAAG,CAAC;IACrB,IAAI,CAAC,CAAC0B,cAAc,GAAG,CAAC;IACxB,IAAI,CAAC,CAAC9B,IAAI,GAAG,CAAC;IACd,IAAI,IAAI,CAAC,CAAC6C,eAAe,IAAI,IAAI,CAAC,CAACN,QAAQ,EAAE;MACzC,MAAMwF,EAAE,GAAG,IAAI,CAAC,CAACxF,QAAQ;MACzB,IAAIyF,IAAI;MACR,OAAQA,IAAI,GAAGD,EAAE,EAAEE,KAAK,EAAE,EAAG;QACzB,IAAI,CAAC,CAACpH,YAAY,GAAG,GAAGmH,IAAI,CAAC;MACjC;IACJ;EACJ;AACJ;AACAxL,OAAO,CAACE,QAAQ,GAAGA,QAAQ"},"metadata":{},"sourceType":"script","externalDependencies":[]}