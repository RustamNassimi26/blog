{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"I:/Angular/angular-blog/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst {\n  Walker: IgnoreWalker\n} = require('ignore-walk');\nconst {\n  lstatSync: lstat,\n  readFileSync: readFile\n} = require('fs');\nconst {\n  basename,\n  dirname,\n  extname,\n  join,\n  relative,\n  resolve,\n  sep\n} = require('path');\n\n// symbols used to represent synthetic rule sets\nconst defaultRules = Symbol('npm-packlist.rules.default');\nconst strictRules = Symbol('npm-packlist.rules.strict');\n\n// There may be others, but :?|<> are handled by node-tar\nconst nameIsBadForWindows = file => /\\*/.test(file);\n\n// these are the default rules that are applied to everything except for non-link bundled deps\nconst defaults = ['.npmignore', '.gitignore', '**/.git', '**/.svn', '**/.hg', '**/CVS', '**/.git/**', '**/.svn/**', '**/.hg/**', '**/CVS/**', '/.lock-wscript', '/.wafpickle-*', '/build/config.gypi', 'npm-debug.log', '**/.npmrc', '.*.swp', '.DS_Store', '**/.DS_Store/**', '._*', '**/._*/**', '*.orig', '/archived-packages/**'];\nconst strictDefaults = [\n// these are forcibly included at all levels\n'!/readme{,.*[^~$]}', '!/copying{,.*[^~$]}', '!/license{,.*[^~$]}', '!/licence{,.*[^~$]}',\n// these are forcibly excluded\n'/.git'];\nconst normalizePath = path => path.split('\\\\').join('/');\nconst readOutOfTreeIgnoreFiles = (root, rel, result = []) => {\n  for (const file of ['.npmignore', '.gitignore']) {\n    try {\n      const ignoreContent = readFile(join(root, file), {\n        encoding: 'utf8'\n      });\n      result.push(ignoreContent);\n      // break the loop immediately after reading, this allows us to prioritize\n      // the .npmignore and discard the .gitignore if one is present\n      break;\n    } catch (err) {\n      // we ignore ENOENT errors completely because we don't care if the file doesn't exist\n      // but we throw everything else because failing to read a file that does exist is\n      // something that the user likely wants to know about\n      // istanbul ignore next -- we do not need to test a thrown error\n      if (err.code !== 'ENOENT') {\n        throw err;\n      }\n    }\n  }\n  if (!rel) {\n    return result;\n  }\n  const firstRel = rel.split(sep, 1)[0];\n  const newRoot = join(root, firstRel);\n  const newRel = relative(newRoot, join(root, rel));\n  return readOutOfTreeIgnoreFiles(newRoot, newRel, result);\n};\nclass PackWalker extends IgnoreWalker {\n  constructor(tree, opts) {\n    const options = {\n      ...opts,\n      includeEmpty: false,\n      follow: false,\n      // we path.resolve() here because ignore-walk doesn't do it and we want full paths\n      path: resolve(opts?.path || tree.path).replace(/\\\\/g, '/'),\n      ignoreFiles: opts?.ignoreFiles || [defaultRules, 'package.json', '.npmignore', '.gitignore', strictRules]\n    };\n    super(options);\n    this.isPackage = options.isPackage;\n    this.seen = options.seen || new Set();\n    this.tree = tree;\n    this.requiredFiles = options.requiredFiles || [];\n    const additionalDefaults = [];\n    if (options.prefix && options.workspaces) {\n      const path = normalizePath(options.path);\n      const prefix = normalizePath(options.prefix);\n      const workspaces = options.workspaces.map(ws => normalizePath(ws));\n\n      // istanbul ignore else - this does nothing unless we need it to\n      if (path !== prefix && workspaces.includes(path)) {\n        // if path and prefix are not the same directory, and workspaces has path in it\n        // then we know path is a workspace directory. in order to not drop ignore rules\n        // from directories between the workspaces root (prefix) and the workspace itself\n        // (path) we need to find and read those now\n        const relpath = relative(options.prefix, dirname(options.path));\n        additionalDefaults.push(...readOutOfTreeIgnoreFiles(options.prefix, relpath));\n      } else if (path === prefix) {\n        // on the other hand, if the path and prefix are the same, then we ignore workspaces\n        // so that we don't pack a workspace as part of the root project. append them as\n        // normalized relative paths from the root\n        additionalDefaults.push(...workspaces.map(w => normalizePath(relative(options.path, w))));\n      }\n    }\n\n    // go ahead and inject the default rules now\n    this.injectRules(defaultRules, [...defaults, ...additionalDefaults]);\n    if (!this.isPackage) {\n      // if this instance is not a package, then place some strict default rules, and append\n      // known required files for this directory\n      this.injectRules(strictRules, [...strictDefaults, ...this.requiredFiles.map(file => `!${file}`)]);\n    }\n  }\n\n  // overridden method: we intercept the reading of the package.json file here so that we can\n  // process it into both the package.json file rules as well as the strictRules synthetic rule set\n  addIgnoreFile(file, callback) {\n    // if we're adding anything other than package.json, then let ignore-walk handle it\n    if (file !== 'package.json' || !this.isPackage) {\n      return super.addIgnoreFile(file, callback);\n    }\n    return this.processPackage(callback);\n  }\n\n  // overridden method: if we're done, but we're a package, then we also need to evaluate bundles\n  // before we actually emit our done event\n  emit(ev, data) {\n    if (ev !== 'done' || !this.isPackage) {\n      return super.emit(ev, data);\n    }\n\n    // we intentionally delay the done event while keeping the function sync here\n    // eslint-disable-next-line promise/catch-or-return, promise/always-return\n    this.gatherBundles().then(() => {\n      super.emit('done', this.result);\n    });\n    return true;\n  }\n\n  // overridden method: before actually filtering, we make sure that we've removed the rules for\n  // files that should no longer take effect due to our order of precedence\n  filterEntries() {\n    if (this.ignoreRules['package.json']) {\n      // package.json means no .npmignore or .gitignore\n      this.ignoreRules['.npmignore'] = null;\n      this.ignoreRules['.gitignore'] = null;\n    } else if (this.ignoreRules['.npmignore']) {\n      // .npmignore means no .gitignore\n      this.ignoreRules['.gitignore'] = null;\n    }\n    return super.filterEntries();\n  }\n\n  // overridden method: we never want to include anything that isn't a file or directory\n  onstat(opts, callback) {\n    if (!opts.st.isFile() && !opts.st.isDirectory()) {\n      return callback();\n    }\n    return super.onstat(opts, callback);\n  }\n\n  // overridden method: we want to refuse to pack files that are invalid, node-tar protects us from\n  // a lot of them but not all\n  stat(opts, callback) {\n    if (nameIsBadForWindows(opts.entry)) {\n      return callback();\n    }\n    return super.stat(opts, callback);\n  }\n\n  // overridden method: this is called to create options for a child walker when we step\n  // in to a normal child directory (this will never be a bundle). the default method here\n  // copies the root's `ignoreFiles` value, but we don't want to respect package.json for\n  // subdirectories, so we override it with a list that intentionally omits package.json\n  walkerOpt(entry, opts) {\n    let ignoreFiles = null;\n\n    // however, if we have a tree, and we have workspaces, and the directory we're about\n    // to step into is a workspace, then we _do_ want to respect its package.json\n    if (this.tree.workspaces) {\n      const workspaceDirs = [...this.tree.workspaces.values()].map(dir => dir.replace(/\\\\/g, '/'));\n      const entryPath = join(this.path, entry).replace(/\\\\/g, '/');\n      if (workspaceDirs.includes(entryPath)) {\n        ignoreFiles = [defaultRules, 'package.json', '.npmignore', '.gitignore', strictRules];\n      }\n    } else {\n      ignoreFiles = [defaultRules, '.npmignore', '.gitignore', strictRules];\n    }\n    return {\n      ...super.walkerOpt(entry, opts),\n      ignoreFiles,\n      // we map over our own requiredFiles and pass ones that are within this entry\n      requiredFiles: this.requiredFiles.map(file => {\n        if (relative(file, entry) === '..') {\n          return relative(entry, file).replace(/\\\\/g, '/');\n        }\n        return false;\n      }).filter(Boolean)\n    };\n  }\n\n  // overridden method: we want child walkers to be instances of this class, not ignore-walk\n  walker(entry, opts, callback) {\n    new PackWalker(this.tree, this.walkerOpt(entry, opts)).on('done', callback).start();\n  }\n\n  // overridden method: we use a custom sort method to help compressibility\n  sort(a, b) {\n    // optimize for compressibility\n    // extname, then basename, then locale alphabetically\n    // https://twitter.com/isntitvacant/status/1131094910923231232\n    const exta = extname(a).toLowerCase();\n    const extb = extname(b).toLowerCase();\n    const basea = basename(a).toLowerCase();\n    const baseb = basename(b).toLowerCase();\n    return exta.localeCompare(extb, 'en') || basea.localeCompare(baseb, 'en') || a.localeCompare(b, 'en');\n  }\n\n  // convenience method: this joins the given rules with newlines, appends a trailing newline,\n  // and calls the internal onReadIgnoreFile method\n  injectRules(filename, rules, callback = () => {}) {\n    this.onReadIgnoreFile(filename, `${rules.join('\\n')}\\n`, callback);\n  }\n\n  // custom method: this is called by addIgnoreFile when we find a package.json, it uses the\n  // arborist tree to pull both default rules and strict rules for the package\n  processPackage(callback) {\n    const {\n      bin,\n      browser,\n      files,\n      main\n    } = this.tree.package;\n\n    // rules in these arrays are inverted since they are patterns we want to _not_ ignore\n    const ignores = [];\n    const strict = [...strictDefaults, '!/package.json', '/.git', '/node_modules', '/package-lock.json', '/yarn.lock', '/pnpm-lock.yaml'];\n\n    // if we have a files array in our package, we need to pull rules from it\n    if (files) {\n      for (let file of files) {\n        // invert the rule because these are things we want to include\n        if (file.startsWith('/')) {\n          file = file.slice(1);\n        } else if (file.startsWith('./')) {\n          file = file.slice(2);\n        } else if (file.endsWith('/*')) {\n          file = file.slice(0, -2);\n        }\n        const inverse = `!${file}`;\n        try {\n          // if an entry in the files array is a specific file, then we need to include it as a\n          // strict requirement for this package. if it's a directory or a pattern, it's a default\n          // pattern instead. this is ugly, but we have to stat to find out if it's a file\n          const stat = lstat(join(this.path, file.replace(/^!+/, '')).replace(/\\\\/g, '/'));\n          // if we have a file and we know that, it's strictly required\n          if (stat.isFile()) {\n            strict.unshift(inverse);\n            this.requiredFiles.push(file);\n          } else if (stat.isDirectory()) {\n            // otherwise, it's a default ignore, and since we got here we know it's not a pattern\n            // so we include the directory contents\n            ignores.push(inverse);\n            ignores.push(`${inverse}/**`);\n          }\n          // if the thing exists, but is neither a file or a directory, we don't want it at all\n        } catch (err) {\n          // if lstat throws, then we assume we're looking at a pattern and treat it as a default\n          ignores.push(inverse);\n        }\n      }\n\n      // we prepend a '*' to exclude everything, followed by our inverted file rules\n      // which now mean to include those\n      this.injectRules('package.json', ['*', ...ignores]);\n    }\n\n    // browser is required\n    if (browser) {\n      strict.push(`!/${browser}`);\n    }\n\n    // main is required\n    if (main) {\n      strict.push(`!/${main}`);\n    }\n\n    // each bin is required\n    if (bin) {\n      for (const key in bin) {\n        strict.push(`!/${bin[key]}`);\n      }\n    }\n\n    // and now we add all of the strict rules to our synthetic file\n    this.injectRules(strictRules, strict, callback);\n  }\n\n  // custom method: after we've finished gathering the files for the root package, we call this\n  // before emitting the 'done' event in order to gather all of the files for bundled deps\n  gatherBundles() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (_this.seen.has(_this.tree)) {\n        return;\n      }\n\n      // add this node to our seen tracker\n      _this.seen.add(_this.tree);\n\n      // if we're the project root, then we look at our bundleDependencies, otherwise we got here\n      // because we're a bundled dependency of the root, which means we need to include all prod\n      // and optional dependencies in the bundle\n      let toBundle;\n      if (_this.tree.isProjectRoot) {\n        const {\n          bundleDependencies\n        } = _this.tree.package;\n        toBundle = bundleDependencies || [];\n      } else {\n        const {\n          dependencies,\n          optionalDependencies\n        } = _this.tree.package;\n        toBundle = Object.keys(dependencies || {}).concat(Object.keys(optionalDependencies || {}));\n      }\n      for (const dep of toBundle) {\n        const edge = _this.tree.edgesOut.get(dep);\n        // no edgeOut = missing node, so skip it. we can't pack it if it's not here\n        // we also refuse to pack peer dependencies and dev dependencies\n        if (!edge || edge.peer || edge.dev) {\n          continue;\n        }\n\n        // get a reference to the node we're bundling\n        const node = _this.tree.edgesOut.get(dep).to;\n        // if there's no node, this is most likely an optional dependency that hasn't been\n        // installed. just skip it.\n        if (!node) {\n          continue;\n        }\n        // we use node.path for the path because we want the location the node was linked to,\n        // not where it actually lives on disk\n        const path = node.path;\n        // but link nodes don't have edgesOut, so we need to pass in the target of the node\n        // in order to make sure we correctly traverse its dependencies\n        const tree = node.target;\n\n        // and start building options to be passed to the walker for this package\n        const walkerOpts = {\n          path,\n          isPackage: true,\n          ignoreFiles: [],\n          seen: _this.seen // pass through seen so we can prevent infinite circular loops\n        };\n\n        // if our node is a link, we apply defaultRules. we don't do this for regular bundled\n        // deps because their .npmignore and .gitignore files are excluded by default and may\n        // override defaults\n        if (node.isLink) {\n          walkerOpts.ignoreFiles.push(defaultRules);\n        }\n\n        // _all_ nodes will follow package.json rules from their package root\n        walkerOpts.ignoreFiles.push('package.json');\n\n        // only link nodes will obey .npmignore or .gitignore\n        if (node.isLink) {\n          walkerOpts.ignoreFiles.push('.npmignore');\n          walkerOpts.ignoreFiles.push('.gitignore');\n        }\n\n        // _all_ nodes follow strict rules\n        walkerOpts.ignoreFiles.push(strictRules);\n\n        // create a walker for this dependency and gather its results\n        const walker = new PackWalker(tree, walkerOpts);\n        const bundled = yield new Promise((pResolve, pReject) => {\n          walker.on('error', pReject);\n          walker.on('done', pResolve);\n          walker.start();\n        });\n\n        // now we make sure we have our paths correct from the root, and accumulate everything into\n        // our own result set to deduplicate\n        const relativeFrom = relative(_this.root, walker.path);\n        for (const file of bundled) {\n          _this.result.add(join(relativeFrom, file).replace(/\\\\/g, '/'));\n        }\n      }\n    })();\n  }\n}\nconst walk = (tree, options, callback) => {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  const p = new Promise((pResolve, pReject) => {\n    new PackWalker(tree, {\n      ...options,\n      isPackage: true\n    }).on('done', pResolve).on('error', pReject).start();\n  });\n  return callback ? p.then(res => callback(null, res), callback) : p;\n};\nmodule.exports = walk;\nwalk.Walker = PackWalker;","map":{"version":3,"names":["Walker","IgnoreWalker","require","lstatSync","lstat","readFileSync","readFile","basename","dirname","extname","join","relative","resolve","sep","defaultRules","Symbol","strictRules","nameIsBadForWindows","file","test","defaults","strictDefaults","normalizePath","path","split","readOutOfTreeIgnoreFiles","root","rel","result","ignoreContent","encoding","push","err","code","firstRel","newRoot","newRel","PackWalker","constructor","tree","opts","options","includeEmpty","follow","replace","ignoreFiles","isPackage","seen","Set","requiredFiles","additionalDefaults","prefix","workspaces","map","ws","includes","relpath","w","injectRules","addIgnoreFile","callback","processPackage","emit","ev","data","gatherBundles","then","filterEntries","ignoreRules","onstat","st","isFile","isDirectory","stat","entry","walkerOpt","workspaceDirs","values","dir","entryPath","filter","Boolean","walker","on","start","sort","a","b","exta","toLowerCase","extb","basea","baseb","localeCompare","filename","rules","onReadIgnoreFile","bin","browser","files","main","package","ignores","strict","startsWith","slice","endsWith","inverse","unshift","key","has","add","toBundle","isProjectRoot","bundleDependencies","dependencies","optionalDependencies","Object","keys","concat","dep","edge","edgesOut","get","peer","dev","node","to","target","walkerOpts","isLink","bundled","Promise","pResolve","pReject","relativeFrom","walk","p","res","module","exports"],"sources":["I:/Angular/angular-blog/node_modules/npm-packlist/lib/index.js"],"sourcesContent":["'use strict'\n\nconst { Walker: IgnoreWalker } = require('ignore-walk')\nconst { lstatSync: lstat, readFileSync: readFile } = require('fs')\nconst { basename, dirname, extname, join, relative, resolve, sep } = require('path')\n\n// symbols used to represent synthetic rule sets\nconst defaultRules = Symbol('npm-packlist.rules.default')\nconst strictRules = Symbol('npm-packlist.rules.strict')\n\n// There may be others, but :?|<> are handled by node-tar\nconst nameIsBadForWindows = file => /\\*/.test(file)\n\n// these are the default rules that are applied to everything except for non-link bundled deps\nconst defaults = [\n  '.npmignore',\n  '.gitignore',\n  '**/.git',\n  '**/.svn',\n  '**/.hg',\n  '**/CVS',\n  '**/.git/**',\n  '**/.svn/**',\n  '**/.hg/**',\n  '**/CVS/**',\n  '/.lock-wscript',\n  '/.wafpickle-*',\n  '/build/config.gypi',\n  'npm-debug.log',\n  '**/.npmrc',\n  '.*.swp',\n  '.DS_Store',\n  '**/.DS_Store/**',\n  '._*',\n  '**/._*/**',\n  '*.orig',\n  '/archived-packages/**',\n]\n\nconst strictDefaults = [\n  // these are forcibly included at all levels\n  '!/readme{,.*[^~$]}',\n  '!/copying{,.*[^~$]}',\n  '!/license{,.*[^~$]}',\n  '!/licence{,.*[^~$]}',\n  // these are forcibly excluded\n  '/.git',\n]\n\nconst normalizePath = (path) => path.split('\\\\').join('/')\n\nconst readOutOfTreeIgnoreFiles = (root, rel, result = []) => {\n  for (const file of ['.npmignore', '.gitignore']) {\n    try {\n      const ignoreContent = readFile(join(root, file), { encoding: 'utf8' })\n      result.push(ignoreContent)\n      // break the loop immediately after reading, this allows us to prioritize\n      // the .npmignore and discard the .gitignore if one is present\n      break\n    } catch (err) {\n      // we ignore ENOENT errors completely because we don't care if the file doesn't exist\n      // but we throw everything else because failing to read a file that does exist is\n      // something that the user likely wants to know about\n      // istanbul ignore next -- we do not need to test a thrown error\n      if (err.code !== 'ENOENT') {\n        throw err\n      }\n    }\n  }\n\n  if (!rel) {\n    return result\n  }\n\n  const firstRel = rel.split(sep, 1)[0]\n  const newRoot = join(root, firstRel)\n  const newRel = relative(newRoot, join(root, rel))\n\n  return readOutOfTreeIgnoreFiles(newRoot, newRel, result)\n}\n\nclass PackWalker extends IgnoreWalker {\n  constructor (tree, opts) {\n    const options = {\n      ...opts,\n      includeEmpty: false,\n      follow: false,\n      // we path.resolve() here because ignore-walk doesn't do it and we want full paths\n      path: resolve(opts?.path || tree.path).replace(/\\\\/g, '/'),\n      ignoreFiles: opts?.ignoreFiles || [\n        defaultRules,\n        'package.json',\n        '.npmignore',\n        '.gitignore',\n        strictRules,\n      ],\n    }\n\n    super(options)\n    this.isPackage = options.isPackage\n    this.seen = options.seen || new Set()\n    this.tree = tree\n    this.requiredFiles = options.requiredFiles || []\n\n    const additionalDefaults = []\n    if (options.prefix && options.workspaces) {\n      const path = normalizePath(options.path)\n      const prefix = normalizePath(options.prefix)\n      const workspaces = options.workspaces.map((ws) => normalizePath(ws))\n\n      // istanbul ignore else - this does nothing unless we need it to\n      if (path !== prefix && workspaces.includes(path)) {\n        // if path and prefix are not the same directory, and workspaces has path in it\n        // then we know path is a workspace directory. in order to not drop ignore rules\n        // from directories between the workspaces root (prefix) and the workspace itself\n        // (path) we need to find and read those now\n        const relpath = relative(options.prefix, dirname(options.path))\n        additionalDefaults.push(...readOutOfTreeIgnoreFiles(options.prefix, relpath))\n      } else if (path === prefix) {\n        // on the other hand, if the path and prefix are the same, then we ignore workspaces\n        // so that we don't pack a workspace as part of the root project. append them as\n        // normalized relative paths from the root\n        additionalDefaults.push(...workspaces.map((w) => normalizePath(relative(options.path, w))))\n      }\n    }\n\n    // go ahead and inject the default rules now\n    this.injectRules(defaultRules, [...defaults, ...additionalDefaults])\n\n    if (!this.isPackage) {\n      // if this instance is not a package, then place some strict default rules, and append\n      // known required files for this directory\n      this.injectRules(strictRules, [\n        ...strictDefaults,\n        ...this.requiredFiles.map((file) => `!${file}`),\n      ])\n    }\n  }\n\n  // overridden method: we intercept the reading of the package.json file here so that we can\n  // process it into both the package.json file rules as well as the strictRules synthetic rule set\n  addIgnoreFile (file, callback) {\n    // if we're adding anything other than package.json, then let ignore-walk handle it\n    if (file !== 'package.json' || !this.isPackage) {\n      return super.addIgnoreFile(file, callback)\n    }\n\n    return this.processPackage(callback)\n  }\n\n  // overridden method: if we're done, but we're a package, then we also need to evaluate bundles\n  // before we actually emit our done event\n  emit (ev, data) {\n    if (ev !== 'done' || !this.isPackage) {\n      return super.emit(ev, data)\n    }\n\n    // we intentionally delay the done event while keeping the function sync here\n    // eslint-disable-next-line promise/catch-or-return, promise/always-return\n    this.gatherBundles().then(() => {\n      super.emit('done', this.result)\n    })\n    return true\n  }\n\n  // overridden method: before actually filtering, we make sure that we've removed the rules for\n  // files that should no longer take effect due to our order of precedence\n  filterEntries () {\n    if (this.ignoreRules['package.json']) {\n      // package.json means no .npmignore or .gitignore\n      this.ignoreRules['.npmignore'] = null\n      this.ignoreRules['.gitignore'] = null\n    } else if (this.ignoreRules['.npmignore']) {\n      // .npmignore means no .gitignore\n      this.ignoreRules['.gitignore'] = null\n    }\n\n    return super.filterEntries()\n  }\n\n  // overridden method: we never want to include anything that isn't a file or directory\n  onstat (opts, callback) {\n    if (!opts.st.isFile() && !opts.st.isDirectory()) {\n      return callback()\n    }\n\n    return super.onstat(opts, callback)\n  }\n\n  // overridden method: we want to refuse to pack files that are invalid, node-tar protects us from\n  // a lot of them but not all\n  stat (opts, callback) {\n    if (nameIsBadForWindows(opts.entry)) {\n      return callback()\n    }\n\n    return super.stat(opts, callback)\n  }\n\n  // overridden method: this is called to create options for a child walker when we step\n  // in to a normal child directory (this will never be a bundle). the default method here\n  // copies the root's `ignoreFiles` value, but we don't want to respect package.json for\n  // subdirectories, so we override it with a list that intentionally omits package.json\n  walkerOpt (entry, opts) {\n    let ignoreFiles = null\n\n    // however, if we have a tree, and we have workspaces, and the directory we're about\n    // to step into is a workspace, then we _do_ want to respect its package.json\n    if (this.tree.workspaces) {\n      const workspaceDirs = [...this.tree.workspaces.values()]\n        .map((dir) => dir.replace(/\\\\/g, '/'))\n\n      const entryPath = join(this.path, entry).replace(/\\\\/g, '/')\n      if (workspaceDirs.includes(entryPath)) {\n        ignoreFiles = [\n          defaultRules,\n          'package.json',\n          '.npmignore',\n          '.gitignore',\n          strictRules,\n        ]\n      }\n    } else {\n      ignoreFiles = [\n        defaultRules,\n        '.npmignore',\n        '.gitignore',\n        strictRules,\n      ]\n    }\n\n    return {\n      ...super.walkerOpt(entry, opts),\n      ignoreFiles,\n      // we map over our own requiredFiles and pass ones that are within this entry\n      requiredFiles: this.requiredFiles\n        .map((file) => {\n          if (relative(file, entry) === '..') {\n            return relative(entry, file).replace(/\\\\/g, '/')\n          }\n          return false\n        })\n        .filter(Boolean),\n    }\n  }\n\n  // overridden method: we want child walkers to be instances of this class, not ignore-walk\n  walker (entry, opts, callback) {\n    new PackWalker(this.tree, this.walkerOpt(entry, opts)).on('done', callback).start()\n  }\n\n  // overridden method: we use a custom sort method to help compressibility\n  sort (a, b) {\n    // optimize for compressibility\n    // extname, then basename, then locale alphabetically\n    // https://twitter.com/isntitvacant/status/1131094910923231232\n    const exta = extname(a).toLowerCase()\n    const extb = extname(b).toLowerCase()\n    const basea = basename(a).toLowerCase()\n    const baseb = basename(b).toLowerCase()\n\n    return exta.localeCompare(extb, 'en') ||\n      basea.localeCompare(baseb, 'en') ||\n      a.localeCompare(b, 'en')\n  }\n\n  // convenience method: this joins the given rules with newlines, appends a trailing newline,\n  // and calls the internal onReadIgnoreFile method\n  injectRules (filename, rules, callback = () => {}) {\n    this.onReadIgnoreFile(filename, `${rules.join('\\n')}\\n`, callback)\n  }\n\n  // custom method: this is called by addIgnoreFile when we find a package.json, it uses the\n  // arborist tree to pull both default rules and strict rules for the package\n  processPackage (callback) {\n    const {\n      bin,\n      browser,\n      files,\n      main,\n    } = this.tree.package\n\n    // rules in these arrays are inverted since they are patterns we want to _not_ ignore\n    const ignores = []\n    const strict = [\n      ...strictDefaults,\n      '!/package.json',\n      '/.git',\n      '/node_modules',\n      '/package-lock.json',\n      '/yarn.lock',\n      '/pnpm-lock.yaml',\n    ]\n\n    // if we have a files array in our package, we need to pull rules from it\n    if (files) {\n      for (let file of files) {\n        // invert the rule because these are things we want to include\n        if (file.startsWith('/')) {\n          file = file.slice(1)\n        } else if (file.startsWith('./')) {\n          file = file.slice(2)\n        } else if (file.endsWith('/*')) {\n          file = file.slice(0, -2)\n        }\n        const inverse = `!${file}`\n        try {\n          // if an entry in the files array is a specific file, then we need to include it as a\n          // strict requirement for this package. if it's a directory or a pattern, it's a default\n          // pattern instead. this is ugly, but we have to stat to find out if it's a file\n          const stat = lstat(join(this.path, file.replace(/^!+/, '')).replace(/\\\\/g, '/'))\n          // if we have a file and we know that, it's strictly required\n          if (stat.isFile()) {\n            strict.unshift(inverse)\n            this.requiredFiles.push(file)\n          } else if (stat.isDirectory()) {\n            // otherwise, it's a default ignore, and since we got here we know it's not a pattern\n            // so we include the directory contents\n            ignores.push(inverse)\n            ignores.push(`${inverse}/**`)\n          }\n          // if the thing exists, but is neither a file or a directory, we don't want it at all\n        } catch (err) {\n          // if lstat throws, then we assume we're looking at a pattern and treat it as a default\n          ignores.push(inverse)\n        }\n      }\n\n      // we prepend a '*' to exclude everything, followed by our inverted file rules\n      // which now mean to include those\n      this.injectRules('package.json', ['*', ...ignores])\n    }\n\n    // browser is required\n    if (browser) {\n      strict.push(`!/${browser}`)\n    }\n\n    // main is required\n    if (main) {\n      strict.push(`!/${main}`)\n    }\n\n    // each bin is required\n    if (bin) {\n      for (const key in bin) {\n        strict.push(`!/${bin[key]}`)\n      }\n    }\n\n    // and now we add all of the strict rules to our synthetic file\n    this.injectRules(strictRules, strict, callback)\n  }\n\n  // custom method: after we've finished gathering the files for the root package, we call this\n  // before emitting the 'done' event in order to gather all of the files for bundled deps\n  async gatherBundles () {\n    if (this.seen.has(this.tree)) {\n      return\n    }\n\n    // add this node to our seen tracker\n    this.seen.add(this.tree)\n\n    // if we're the project root, then we look at our bundleDependencies, otherwise we got here\n    // because we're a bundled dependency of the root, which means we need to include all prod\n    // and optional dependencies in the bundle\n    let toBundle\n    if (this.tree.isProjectRoot) {\n      const { bundleDependencies } = this.tree.package\n      toBundle = bundleDependencies || []\n    } else {\n      const { dependencies, optionalDependencies } = this.tree.package\n      toBundle = Object.keys(dependencies || {}).concat(Object.keys(optionalDependencies || {}))\n    }\n\n    for (const dep of toBundle) {\n      const edge = this.tree.edgesOut.get(dep)\n      // no edgeOut = missing node, so skip it. we can't pack it if it's not here\n      // we also refuse to pack peer dependencies and dev dependencies\n      if (!edge || edge.peer || edge.dev) {\n        continue\n      }\n\n      // get a reference to the node we're bundling\n      const node = this.tree.edgesOut.get(dep).to\n      // if there's no node, this is most likely an optional dependency that hasn't been\n      // installed. just skip it.\n      if (!node) {\n        continue\n      }\n      // we use node.path for the path because we want the location the node was linked to,\n      // not where it actually lives on disk\n      const path = node.path\n      // but link nodes don't have edgesOut, so we need to pass in the target of the node\n      // in order to make sure we correctly traverse its dependencies\n      const tree = node.target\n\n      // and start building options to be passed to the walker for this package\n      const walkerOpts = {\n        path,\n        isPackage: true,\n        ignoreFiles: [],\n        seen: this.seen, // pass through seen so we can prevent infinite circular loops\n      }\n\n      // if our node is a link, we apply defaultRules. we don't do this for regular bundled\n      // deps because their .npmignore and .gitignore files are excluded by default and may\n      // override defaults\n      if (node.isLink) {\n        walkerOpts.ignoreFiles.push(defaultRules)\n      }\n\n      // _all_ nodes will follow package.json rules from their package root\n      walkerOpts.ignoreFiles.push('package.json')\n\n      // only link nodes will obey .npmignore or .gitignore\n      if (node.isLink) {\n        walkerOpts.ignoreFiles.push('.npmignore')\n        walkerOpts.ignoreFiles.push('.gitignore')\n      }\n\n      // _all_ nodes follow strict rules\n      walkerOpts.ignoreFiles.push(strictRules)\n\n      // create a walker for this dependency and gather its results\n      const walker = new PackWalker(tree, walkerOpts)\n      const bundled = await new Promise((pResolve, pReject) => {\n        walker.on('error', pReject)\n        walker.on('done', pResolve)\n        walker.start()\n      })\n\n      // now we make sure we have our paths correct from the root, and accumulate everything into\n      // our own result set to deduplicate\n      const relativeFrom = relative(this.root, walker.path)\n      for (const file of bundled) {\n        this.result.add(join(relativeFrom, file).replace(/\\\\/g, '/'))\n      }\n    }\n  }\n}\n\nconst walk = (tree, options, callback) => {\n  if (typeof options === 'function') {\n    callback = options\n    options = {}\n  }\n  const p = new Promise((pResolve, pReject) => {\n    new PackWalker(tree, { ...options, isPackage: true })\n      .on('done', pResolve).on('error', pReject).start()\n  })\n  return callback ? p.then(res => callback(null, res), callback) : p\n}\n\nmodule.exports = walk\nwalk.Walker = PackWalker\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}