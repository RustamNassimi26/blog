{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;\nconst brace_expansion_1 = __importDefault(require(\"brace-expansion\"));\nconst assert_valid_pattern_js_1 = require(\"./assert-valid-pattern.js\");\nconst ast_js_1 = require(\"./ast.js\");\nconst escape_js_1 = require(\"./escape.js\");\nconst unescape_js_1 = require(\"./unescape.js\");\nconst minimatch = (p, pattern, options = {}) => {\n  (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false;\n  }\n  return new Minimatch(pattern, options).match(p);\n};\nexports.minimatch = minimatch;\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/;\nconst starDotExtTest = ext => f => !f.startsWith('.') && f.endsWith(ext);\nconst starDotExtTestDot = ext => f => f.endsWith(ext);\nconst starDotExtTestNocase = ext => {\n  ext = ext.toLowerCase();\n  return f => !f.startsWith('.') && f.toLowerCase().endsWith(ext);\n};\nconst starDotExtTestNocaseDot = ext => {\n  ext = ext.toLowerCase();\n  return f => f.toLowerCase().endsWith(ext);\n};\nconst starDotStarRE = /^\\*+\\.\\*+$/;\nconst starDotStarTest = f => !f.startsWith('.') && f.includes('.');\nconst starDotStarTestDot = f => f !== '.' && f !== '..' && f.includes('.');\nconst dotStarRE = /^\\.\\*+$/;\nconst dotStarTest = f => f !== '.' && f !== '..' && f.startsWith('.');\nconst starRE = /^\\*+$/;\nconst starTest = f => f.length !== 0 && !f.startsWith('.');\nconst starTestDot = f => f.length !== 0 && f !== '.' && f !== '..';\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/;\nconst qmarksTestNocase = ([$0, ext = '']) => {\n  const noext = qmarksTestNoExt([$0]);\n  if (!ext) return noext;\n  ext = ext.toLowerCase();\n  return f => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestNocaseDot = ([$0, ext = '']) => {\n  const noext = qmarksTestNoExtDot([$0]);\n  if (!ext) return noext;\n  ext = ext.toLowerCase();\n  return f => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestDot = ([$0, ext = '']) => {\n  const noext = qmarksTestNoExtDot([$0]);\n  return !ext ? noext : f => noext(f) && f.endsWith(ext);\n};\nconst qmarksTest = ([$0, ext = '']) => {\n  const noext = qmarksTestNoExt([$0]);\n  return !ext ? noext : f => noext(f) && f.endsWith(ext);\n};\nconst qmarksTestNoExt = ([$0]) => {\n  const len = $0.length;\n  return f => f.length === len && !f.startsWith('.');\n};\nconst qmarksTestNoExtDot = ([$0]) => {\n  const len = $0.length;\n  return f => f.length === len && f !== '.' && f !== '..';\n};\n/* c8 ignore start */\nconst defaultPlatform = typeof process === 'object' && process ? typeof process.env === 'object' && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : 'posix';\nconst path = {\n  win32: {\n    sep: '\\\\'\n  },\n  posix: {\n    sep: '/'\n  }\n};\n/* c8 ignore stop */\nexports.sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;\nexports.minimatch.sep = exports.sep;\nexports.GLOBSTAR = Symbol('globstar **');\nexports.minimatch.GLOBSTAR = exports.GLOBSTAR;\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?';\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?';\nconst filter = (pattern, options = {}) => p => (0, exports.minimatch)(p, pattern, options);\nexports.filter = filter;\nexports.minimatch.filter = exports.filter;\nconst ext = (a, b = {}) => Object.assign({}, a, b);\nconst defaults = def => {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return exports.minimatch;\n  }\n  const orig = exports.minimatch;\n  const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));\n  return Object.assign(m, {\n    Minimatch: class Minimatch extends orig.Minimatch {\n      constructor(pattern, options = {}) {\n        super(pattern, ext(def, options));\n      }\n      static defaults(options) {\n        return orig.defaults(ext(def, options)).Minimatch;\n      }\n    },\n    AST: class AST extends orig.AST {\n      /* c8 ignore start */\n      constructor(type, parent, options = {}) {\n        super(type, parent, ext(def, options));\n      }\n      /* c8 ignore stop */\n      static fromGlob(pattern, options = {}) {\n        return orig.AST.fromGlob(pattern, ext(def, options));\n      }\n    },\n    unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),\n    escape: (s, options = {}) => orig.escape(s, ext(def, options)),\n    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),\n    defaults: options => orig.defaults(ext(def, options)),\n    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),\n    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),\n    match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),\n    sep: orig.sep,\n    GLOBSTAR: exports.GLOBSTAR\n  });\n};\nexports.defaults = defaults;\nexports.minimatch.defaults = exports.defaults;\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nconst braceExpand = (pattern, options = {}) => {\n  (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern];\n  }\n  return (0, brace_expansion_1.default)(pattern);\n};\nexports.braceExpand = braceExpand;\nexports.minimatch.braceExpand = exports.braceExpand;\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nconst makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();\nexports.makeRe = makeRe;\nexports.minimatch.makeRe = exports.makeRe;\nconst match = (list, pattern, options = {}) => {\n  const mm = new Minimatch(pattern, options);\n  list = list.filter(f => mm.match(f));\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern);\n  }\n  return list;\n};\nexports.match = match;\nexports.minimatch.match = exports.match;\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/;\nconst regExpEscape = s => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\nclass Minimatch {\n  options;\n  set;\n  pattern;\n  windowsPathsNoEscape;\n  nonegate;\n  negate;\n  comment;\n  empty;\n  preserveMultipleSlashes;\n  partial;\n  globSet;\n  globParts;\n  nocase;\n  isWindows;\n  platform;\n  windowsNoMagicRoot;\n  regexp;\n  constructor(pattern, options = {}) {\n    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n    options = options || {};\n    this.options = options;\n    this.pattern = pattern;\n    this.platform = options.platform || defaultPlatform;\n    this.isWindows = this.platform === 'win32';\n    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n    if (this.windowsPathsNoEscape) {\n      this.pattern = this.pattern.replace(/\\\\/g, '/');\n    }\n    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;\n    this.regexp = null;\n    this.negate = false;\n    this.nonegate = !!options.nonegate;\n    this.comment = false;\n    this.empty = false;\n    this.partial = !!options.partial;\n    this.nocase = !!this.options.nocase;\n    this.windowsNoMagicRoot = options.windowsNoMagicRoot !== undefined ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);\n    this.globSet = [];\n    this.globParts = [];\n    this.set = [];\n    // make the set of regexps etc.\n    this.make();\n  }\n  hasMagic() {\n    if (this.options.magicalBraces && this.set.length > 1) {\n      return true;\n    }\n    for (const pattern of this.set) {\n      for (const part of pattern) {\n        if (typeof part !== 'string') return true;\n      }\n    }\n    return false;\n  }\n  debug(..._) {}\n  make() {\n    const pattern = this.pattern;\n    const options = this.options;\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true;\n      return;\n    }\n    if (!pattern) {\n      this.empty = true;\n      return;\n    }\n    // step 1: figure out negation, etc.\n    this.parseNegate();\n    // step 2: expand braces\n    this.globSet = [...new Set(this.braceExpand())];\n    if (options.debug) {\n      this.debug = (...args) => console.error(...args);\n    }\n    this.debug(this.pattern, this.globSet);\n    // step 3: now we have a set, so turn each one into a series of\n    // path-portion matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    //\n    // First, we preprocess to make the glob pattern sets a bit simpler\n    // and deduped.  There are some perf-killing patterns that can cause\n    // problems with a glob walk, but we can simplify them down a bit.\n    const rawGlobParts = this.globSet.map(s => this.slashSplit(s));\n    this.globParts = this.preprocess(rawGlobParts);\n    this.debug(this.pattern, this.globParts);\n    // glob --> regexps\n    let set = this.globParts.map((s, _, __) => {\n      if (this.isWindows && this.windowsNoMagicRoot) {\n        // check if it's a drive or unc path.\n        const isUNC = s[0] === '' && s[1] === '' && (s[2] === '?' || !globMagic.test(s[2])) && !globMagic.test(s[3]);\n        const isDrive = /^[a-z]:/i.test(s[0]);\n        if (isUNC) {\n          return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];\n        } else if (isDrive) {\n          return [s[0], ...s.slice(1).map(ss => this.parse(ss))];\n        }\n      }\n      return s.map(ss => this.parse(ss));\n    });\n    this.debug(this.pattern, set);\n    // filter out everything that didn't compile properly.\n    this.set = set.filter(s => s.indexOf(false) === -1);\n    // do not treat the ? in UNC paths as magic\n    if (this.isWindows) {\n      for (let i = 0; i < this.set.length; i++) {\n        const p = this.set[i];\n        if (p[0] === '' && p[1] === '' && this.globParts[i][2] === '?' && typeof p[3] === 'string' && /^[a-z]:$/i.test(p[3])) {\n          p[2] = '?';\n        }\n      }\n    }\n    this.debug(this.pattern, this.set);\n  }\n  // various transforms to equivalent pattern sets that are\n  // faster to process in a filesystem walk.  The goal is to\n  // eliminate what we can, and push all ** patterns as far\n  // to the right as possible, even if it increases the number\n  // of patterns that we have to process.\n  preprocess(globParts) {\n    // if we're not in globstar mode, then turn all ** into *\n    if (this.options.noglobstar) {\n      for (let i = 0; i < globParts.length; i++) {\n        for (let j = 0; j < globParts[i].length; j++) {\n          if (globParts[i][j] === '**') {\n            globParts[i][j] = '*';\n          }\n        }\n      }\n    }\n    const {\n      optimizationLevel = 1\n    } = this.options;\n    if (optimizationLevel >= 2) {\n      // aggressive optimization for the purpose of fs walking\n      globParts = this.firstPhasePreProcess(globParts);\n      globParts = this.secondPhasePreProcess(globParts);\n    } else if (optimizationLevel >= 1) {\n      // just basic optimizations to remove some .. parts\n      globParts = this.levelOneOptimize(globParts);\n    } else {\n      globParts = this.adjascentGlobstarOptimize(globParts);\n    }\n    return globParts;\n  }\n  // just get rid of adjascent ** portions\n  adjascentGlobstarOptimize(globParts) {\n    return globParts.map(parts => {\n      let gs = -1;\n      while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n        let i = gs;\n        while (parts[i + 1] === '**') {\n          i++;\n        }\n        if (i !== gs) {\n          parts.splice(gs, i - gs);\n        }\n      }\n      return parts;\n    });\n  }\n  // get rid of adjascent ** and resolve .. portions\n  levelOneOptimize(globParts) {\n    return globParts.map(parts => {\n      parts = parts.reduce((set, part) => {\n        const prev = set[set.length - 1];\n        if (part === '**' && prev === '**') {\n          return set;\n        }\n        if (part === '..') {\n          if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n            set.pop();\n            return set;\n          }\n        }\n        set.push(part);\n        return set;\n      }, []);\n      return parts.length === 0 ? [''] : parts;\n    });\n  }\n  levelTwoFileOptimize(parts) {\n    if (!Array.isArray(parts)) {\n      parts = this.slashSplit(parts);\n    }\n    let didSomething = false;\n    do {\n      didSomething = false;\n      // <pre>/<e>/<rest> -> <pre>/<rest>\n      if (!this.preserveMultipleSlashes) {\n        for (let i = 1; i < parts.length - 1; i++) {\n          const p = parts[i];\n          // don't squeeze out UNC patterns\n          if (i === 1 && p === '' && parts[0] === '') continue;\n          if (p === '.' || p === '') {\n            didSomething = true;\n            parts.splice(i, 1);\n            i--;\n          }\n        }\n        if (parts[0] === '.' && parts.length === 2 && (parts[1] === '.' || parts[1] === '')) {\n          didSomething = true;\n          parts.pop();\n        }\n      }\n      // <pre>/<p>/../<rest> -> <pre>/<rest>\n      let dd = 0;\n      while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n        const p = parts[dd - 1];\n        if (p && p !== '.' && p !== '..' && p !== '**') {\n          didSomething = true;\n          parts.splice(dd - 1, 2);\n          dd -= 2;\n        }\n      }\n    } while (didSomething);\n    return parts.length === 0 ? [''] : parts;\n  }\n  // First phase: single-pattern processing\n  // <pre> is 1 or more portions\n  // <rest> is 1 or more portions\n  // <p> is any portion other than ., .., '', or **\n  // <e> is . or ''\n  //\n  // **/.. is *brutal* for filesystem walking performance, because\n  // it effectively resets the recursive walk each time it occurs,\n  // and ** cannot be reduced out by a .. pattern part like a regexp\n  // or most strings (other than .., ., and '') can be.\n  //\n  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n  // <pre>/<e>/<rest> -> <pre>/<rest>\n  // <pre>/<p>/../<rest> -> <pre>/<rest>\n  // **/**/<rest> -> **/<rest>\n  //\n  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n  // this WOULD be allowed if ** did follow symlinks, or * didn't\n  firstPhasePreProcess(globParts) {\n    let didSomething = false;\n    do {\n      didSomething = false;\n      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n      for (let parts of globParts) {\n        let gs = -1;\n        while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n          let gss = gs;\n          while (parts[gss + 1] === '**') {\n            // <pre>/**/**/<rest> -> <pre>/**/<rest>\n            gss++;\n          }\n          // eg, if gs is 2 and gss is 4, that means we have 3 **\n          // parts, and can remove 2 of them.\n          if (gss > gs) {\n            parts.splice(gs + 1, gss - gs);\n          }\n          let next = parts[gs + 1];\n          const p = parts[gs + 2];\n          const p2 = parts[gs + 3];\n          if (next !== '..') continue;\n          if (!p || p === '.' || p === '..' || !p2 || p2 === '.' || p2 === '..') {\n            continue;\n          }\n          didSomething = true;\n          // edit parts in place, and push the new one\n          parts.splice(gs, 1);\n          const other = parts.slice(0);\n          other[gs] = '**';\n          globParts.push(other);\n          gs--;\n        }\n        // <pre>/<e>/<rest> -> <pre>/<rest>\n        if (!this.preserveMultipleSlashes) {\n          for (let i = 1; i < parts.length - 1; i++) {\n            const p = parts[i];\n            // don't squeeze out UNC patterns\n            if (i === 1 && p === '' && parts[0] === '') continue;\n            if (p === '.' || p === '') {\n              didSomething = true;\n              parts.splice(i, 1);\n              i--;\n            }\n          }\n          if (parts[0] === '.' && parts.length === 2 && (parts[1] === '.' || parts[1] === '')) {\n            didSomething = true;\n            parts.pop();\n          }\n        }\n        // <pre>/<p>/../<rest> -> <pre>/<rest>\n        let dd = 0;\n        while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n          const p = parts[dd - 1];\n          if (p && p !== '.' && p !== '..' && p !== '**') {\n            didSomething = true;\n            const needDot = dd === 1 && parts[dd + 1] === '**';\n            const splin = needDot ? ['.'] : [];\n            parts.splice(dd - 1, 2, ...splin);\n            if (parts.length === 0) parts.push('');\n            dd -= 2;\n          }\n        }\n      }\n    } while (didSomething);\n    return globParts;\n  }\n  // second phase: multi-pattern dedupes\n  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n  //\n  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n  // ^-- not valid because ** doens't follow symlinks\n  secondPhasePreProcess(globParts) {\n    for (let i = 0; i < globParts.length - 1; i++) {\n      for (let j = i + 1; j < globParts.length; j++) {\n        const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);\n        if (!matched) continue;\n        globParts[i] = matched;\n        globParts[j] = [];\n      }\n    }\n    return globParts.filter(gs => gs.length);\n  }\n  partsMatch(a, b, emptyGSMatch = false) {\n    let ai = 0;\n    let bi = 0;\n    let result = [];\n    let which = '';\n    while (ai < a.length && bi < b.length) {\n      if (a[ai] === b[bi]) {\n        result.push(which === 'b' ? b[bi] : a[ai]);\n        ai++;\n        bi++;\n      } else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n        result.push(a[ai]);\n        ai++;\n      } else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n        result.push(b[bi]);\n        bi++;\n      } else if (a[ai] === '*' && b[bi] && (this.options.dot || !b[bi].startsWith('.')) && b[bi] !== '**') {\n        if (which === 'b') return false;\n        which = 'a';\n        result.push(a[ai]);\n        ai++;\n        bi++;\n      } else if (b[bi] === '*' && a[ai] && (this.options.dot || !a[ai].startsWith('.')) && a[ai] !== '**') {\n        if (which === 'a') return false;\n        which = 'b';\n        result.push(b[bi]);\n        ai++;\n        bi++;\n      } else {\n        return false;\n      }\n    }\n    // if we fall out of the loop, it means they two are identical\n    // as long as their lengths match\n    return a.length === b.length && result;\n  }\n  parseNegate() {\n    if (this.nonegate) return;\n    const pattern = this.pattern;\n    let negate = false;\n    let negateOffset = 0;\n    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n      negate = !negate;\n      negateOffset++;\n    }\n    if (negateOffset) this.pattern = pattern.slice(negateOffset);\n    this.negate = negate;\n  }\n  // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n  matchOne(file, pattern, partial = false) {\n    const options = this.options;\n    // UNC paths like //?/X:/... can match X:/... and vice versa\n    // Drive letters in absolute drive or unc paths are always compared\n    // case-insensitively.\n    if (this.isWindows) {\n      const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);\n      const fileUNC = !fileDrive && file[0] === '' && file[1] === '' && file[2] === '?' && /^[a-z]:$/i.test(file[3]);\n      const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);\n      const patternUNC = !patternDrive && pattern[0] === '' && pattern[1] === '' && pattern[2] === '?' && typeof pattern[3] === 'string' && /^[a-z]:$/i.test(pattern[3]);\n      const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;\n      const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;\n      if (typeof fdi === 'number' && typeof pdi === 'number') {\n        const [fd, pd] = [file[fdi], pattern[pdi]];\n        if (fd.toLowerCase() === pd.toLowerCase()) {\n          pattern[pdi] = fd;\n          if (pdi > fdi) {\n            pattern = pattern.slice(pdi);\n          } else if (fdi > pdi) {\n            file = file.slice(fdi);\n          }\n        }\n      }\n    }\n    // resolve and reduce . and .. portions in the file as well.\n    // dont' need to do the second phase, because it's only one string[]\n    const {\n      optimizationLevel = 1\n    } = this.options;\n    if (optimizationLevel >= 2) {\n      file = this.levelTwoFileOptimize(file);\n    }\n    this.debug('matchOne', this, {\n      file,\n      pattern\n    });\n    this.debug('matchOne', file.length, pattern.length);\n    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n      this.debug('matchOne loop');\n      var p = pattern[pi];\n      var f = file[fi];\n      this.debug(pattern, p, f);\n      // should be impossible.\n      // some invalid regexp stuff in the set.\n      /* c8 ignore start */\n      if (p === false) {\n        return false;\n      }\n      /* c8 ignore stop */\n      if (p === exports.GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f]);\n        // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n        var fr = fi;\n        var pr = pi + 1;\n        if (pr === pl) {\n          this.debug('** at the end');\n          // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n          for (; fi < fl; fi++) {\n            if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.') return false;\n          }\n          return true;\n        }\n        // ok, let's see if we can swallow whatever we can.\n        while (fr < fl) {\n          var swallowee = file[fr];\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n          // XXX remove this slice.  Just pass the start index.\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee);\n            // found a match.\n            return true;\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {\n              this.debug('dot detected!', file, fr, pattern, pr);\n              break;\n            }\n            // ** swallows a segment, and continue.\n            this.debug('globstar swallow a segment, and continue');\n            fr++;\n          }\n        }\n        // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        /* c8 ignore start */\n        if (partial) {\n          // ran out of file\n          this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n          if (fr === fl) {\n            return true;\n          }\n        }\n        /* c8 ignore stop */\n        return false;\n      }\n      // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n      let hit;\n      if (typeof p === 'string') {\n        hit = f === p;\n        this.debug('string match', p, f, hit);\n      } else {\n        hit = p.test(f);\n        this.debug('pattern match', p, f, hit);\n      }\n      if (!hit) return false;\n    }\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true;\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial;\n    } else if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return fi === fl - 1 && file[fi] === '';\n      /* c8 ignore start */\n    } else {\n      // should be unreachable.\n      throw new Error('wtf?');\n    }\n    /* c8 ignore stop */\n  }\n\n  braceExpand() {\n    return (0, exports.braceExpand)(this.pattern, this.options);\n  }\n  parse(pattern) {\n    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n    const options = this.options;\n    // shortcuts\n    if (pattern === '**') return exports.GLOBSTAR;\n    if (pattern === '') return '';\n    // far and away, the most common glob pattern parts are\n    // *, *.*, and *.<ext>  Add a fast check method for those.\n    let m;\n    let fastTest = null;\n    if (m = pattern.match(starRE)) {\n      fastTest = options.dot ? starTestDot : starTest;\n    } else if (m = pattern.match(starDotExtRE)) {\n      fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);\n    } else if (m = pattern.match(qmarksRE)) {\n      fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);\n    } else if (m = pattern.match(starDotStarRE)) {\n      fastTest = options.dot ? starDotStarTestDot : starDotStarTest;\n    } else if (m = pattern.match(dotStarRE)) {\n      fastTest = dotStarTest;\n    }\n    const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();\n    return fastTest ? Object.assign(re, {\n      test: fastTest\n    }) : re;\n  }\n  makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp;\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    const set = this.set;\n    if (!set.length) {\n      this.regexp = false;\n      return this.regexp;\n    }\n    const options = this.options;\n    const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;\n    const flags = new Set(options.nocase ? ['i'] : []);\n    // regexpify non-globstar patterns\n    // if ** is only item, then we just do one twoStar\n    // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n    // if ** is last, append (\\/twoStar|) to previous\n    // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n    // then filter out GLOBSTAR symbols\n    let re = set.map(pattern => {\n      const pp = pattern.map(p => {\n        if (p instanceof RegExp) {\n          for (const f of p.flags.split('')) flags.add(f);\n        }\n        return typeof p === 'string' ? regExpEscape(p) : p === exports.GLOBSTAR ? exports.GLOBSTAR : p._src;\n      });\n      pp.forEach((p, i) => {\n        const next = pp[i + 1];\n        const prev = pp[i - 1];\n        if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {\n          return;\n        }\n        if (prev === undefined) {\n          if (next !== undefined && next !== exports.GLOBSTAR) {\n            pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next;\n          } else {\n            pp[i] = twoStar;\n          }\n        } else if (next === undefined) {\n          pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?';\n        } else if (next !== exports.GLOBSTAR) {\n          pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next;\n          pp[i + 1] = exports.GLOBSTAR;\n        }\n      });\n      return pp.filter(p => p !== exports.GLOBSTAR).join('/');\n    }).join('|');\n    // need to wrap in parens if we had more than one thing with |,\n    // otherwise only the first will be anchored to ^ and the last to $\n    const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = '^' + open + re + close + '$';\n    // can match anything, as long as it's not this.\n    if (this.negate) re = '^(?!' + re + ').+$';\n    try {\n      this.regexp = new RegExp(re, [...flags].join(''));\n      /* c8 ignore start */\n    } catch (ex) {\n      // should be impossible\n      this.regexp = false;\n    }\n    /* c8 ignore stop */\n    return this.regexp;\n  }\n  slashSplit(p) {\n    // if p starts with // on windows, we preserve that\n    // so that UNC paths aren't broken.  Otherwise, any number of\n    // / characters are coalesced into one, unless\n    // preserveMultipleSlashes is set to true.\n    if (this.preserveMultipleSlashes) {\n      return p.split('/');\n    } else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n      // add an extra '' for the one we lose\n      return ['', ...p.split(/\\/+/)];\n    } else {\n      return p.split(/\\/+/);\n    }\n  }\n  match(f, partial = this.partial) {\n    this.debug('match', f, this.pattern);\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) {\n      return false;\n    }\n    if (this.empty) {\n      return f === '';\n    }\n    if (f === '/' && partial) {\n      return true;\n    }\n    const options = this.options;\n    // windows: need to use /, not \\\n    if (this.isWindows) {\n      f = f.split('\\\\').join('/');\n    }\n    // treat the test path as a set of pathparts.\n    const ff = this.slashSplit(f);\n    this.debug(this.pattern, 'split', ff);\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n    const set = this.set;\n    this.debug(this.pattern, 'set', set);\n    // Find the basename of the path by looking for the last non-empty segment\n    let filename = ff[ff.length - 1];\n    if (!filename) {\n      for (let i = ff.length - 2; !filename && i >= 0; i--) {\n        filename = ff[i];\n      }\n    }\n    for (let i = 0; i < set.length; i++) {\n      const pattern = set[i];\n      let file = ff;\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename];\n      }\n      const hit = this.matchOne(file, pattern, partial);\n      if (hit) {\n        if (options.flipNegate) {\n          return true;\n        }\n        return !this.negate;\n      }\n    }\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) {\n      return false;\n    }\n    return this.negate;\n  }\n  static defaults(def) {\n    return exports.minimatch.defaults(def).Minimatch;\n  }\n}\nexports.Minimatch = Minimatch;\n/* c8 ignore start */\nvar ast_js_2 = require(\"./ast.js\");\nObject.defineProperty(exports, \"AST\", {\n  enumerable: true,\n  get: function () {\n    return ast_js_2.AST;\n  }\n});\nvar escape_js_2 = require(\"./escape.js\");\nObject.defineProperty(exports, \"escape\", {\n  enumerable: true,\n  get: function () {\n    return escape_js_2.escape;\n  }\n});\nvar unescape_js_2 = require(\"./unescape.js\");\nObject.defineProperty(exports, \"unescape\", {\n  enumerable: true,\n  get: function () {\n    return unescape_js_2.unescape;\n  }\n});\n/* c8 ignore stop */\nexports.minimatch.AST = ast_js_1.AST;\nexports.minimatch.Minimatch = Minimatch;\nexports.minimatch.escape = escape_js_1.escape;\nexports.minimatch.unescape = unescape_js_1.unescape;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","unescape","escape","AST","Minimatch","match","makeRe","braceExpand","defaults","filter","GLOBSTAR","sep","minimatch","brace_expansion_1","require","assert_valid_pattern_js_1","ast_js_1","escape_js_1","unescape_js_1","p","pattern","options","assertValidPattern","nocomment","charAt","starDotExtRE","starDotExtTest","ext","f","startsWith","endsWith","starDotExtTestDot","starDotExtTestNocase","toLowerCase","starDotExtTestNocaseDot","starDotStarRE","starDotStarTest","includes","starDotStarTestDot","dotStarRE","dotStarTest","starRE","starTest","length","starTestDot","qmarksRE","qmarksTestNocase","$0","noext","qmarksTestNoExt","qmarksTestNocaseDot","qmarksTestNoExtDot","qmarksTestDot","qmarksTest","len","defaultPlatform","process","env","__MINIMATCH_TESTING_PLATFORM__","platform","path","win32","posix","Symbol","qmark","star","twoStarDot","twoStarNoDot","a","b","assign","def","keys","orig","m","constructor","type","parent","fromGlob","s","list","nobrace","test","default","mm","nonull","push","globMagic","regExpEscape","replace","set","windowsPathsNoEscape","nonegate","negate","comment","empty","preserveMultipleSlashes","partial","globSet","globParts","nocase","isWindows","windowsNoMagicRoot","regexp","allowWindowsEscape","undefined","make","hasMagic","magicalBraces","part","debug","_","parseNegate","Set","args","console","error","rawGlobParts","map","slashSplit","preprocess","__","isUNC","isDrive","slice","ss","parse","indexOf","i","noglobstar","j","optimizationLevel","firstPhasePreProcess","secondPhasePreProcess","levelOneOptimize","adjascentGlobstarOptimize","parts","gs","splice","reduce","prev","pop","levelTwoFileOptimize","Array","isArray","didSomething","dd","gss","next","p2","other","needDot","splin","matched","partsMatch","emptyGSMatch","ai","bi","result","which","dot","negateOffset","matchOne","file","fileDrive","fileUNC","patternDrive","patternUNC","fdi","pdi","fd","pd","fi","pi","fl","pl","fr","pr","swallowee","hit","Error","fastTest","re","toMMPattern","twoStar","flags","pp","RegExp","split","add","_src","forEach","join","open","close","ex","ff","filename","matchBase","flipNegate","ast_js_2","enumerable","get","escape_js_2","unescape_js_2"],"sources":["I:/Angular/angular-blog/node_modules/read-package-json/node_modules/minimatch/dist/cjs/index.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;\nconst brace_expansion_1 = __importDefault(require(\"brace-expansion\"));\nconst assert_valid_pattern_js_1 = require(\"./assert-valid-pattern.js\");\nconst ast_js_1 = require(\"./ast.js\");\nconst escape_js_1 = require(\"./escape.js\");\nconst unescape_js_1 = require(\"./unescape.js\");\nconst minimatch = (p, pattern, options = {}) => {\n    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n    // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n        return false;\n    }\n    return new Minimatch(pattern, options).match(p);\n};\nexports.minimatch = minimatch;\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/;\nconst starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);\nconst starDotExtTestDot = (ext) => (f) => f.endsWith(ext);\nconst starDotExtTestNocase = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);\n};\nconst starDotExtTestNocaseDot = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => f.toLowerCase().endsWith(ext);\n};\nconst starDotStarRE = /^\\*+\\.\\*+$/;\nconst starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');\nconst starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');\nconst dotStarRE = /^\\.\\*+$/;\nconst dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');\nconst starRE = /^\\*+$/;\nconst starTest = (f) => f.length !== 0 && !f.startsWith('.');\nconst starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/;\nconst qmarksTestNocase = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestNocaseDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTest = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTestNoExt = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && !f.startsWith('.');\n};\nconst qmarksTestNoExtDot = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && f !== '.' && f !== '..';\n};\n/* c8 ignore start */\nconst defaultPlatform = (typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n        process.platform\n    : 'posix');\nconst path = {\n    win32: { sep: '\\\\' },\n    posix: { sep: '/' },\n};\n/* c8 ignore stop */\nexports.sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;\nexports.minimatch.sep = exports.sep;\nexports.GLOBSTAR = Symbol('globstar **');\nexports.minimatch.GLOBSTAR = exports.GLOBSTAR;\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?';\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?';\nconst filter = (pattern, options = {}) => (p) => (0, exports.minimatch)(p, pattern, options);\nexports.filter = filter;\nexports.minimatch.filter = exports.filter;\nconst ext = (a, b = {}) => Object.assign({}, a, b);\nconst defaults = (def) => {\n    if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n        return exports.minimatch;\n    }\n    const orig = exports.minimatch;\n    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));\n    return Object.assign(m, {\n        Minimatch: class Minimatch extends orig.Minimatch {\n            constructor(pattern, options = {}) {\n                super(pattern, ext(def, options));\n            }\n            static defaults(options) {\n                return orig.defaults(ext(def, options)).Minimatch;\n            }\n        },\n        AST: class AST extends orig.AST {\n            /* c8 ignore start */\n            constructor(type, parent, options = {}) {\n                super(type, parent, ext(def, options));\n            }\n            /* c8 ignore stop */\n            static fromGlob(pattern, options = {}) {\n                return orig.AST.fromGlob(pattern, ext(def, options));\n            }\n        },\n        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),\n        escape: (s, options = {}) => orig.escape(s, ext(def, options)),\n        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),\n        defaults: (options) => orig.defaults(ext(def, options)),\n        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),\n        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),\n        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),\n        sep: orig.sep,\n        GLOBSTAR: exports.GLOBSTAR,\n    });\n};\nexports.defaults = defaults;\nexports.minimatch.defaults = exports.defaults;\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nconst braceExpand = (pattern, options = {}) => {\n    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n    // Thanks to Yeting Li <https://github.com/yetingli> for\n    // improving this regexp to avoid a ReDOS vulnerability.\n    if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n        // shortcut. no need to expand.\n        return [pattern];\n    }\n    return (0, brace_expansion_1.default)(pattern);\n};\nexports.braceExpand = braceExpand;\nexports.minimatch.braceExpand = exports.braceExpand;\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nconst makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();\nexports.makeRe = makeRe;\nexports.minimatch.makeRe = exports.makeRe;\nconst match = (list, pattern, options = {}) => {\n    const mm = new Minimatch(pattern, options);\n    list = list.filter(f => mm.match(f));\n    if (mm.options.nonull && !list.length) {\n        list.push(pattern);\n    }\n    return list;\n};\nexports.match = match;\nexports.minimatch.match = exports.match;\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/;\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\nclass Minimatch {\n    options;\n    set;\n    pattern;\n    windowsPathsNoEscape;\n    nonegate;\n    negate;\n    comment;\n    empty;\n    preserveMultipleSlashes;\n    partial;\n    globSet;\n    globParts;\n    nocase;\n    isWindows;\n    platform;\n    windowsNoMagicRoot;\n    regexp;\n    constructor(pattern, options = {}) {\n        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n        options = options || {};\n        this.options = options;\n        this.pattern = pattern;\n        this.platform = options.platform || defaultPlatform;\n        this.isWindows = this.platform === 'win32';\n        this.windowsPathsNoEscape =\n            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n        if (this.windowsPathsNoEscape) {\n            this.pattern = this.pattern.replace(/\\\\/g, '/');\n        }\n        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;\n        this.regexp = null;\n        this.negate = false;\n        this.nonegate = !!options.nonegate;\n        this.comment = false;\n        this.empty = false;\n        this.partial = !!options.partial;\n        this.nocase = !!this.options.nocase;\n        this.windowsNoMagicRoot =\n            options.windowsNoMagicRoot !== undefined\n                ? options.windowsNoMagicRoot\n                : !!(this.isWindows && this.nocase);\n        this.globSet = [];\n        this.globParts = [];\n        this.set = [];\n        // make the set of regexps etc.\n        this.make();\n    }\n    hasMagic() {\n        if (this.options.magicalBraces && this.set.length > 1) {\n            return true;\n        }\n        for (const pattern of this.set) {\n            for (const part of pattern) {\n                if (typeof part !== 'string')\n                    return true;\n            }\n        }\n        return false;\n    }\n    debug(..._) { }\n    make() {\n        const pattern = this.pattern;\n        const options = this.options;\n        // empty patterns and comments match nothing.\n        if (!options.nocomment && pattern.charAt(0) === '#') {\n            this.comment = true;\n            return;\n        }\n        if (!pattern) {\n            this.empty = true;\n            return;\n        }\n        // step 1: figure out negation, etc.\n        this.parseNegate();\n        // step 2: expand braces\n        this.globSet = [...new Set(this.braceExpand())];\n        if (options.debug) {\n            this.debug = (...args) => console.error(...args);\n        }\n        this.debug(this.pattern, this.globSet);\n        // step 3: now we have a set, so turn each one into a series of\n        // path-portion matching patterns.\n        // These will be regexps, except in the case of \"**\", which is\n        // set to the GLOBSTAR object for globstar behavior,\n        // and will not contain any / characters\n        //\n        // First, we preprocess to make the glob pattern sets a bit simpler\n        // and deduped.  There are some perf-killing patterns that can cause\n        // problems with a glob walk, but we can simplify them down a bit.\n        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));\n        this.globParts = this.preprocess(rawGlobParts);\n        this.debug(this.pattern, this.globParts);\n        // glob --> regexps\n        let set = this.globParts.map((s, _, __) => {\n            if (this.isWindows && this.windowsNoMagicRoot) {\n                // check if it's a drive or unc path.\n                const isUNC = s[0] === '' &&\n                    s[1] === '' &&\n                    (s[2] === '?' || !globMagic.test(s[2])) &&\n                    !globMagic.test(s[3]);\n                const isDrive = /^[a-z]:/i.test(s[0]);\n                if (isUNC) {\n                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];\n                }\n                else if (isDrive) {\n                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];\n                }\n            }\n            return s.map(ss => this.parse(ss));\n        });\n        this.debug(this.pattern, set);\n        // filter out everything that didn't compile properly.\n        this.set = set.filter(s => s.indexOf(false) === -1);\n        // do not treat the ? in UNC paths as magic\n        if (this.isWindows) {\n            for (let i = 0; i < this.set.length; i++) {\n                const p = this.set[i];\n                if (p[0] === '' &&\n                    p[1] === '' &&\n                    this.globParts[i][2] === '?' &&\n                    typeof p[3] === 'string' &&\n                    /^[a-z]:$/i.test(p[3])) {\n                    p[2] = '?';\n                }\n            }\n        }\n        this.debug(this.pattern, this.set);\n    }\n    // various transforms to equivalent pattern sets that are\n    // faster to process in a filesystem walk.  The goal is to\n    // eliminate what we can, and push all ** patterns as far\n    // to the right as possible, even if it increases the number\n    // of patterns that we have to process.\n    preprocess(globParts) {\n        // if we're not in globstar mode, then turn all ** into *\n        if (this.options.noglobstar) {\n            for (let i = 0; i < globParts.length; i++) {\n                for (let j = 0; j < globParts[i].length; j++) {\n                    if (globParts[i][j] === '**') {\n                        globParts[i][j] = '*';\n                    }\n                }\n            }\n        }\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            // aggressive optimization for the purpose of fs walking\n            globParts = this.firstPhasePreProcess(globParts);\n            globParts = this.secondPhasePreProcess(globParts);\n        }\n        else if (optimizationLevel >= 1) {\n            // just basic optimizations to remove some .. parts\n            globParts = this.levelOneOptimize(globParts);\n        }\n        else {\n            globParts = this.adjascentGlobstarOptimize(globParts);\n        }\n        return globParts;\n    }\n    // just get rid of adjascent ** portions\n    adjascentGlobstarOptimize(globParts) {\n        return globParts.map(parts => {\n            let gs = -1;\n            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                let i = gs;\n                while (parts[i + 1] === '**') {\n                    i++;\n                }\n                if (i !== gs) {\n                    parts.splice(gs, i - gs);\n                }\n            }\n            return parts;\n        });\n    }\n    // get rid of adjascent ** and resolve .. portions\n    levelOneOptimize(globParts) {\n        return globParts.map(parts => {\n            parts = parts.reduce((set, part) => {\n                const prev = set[set.length - 1];\n                if (part === '**' && prev === '**') {\n                    return set;\n                }\n                if (part === '..') {\n                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n                        set.pop();\n                        return set;\n                    }\n                }\n                set.push(part);\n                return set;\n            }, []);\n            return parts.length === 0 ? [''] : parts;\n        });\n    }\n    levelTwoFileOptimize(parts) {\n        if (!Array.isArray(parts)) {\n            parts = this.slashSplit(parts);\n        }\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/<e>/<rest> -> <pre>/<rest>\n            if (!this.preserveMultipleSlashes) {\n                for (let i = 1; i < parts.length - 1; i++) {\n                    const p = parts[i];\n                    // don't squeeze out UNC patterns\n                    if (i === 1 && p === '' && parts[0] === '')\n                        continue;\n                    if (p === '.' || p === '') {\n                        didSomething = true;\n                        parts.splice(i, 1);\n                        i--;\n                    }\n                }\n                if (parts[0] === '.' &&\n                    parts.length === 2 &&\n                    (parts[1] === '.' || parts[1] === '')) {\n                    didSomething = true;\n                    parts.pop();\n                }\n            }\n            // <pre>/<p>/../<rest> -> <pre>/<rest>\n            let dd = 0;\n            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                const p = parts[dd - 1];\n                if (p && p !== '.' && p !== '..' && p !== '**') {\n                    didSomething = true;\n                    parts.splice(dd - 1, 2);\n                    dd -= 2;\n                }\n            }\n        } while (didSomething);\n        return parts.length === 0 ? [''] : parts;\n    }\n    // First phase: single-pattern processing\n    // <pre> is 1 or more portions\n    // <rest> is 1 or more portions\n    // <p> is any portion other than ., .., '', or **\n    // <e> is . or ''\n    //\n    // **/.. is *brutal* for filesystem walking performance, because\n    // it effectively resets the recursive walk each time it occurs,\n    // and ** cannot be reduced out by a .. pattern part like a regexp\n    // or most strings (other than .., ., and '') can be.\n    //\n    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n    // <pre>/<e>/<rest> -> <pre>/<rest>\n    // <pre>/<p>/../<rest> -> <pre>/<rest>\n    // **/**/<rest> -> **/<rest>\n    //\n    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n    // this WOULD be allowed if ** did follow symlinks, or * didn't\n    firstPhasePreProcess(globParts) {\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n            for (let parts of globParts) {\n                let gs = -1;\n                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                    let gss = gs;\n                    while (parts[gss + 1] === '**') {\n                        // <pre>/**/**/<rest> -> <pre>/**/<rest>\n                        gss++;\n                    }\n                    // eg, if gs is 2 and gss is 4, that means we have 3 **\n                    // parts, and can remove 2 of them.\n                    if (gss > gs) {\n                        parts.splice(gs + 1, gss - gs);\n                    }\n                    let next = parts[gs + 1];\n                    const p = parts[gs + 2];\n                    const p2 = parts[gs + 3];\n                    if (next !== '..')\n                        continue;\n                    if (!p ||\n                        p === '.' ||\n                        p === '..' ||\n                        !p2 ||\n                        p2 === '.' ||\n                        p2 === '..') {\n                        continue;\n                    }\n                    didSomething = true;\n                    // edit parts in place, and push the new one\n                    parts.splice(gs, 1);\n                    const other = parts.slice(0);\n                    other[gs] = '**';\n                    globParts.push(other);\n                    gs--;\n                }\n                // <pre>/<e>/<rest> -> <pre>/<rest>\n                if (!this.preserveMultipleSlashes) {\n                    for (let i = 1; i < parts.length - 1; i++) {\n                        const p = parts[i];\n                        // don't squeeze out UNC patterns\n                        if (i === 1 && p === '' && parts[0] === '')\n                            continue;\n                        if (p === '.' || p === '') {\n                            didSomething = true;\n                            parts.splice(i, 1);\n                            i--;\n                        }\n                    }\n                    if (parts[0] === '.' &&\n                        parts.length === 2 &&\n                        (parts[1] === '.' || parts[1] === '')) {\n                        didSomething = true;\n                        parts.pop();\n                    }\n                }\n                // <pre>/<p>/../<rest> -> <pre>/<rest>\n                let dd = 0;\n                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                    const p = parts[dd - 1];\n                    if (p && p !== '.' && p !== '..' && p !== '**') {\n                        didSomething = true;\n                        const needDot = dd === 1 && parts[dd + 1] === '**';\n                        const splin = needDot ? ['.'] : [];\n                        parts.splice(dd - 1, 2, ...splin);\n                        if (parts.length === 0)\n                            parts.push('');\n                        dd -= 2;\n                    }\n                }\n            }\n        } while (didSomething);\n        return globParts;\n    }\n    // second phase: multi-pattern dedupes\n    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n    //\n    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n    // ^-- not valid because ** doens't follow symlinks\n    secondPhasePreProcess(globParts) {\n        for (let i = 0; i < globParts.length - 1; i++) {\n            for (let j = i + 1; j < globParts.length; j++) {\n                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);\n                if (!matched)\n                    continue;\n                globParts[i] = matched;\n                globParts[j] = [];\n            }\n        }\n        return globParts.filter(gs => gs.length);\n    }\n    partsMatch(a, b, emptyGSMatch = false) {\n        let ai = 0;\n        let bi = 0;\n        let result = [];\n        let which = '';\n        while (ai < a.length && bi < b.length) {\n            if (a[ai] === b[bi]) {\n                result.push(which === 'b' ? b[bi] : a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n                result.push(a[ai]);\n                ai++;\n            }\n            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n                result.push(b[bi]);\n                bi++;\n            }\n            else if (a[ai] === '*' &&\n                b[bi] &&\n                (this.options.dot || !b[bi].startsWith('.')) &&\n                b[bi] !== '**') {\n                if (which === 'b')\n                    return false;\n                which = 'a';\n                result.push(a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (b[bi] === '*' &&\n                a[ai] &&\n                (this.options.dot || !a[ai].startsWith('.')) &&\n                a[ai] !== '**') {\n                if (which === 'a')\n                    return false;\n                which = 'b';\n                result.push(b[bi]);\n                ai++;\n                bi++;\n            }\n            else {\n                return false;\n            }\n        }\n        // if we fall out of the loop, it means they two are identical\n        // as long as their lengths match\n        return a.length === b.length && result;\n    }\n    parseNegate() {\n        if (this.nonegate)\n            return;\n        const pattern = this.pattern;\n        let negate = false;\n        let negateOffset = 0;\n        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n            negate = !negate;\n            negateOffset++;\n        }\n        if (negateOffset)\n            this.pattern = pattern.slice(negateOffset);\n        this.negate = negate;\n    }\n    // set partial to true to test if, for example,\n    // \"/a/b\" matches the start of \"/*/b/*/d\"\n    // Partial means, if you run out of file before you run\n    // out of pattern, then that's fine, as long as all\n    // the parts match.\n    matchOne(file, pattern, partial = false) {\n        const options = this.options;\n        // UNC paths like //?/X:/... can match X:/... and vice versa\n        // Drive letters in absolute drive or unc paths are always compared\n        // case-insensitively.\n        if (this.isWindows) {\n            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);\n            const fileUNC = !fileDrive &&\n                file[0] === '' &&\n                file[1] === '' &&\n                file[2] === '?' &&\n                /^[a-z]:$/i.test(file[3]);\n            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);\n            const patternUNC = !patternDrive &&\n                pattern[0] === '' &&\n                pattern[1] === '' &&\n                pattern[2] === '?' &&\n                typeof pattern[3] === 'string' &&\n                /^[a-z]:$/i.test(pattern[3]);\n            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;\n            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;\n            if (typeof fdi === 'number' && typeof pdi === 'number') {\n                const [fd, pd] = [file[fdi], pattern[pdi]];\n                if (fd.toLowerCase() === pd.toLowerCase()) {\n                    pattern[pdi] = fd;\n                    if (pdi > fdi) {\n                        pattern = pattern.slice(pdi);\n                    }\n                    else if (fdi > pdi) {\n                        file = file.slice(fdi);\n                    }\n                }\n            }\n        }\n        // resolve and reduce . and .. portions in the file as well.\n        // dont' need to do the second phase, because it's only one string[]\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            file = this.levelTwoFileOptimize(file);\n        }\n        this.debug('matchOne', this, { file, pattern });\n        this.debug('matchOne', file.length, pattern.length);\n        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n            this.debug('matchOne loop');\n            var p = pattern[pi];\n            var f = file[fi];\n            this.debug(pattern, p, f);\n            // should be impossible.\n            // some invalid regexp stuff in the set.\n            /* c8 ignore start */\n            if (p === false) {\n                return false;\n            }\n            /* c8 ignore stop */\n            if (p === exports.GLOBSTAR) {\n                this.debug('GLOBSTAR', [pattern, p, f]);\n                // \"**\"\n                // a/**/b/**/c would match the following:\n                // a/b/x/y/z/c\n                // a/x/y/z/b/c\n                // a/b/x/b/x/c\n                // a/b/c\n                // To do this, take the rest of the pattern after\n                // the **, and see if it would match the file remainder.\n                // If so, return success.\n                // If not, the ** \"swallows\" a segment, and try again.\n                // This is recursively awful.\n                //\n                // a/**/b/**/c matching a/b/x/y/z/c\n                // - a matches a\n                // - doublestar\n                //   - matchOne(b/x/y/z/c, b/**/c)\n                //     - b matches b\n                //     - doublestar\n                //       - matchOne(x/y/z/c, c) -> no\n                //       - matchOne(y/z/c, c) -> no\n                //       - matchOne(z/c, c) -> no\n                //       - matchOne(c, c) yes, hit\n                var fr = fi;\n                var pr = pi + 1;\n                if (pr === pl) {\n                    this.debug('** at the end');\n                    // a ** at the end will just swallow the rest.\n                    // We have found a match.\n                    // however, it will not swallow /.x, unless\n                    // options.dot is set.\n                    // . and .. are *never* matched by **, for explosively\n                    // exponential reasons.\n                    for (; fi < fl; fi++) {\n                        if (file[fi] === '.' ||\n                            file[fi] === '..' ||\n                            (!options.dot && file[fi].charAt(0) === '.'))\n                            return false;\n                    }\n                    return true;\n                }\n                // ok, let's see if we can swallow whatever we can.\n                while (fr < fl) {\n                    var swallowee = file[fr];\n                    this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n                    // XXX remove this slice.  Just pass the start index.\n                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                        this.debug('globstar found match!', fr, fl, swallowee);\n                        // found a match.\n                        return true;\n                    }\n                    else {\n                        // can't swallow \".\" or \"..\" ever.\n                        // can only swallow \".foo\" when explicitly asked.\n                        if (swallowee === '.' ||\n                            swallowee === '..' ||\n                            (!options.dot && swallowee.charAt(0) === '.')) {\n                            this.debug('dot detected!', file, fr, pattern, pr);\n                            break;\n                        }\n                        // ** swallows a segment, and continue.\n                        this.debug('globstar swallow a segment, and continue');\n                        fr++;\n                    }\n                }\n                // no match was found.\n                // However, in partial mode, we can't say this is necessarily over.\n                /* c8 ignore start */\n                if (partial) {\n                    // ran out of file\n                    this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n                    if (fr === fl) {\n                        return true;\n                    }\n                }\n                /* c8 ignore stop */\n                return false;\n            }\n            // something other than **\n            // non-magic patterns just have to match exactly\n            // patterns with magic have been turned into regexps.\n            let hit;\n            if (typeof p === 'string') {\n                hit = f === p;\n                this.debug('string match', p, f, hit);\n            }\n            else {\n                hit = p.test(f);\n                this.debug('pattern match', p, f, hit);\n            }\n            if (!hit)\n                return false;\n        }\n        // Note: ending in / means that we'll get a final \"\"\n        // at the end of the pattern.  This can only match a\n        // corresponding \"\" at the end of the file.\n        // If the file ends in /, then it can only match a\n        // a pattern that ends in /, unless the pattern just\n        // doesn't have any more for it. But, a/b/ should *not*\n        // match \"a/b/*\", even though \"\" matches against the\n        // [^/]*? pattern, except in partial mode, where it might\n        // simply not be reached yet.\n        // However, a/b/ should still satisfy a/*\n        // now either we fell off the end of the pattern, or we're done.\n        if (fi === fl && pi === pl) {\n            // ran out of pattern and filename at the same time.\n            // an exact hit!\n            return true;\n        }\n        else if (fi === fl) {\n            // ran out of file, but still had pattern left.\n            // this is ok if we're doing the match as part of\n            // a glob fs traversal.\n            return partial;\n        }\n        else if (pi === pl) {\n            // ran out of pattern, still have file left.\n            // this is only acceptable if we're on the very last\n            // empty segment of a file with a trailing slash.\n            // a/* should match a/b/\n            return fi === fl - 1 && file[fi] === '';\n            /* c8 ignore start */\n        }\n        else {\n            // should be unreachable.\n            throw new Error('wtf?');\n        }\n        /* c8 ignore stop */\n    }\n    braceExpand() {\n        return (0, exports.braceExpand)(this.pattern, this.options);\n    }\n    parse(pattern) {\n        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n        const options = this.options;\n        // shortcuts\n        if (pattern === '**')\n            return exports.GLOBSTAR;\n        if (pattern === '')\n            return '';\n        // far and away, the most common glob pattern parts are\n        // *, *.*, and *.<ext>  Add a fast check method for those.\n        let m;\n        let fastTest = null;\n        if ((m = pattern.match(starRE))) {\n            fastTest = options.dot ? starTestDot : starTest;\n        }\n        else if ((m = pattern.match(starDotExtRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? starDotExtTestNocaseDot\n                    : starDotExtTestNocase\n                : options.dot\n                    ? starDotExtTestDot\n                    : starDotExtTest)(m[1]);\n        }\n        else if ((m = pattern.match(qmarksRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? qmarksTestNocaseDot\n                    : qmarksTestNocase\n                : options.dot\n                    ? qmarksTestDot\n                    : qmarksTest)(m);\n        }\n        else if ((m = pattern.match(starDotStarRE))) {\n            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;\n        }\n        else if ((m = pattern.match(dotStarRE))) {\n            fastTest = dotStarTest;\n        }\n        const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();\n        return fastTest ? Object.assign(re, { test: fastTest }) : re;\n    }\n    makeRe() {\n        if (this.regexp || this.regexp === false)\n            return this.regexp;\n        // at this point, this.set is a 2d array of partial\n        // pattern strings, or \"**\".\n        //\n        // It's better to use .match().  This function shouldn't\n        // be used, really, but it's pretty convenient sometimes,\n        // when you just want to work with a regex.\n        const set = this.set;\n        if (!set.length) {\n            this.regexp = false;\n            return this.regexp;\n        }\n        const options = this.options;\n        const twoStar = options.noglobstar\n            ? star\n            : options.dot\n                ? twoStarDot\n                : twoStarNoDot;\n        const flags = new Set(options.nocase ? ['i'] : []);\n        // regexpify non-globstar patterns\n        // if ** is only item, then we just do one twoStar\n        // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n        // if ** is last, append (\\/twoStar|) to previous\n        // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n        // then filter out GLOBSTAR symbols\n        let re = set\n            .map(pattern => {\n            const pp = pattern.map(p => {\n                if (p instanceof RegExp) {\n                    for (const f of p.flags.split(''))\n                        flags.add(f);\n                }\n                return typeof p === 'string'\n                    ? regExpEscape(p)\n                    : p === exports.GLOBSTAR\n                        ? exports.GLOBSTAR\n                        : p._src;\n            });\n            pp.forEach((p, i) => {\n                const next = pp[i + 1];\n                const prev = pp[i - 1];\n                if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {\n                    return;\n                }\n                if (prev === undefined) {\n                    if (next !== undefined && next !== exports.GLOBSTAR) {\n                        pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next;\n                    }\n                    else {\n                        pp[i] = twoStar;\n                    }\n                }\n                else if (next === undefined) {\n                    pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?';\n                }\n                else if (next !== exports.GLOBSTAR) {\n                    pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next;\n                    pp[i + 1] = exports.GLOBSTAR;\n                }\n            });\n            return pp.filter(p => p !== exports.GLOBSTAR).join('/');\n        })\n            .join('|');\n        // need to wrap in parens if we had more than one thing with |,\n        // otherwise only the first will be anchored to ^ and the last to $\n        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];\n        // must match entire pattern\n        // ending in a * or ** will make it less strict.\n        re = '^' + open + re + close + '$';\n        // can match anything, as long as it's not this.\n        if (this.negate)\n            re = '^(?!' + re + ').+$';\n        try {\n            this.regexp = new RegExp(re, [...flags].join(''));\n            /* c8 ignore start */\n        }\n        catch (ex) {\n            // should be impossible\n            this.regexp = false;\n        }\n        /* c8 ignore stop */\n        return this.regexp;\n    }\n    slashSplit(p) {\n        // if p starts with // on windows, we preserve that\n        // so that UNC paths aren't broken.  Otherwise, any number of\n        // / characters are coalesced into one, unless\n        // preserveMultipleSlashes is set to true.\n        if (this.preserveMultipleSlashes) {\n            return p.split('/');\n        }\n        else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n            // add an extra '' for the one we lose\n            return ['', ...p.split(/\\/+/)];\n        }\n        else {\n            return p.split(/\\/+/);\n        }\n    }\n    match(f, partial = this.partial) {\n        this.debug('match', f, this.pattern);\n        // short-circuit in the case of busted things.\n        // comments, etc.\n        if (this.comment) {\n            return false;\n        }\n        if (this.empty) {\n            return f === '';\n        }\n        if (f === '/' && partial) {\n            return true;\n        }\n        const options = this.options;\n        // windows: need to use /, not \\\n        if (this.isWindows) {\n            f = f.split('\\\\').join('/');\n        }\n        // treat the test path as a set of pathparts.\n        const ff = this.slashSplit(f);\n        this.debug(this.pattern, 'split', ff);\n        // just ONE of the pattern sets in this.set needs to match\n        // in order for it to be valid.  If negating, then just one\n        // match means that we have failed.\n        // Either way, return on the first hit.\n        const set = this.set;\n        this.debug(this.pattern, 'set', set);\n        // Find the basename of the path by looking for the last non-empty segment\n        let filename = ff[ff.length - 1];\n        if (!filename) {\n            for (let i = ff.length - 2; !filename && i >= 0; i--) {\n                filename = ff[i];\n            }\n        }\n        for (let i = 0; i < set.length; i++) {\n            const pattern = set[i];\n            let file = ff;\n            if (options.matchBase && pattern.length === 1) {\n                file = [filename];\n            }\n            const hit = this.matchOne(file, pattern, partial);\n            if (hit) {\n                if (options.flipNegate) {\n                    return true;\n                }\n                return !this.negate;\n            }\n        }\n        // didn't get any hits.  this is success if it's a negative\n        // pattern, failure otherwise.\n        if (options.flipNegate) {\n            return false;\n        }\n        return this.negate;\n    }\n    static defaults(def) {\n        return exports.minimatch.defaults(def).Minimatch;\n    }\n}\nexports.Minimatch = Minimatch;\n/* c8 ignore start */\nvar ast_js_2 = require(\"./ast.js\");\nObject.defineProperty(exports, \"AST\", { enumerable: true, get: function () { return ast_js_2.AST; } });\nvar escape_js_2 = require(\"./escape.js\");\nObject.defineProperty(exports, \"escape\", { enumerable: true, get: function () { return escape_js_2.escape; } });\nvar unescape_js_2 = require(\"./unescape.js\");\nObject.defineProperty(exports, \"unescape\", { enumerable: true, get: function () { return unescape_js_2.unescape; } });\n/* c8 ignore stop */\nexports.minimatch.AST = ast_js_1.AST;\nexports.minimatch.Minimatch = Minimatch;\nexports.minimatch.escape = escape_js_1.escape;\nexports.minimatch.unescape = unescape_js_1.unescape;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}