{"ast":null,"code":"\"use strict\";\n\n// this is just a very light wrapper around 2 arrays with an offset index\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Pattern = void 0;\nconst minimatch_1 = require(\"minimatch\");\nconst isPatternList = pl => pl.length >= 1;\nconst isGlobList = gl => gl.length >= 1;\n/**\n * An immutable-ish view on an array of glob parts and their parsed\n * results\n */\nclass Pattern {\n  #patternList;\n  #globList;\n  #index;\n  length;\n  #platform;\n  #rest;\n  #globString;\n  #isDrive;\n  #isUNC;\n  #isAbsolute;\n  #followGlobstar = true;\n  constructor(patternList, globList, index, platform) {\n    if (!isPatternList(patternList)) {\n      throw new TypeError('empty pattern list');\n    }\n    if (!isGlobList(globList)) {\n      throw new TypeError('empty glob list');\n    }\n    if (globList.length !== patternList.length) {\n      throw new TypeError('mismatched pattern list and glob list lengths');\n    }\n    this.length = patternList.length;\n    if (index < 0 || index >= this.length) {\n      throw new TypeError('index out of range');\n    }\n    this.#patternList = patternList;\n    this.#globList = globList;\n    this.#index = index;\n    this.#platform = platform;\n    // normalize root entries of absolute patterns on initial creation.\n    if (this.#index === 0) {\n      // c: => ['c:/']\n      // C:/ => ['C:/']\n      // C:/x => ['C:/', 'x']\n      // //host/share => ['//host/share/']\n      // //host/share/ => ['//host/share/']\n      // //host/share/x => ['//host/share/', 'x']\n      // /etc => ['/', 'etc']\n      // / => ['/']\n      if (this.isUNC()) {\n        // '' / '' / 'host' / 'share'\n        const [p0, p1, p2, p3, ...prest] = this.#patternList;\n        const [g0, g1, g2, g3, ...grest] = this.#globList;\n        if (prest[0] === '') {\n          // ends in /\n          prest.shift();\n          grest.shift();\n        }\n        const p = [p0, p1, p2, p3, ''].join('/');\n        const g = [g0, g1, g2, g3, ''].join('/');\n        this.#patternList = [p, ...prest];\n        this.#globList = [g, ...grest];\n        this.length = this.#patternList.length;\n      } else if (this.isDrive() || this.isAbsolute()) {\n        const [p1, ...prest] = this.#patternList;\n        const [g1, ...grest] = this.#globList;\n        if (prest[0] === '') {\n          // ends in /\n          prest.shift();\n          grest.shift();\n        }\n        const p = p1 + '/';\n        const g = g1 + '/';\n        this.#patternList = [p, ...prest];\n        this.#globList = [g, ...grest];\n        this.length = this.#patternList.length;\n      }\n    }\n  }\n  /**\n   * The first entry in the parsed list of patterns\n   */\n  pattern() {\n    return this.#patternList[this.#index];\n  }\n  /**\n   * true of if pattern() returns a string\n   */\n  isString() {\n    return typeof this.#patternList[this.#index] === 'string';\n  }\n  /**\n   * true of if pattern() returns GLOBSTAR\n   */\n  isGlobstar() {\n    return this.#patternList[this.#index] === minimatch_1.GLOBSTAR;\n  }\n  /**\n   * true if pattern() returns a regexp\n   */\n  isRegExp() {\n    return this.#patternList[this.#index] instanceof RegExp;\n  }\n  /**\n   * The /-joined set of glob parts that make up this pattern\n   */\n  globString() {\n    return this.#globString = this.#globString || (this.#index === 0 ? this.isAbsolute() ? this.#globList[0] + this.#globList.slice(1).join('/') : this.#globList.join('/') : this.#globList.slice(this.#index).join('/'));\n  }\n  /**\n   * true if there are more pattern parts after this one\n   */\n  hasMore() {\n    return this.length > this.#index + 1;\n  }\n  /**\n   * The rest of the pattern after this part, or null if this is the end\n   */\n  rest() {\n    if (this.#rest !== undefined) return this.#rest;\n    if (!this.hasMore()) return this.#rest = null;\n    this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);\n    this.#rest.#isAbsolute = this.#isAbsolute;\n    this.#rest.#isUNC = this.#isUNC;\n    this.#rest.#isDrive = this.#isDrive;\n    return this.#rest;\n  }\n  /**\n   * true if the pattern represents a //unc/path/ on windows\n   */\n  isUNC() {\n    const pl = this.#patternList;\n    return this.#isUNC !== undefined ? this.#isUNC : this.#isUNC = this.#platform === 'win32' && this.#index === 0 && pl[0] === '' && pl[1] === '' && typeof pl[2] === 'string' && !!pl[2] && typeof pl[3] === 'string' && !!pl[3];\n  }\n  // pattern like C:/...\n  // split = ['C:', ...]\n  // XXX: would be nice to handle patterns like `c:*` to test the cwd\n  // in c: for *, but I don't know of a way to even figure out what that\n  // cwd is without actually chdir'ing into it?\n  /**\n   * True if the pattern starts with a drive letter on Windows\n   */\n  isDrive() {\n    const pl = this.#patternList;\n    return this.#isDrive !== undefined ? this.#isDrive : this.#isDrive = this.#platform === 'win32' && this.#index === 0 && this.length > 1 && typeof pl[0] === 'string' && /^[a-z]:$/i.test(pl[0]);\n  }\n  // pattern = '/' or '/...' or '/x/...'\n  // split = ['', ''] or ['', ...] or ['', 'x', ...]\n  // Drive and UNC both considered absolute on windows\n  /**\n   * True if the pattern is rooted on an absolute path\n   */\n  isAbsolute() {\n    const pl = this.#patternList;\n    return this.#isAbsolute !== undefined ? this.#isAbsolute : this.#isAbsolute = pl[0] === '' && pl.length > 1 || this.isDrive() || this.isUNC();\n  }\n  /**\n   * consume the root of the pattern, and return it\n   */\n  root() {\n    const p = this.#patternList[0];\n    return typeof p === 'string' && this.isAbsolute() && this.#index === 0 ? p : '';\n  }\n  /**\n   * Check to see if the current globstar pattern is allowed to follow\n   * a symbolic link.\n   */\n  checkFollowGlobstar() {\n    return !(this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar);\n  }\n  /**\n   * Mark that the current globstar pattern is following a symbolic link\n   */\n  markFollowGlobstar() {\n    if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar) return false;\n    this.#followGlobstar = false;\n    return true;\n  }\n}\nexports.Pattern = Pattern;","map":{"version":3,"names":["Object","defineProperty","exports","value","Pattern","minimatch_1","require","isPatternList","pl","length","isGlobList","gl","patternList","globList","index","platform","rest","globString","isDrive","isUNC","isAbsolute","followGlobstar","constructor","TypeError","p0","p1","p2","p3","prest","g0","g1","g2","g3","grest","shift","p","join","g","pattern","isString","isGlobstar","GLOBSTAR","isRegExp","RegExp","slice","hasMore","undefined","test","root","checkFollowGlobstar","markFollowGlobstar"],"sources":["I:/Angular/angular-blog/node_modules/read-package-json/node_modules/glob/dist/commonjs/pattern.js"],"sourcesContent":["\"use strict\";\n// this is just a very light wrapper around 2 arrays with an offset index\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Pattern = void 0;\nconst minimatch_1 = require(\"minimatch\");\nconst isPatternList = (pl) => pl.length >= 1;\nconst isGlobList = (gl) => gl.length >= 1;\n/**\n * An immutable-ish view on an array of glob parts and their parsed\n * results\n */\nclass Pattern {\n    #patternList;\n    #globList;\n    #index;\n    length;\n    #platform;\n    #rest;\n    #globString;\n    #isDrive;\n    #isUNC;\n    #isAbsolute;\n    #followGlobstar = true;\n    constructor(patternList, globList, index, platform) {\n        if (!isPatternList(patternList)) {\n            throw new TypeError('empty pattern list');\n        }\n        if (!isGlobList(globList)) {\n            throw new TypeError('empty glob list');\n        }\n        if (globList.length !== patternList.length) {\n            throw new TypeError('mismatched pattern list and glob list lengths');\n        }\n        this.length = patternList.length;\n        if (index < 0 || index >= this.length) {\n            throw new TypeError('index out of range');\n        }\n        this.#patternList = patternList;\n        this.#globList = globList;\n        this.#index = index;\n        this.#platform = platform;\n        // normalize root entries of absolute patterns on initial creation.\n        if (this.#index === 0) {\n            // c: => ['c:/']\n            // C:/ => ['C:/']\n            // C:/x => ['C:/', 'x']\n            // //host/share => ['//host/share/']\n            // //host/share/ => ['//host/share/']\n            // //host/share/x => ['//host/share/', 'x']\n            // /etc => ['/', 'etc']\n            // / => ['/']\n            if (this.isUNC()) {\n                // '' / '' / 'host' / 'share'\n                const [p0, p1, p2, p3, ...prest] = this.#patternList;\n                const [g0, g1, g2, g3, ...grest] = this.#globList;\n                if (prest[0] === '') {\n                    // ends in /\n                    prest.shift();\n                    grest.shift();\n                }\n                const p = [p0, p1, p2, p3, ''].join('/');\n                const g = [g0, g1, g2, g3, ''].join('/');\n                this.#patternList = [p, ...prest];\n                this.#globList = [g, ...grest];\n                this.length = this.#patternList.length;\n            }\n            else if (this.isDrive() || this.isAbsolute()) {\n                const [p1, ...prest] = this.#patternList;\n                const [g1, ...grest] = this.#globList;\n                if (prest[0] === '') {\n                    // ends in /\n                    prest.shift();\n                    grest.shift();\n                }\n                const p = p1 + '/';\n                const g = g1 + '/';\n                this.#patternList = [p, ...prest];\n                this.#globList = [g, ...grest];\n                this.length = this.#patternList.length;\n            }\n        }\n    }\n    /**\n     * The first entry in the parsed list of patterns\n     */\n    pattern() {\n        return this.#patternList[this.#index];\n    }\n    /**\n     * true of if pattern() returns a string\n     */\n    isString() {\n        return typeof this.#patternList[this.#index] === 'string';\n    }\n    /**\n     * true of if pattern() returns GLOBSTAR\n     */\n    isGlobstar() {\n        return this.#patternList[this.#index] === minimatch_1.GLOBSTAR;\n    }\n    /**\n     * true if pattern() returns a regexp\n     */\n    isRegExp() {\n        return this.#patternList[this.#index] instanceof RegExp;\n    }\n    /**\n     * The /-joined set of glob parts that make up this pattern\n     */\n    globString() {\n        return (this.#globString =\n            this.#globString ||\n                (this.#index === 0\n                    ? this.isAbsolute()\n                        ? this.#globList[0] + this.#globList.slice(1).join('/')\n                        : this.#globList.join('/')\n                    : this.#globList.slice(this.#index).join('/')));\n    }\n    /**\n     * true if there are more pattern parts after this one\n     */\n    hasMore() {\n        return this.length > this.#index + 1;\n    }\n    /**\n     * The rest of the pattern after this part, or null if this is the end\n     */\n    rest() {\n        if (this.#rest !== undefined)\n            return this.#rest;\n        if (!this.hasMore())\n            return (this.#rest = null);\n        this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);\n        this.#rest.#isAbsolute = this.#isAbsolute;\n        this.#rest.#isUNC = this.#isUNC;\n        this.#rest.#isDrive = this.#isDrive;\n        return this.#rest;\n    }\n    /**\n     * true if the pattern represents a //unc/path/ on windows\n     */\n    isUNC() {\n        const pl = this.#patternList;\n        return this.#isUNC !== undefined\n            ? this.#isUNC\n            : (this.#isUNC =\n                this.#platform === 'win32' &&\n                    this.#index === 0 &&\n                    pl[0] === '' &&\n                    pl[1] === '' &&\n                    typeof pl[2] === 'string' &&\n                    !!pl[2] &&\n                    typeof pl[3] === 'string' &&\n                    !!pl[3]);\n    }\n    // pattern like C:/...\n    // split = ['C:', ...]\n    // XXX: would be nice to handle patterns like `c:*` to test the cwd\n    // in c: for *, but I don't know of a way to even figure out what that\n    // cwd is without actually chdir'ing into it?\n    /**\n     * True if the pattern starts with a drive letter on Windows\n     */\n    isDrive() {\n        const pl = this.#patternList;\n        return this.#isDrive !== undefined\n            ? this.#isDrive\n            : (this.#isDrive =\n                this.#platform === 'win32' &&\n                    this.#index === 0 &&\n                    this.length > 1 &&\n                    typeof pl[0] === 'string' &&\n                    /^[a-z]:$/i.test(pl[0]));\n    }\n    // pattern = '/' or '/...' or '/x/...'\n    // split = ['', ''] or ['', ...] or ['', 'x', ...]\n    // Drive and UNC both considered absolute on windows\n    /**\n     * True if the pattern is rooted on an absolute path\n     */\n    isAbsolute() {\n        const pl = this.#patternList;\n        return this.#isAbsolute !== undefined\n            ? this.#isAbsolute\n            : (this.#isAbsolute =\n                (pl[0] === '' && pl.length > 1) ||\n                    this.isDrive() ||\n                    this.isUNC());\n    }\n    /**\n     * consume the root of the pattern, and return it\n     */\n    root() {\n        const p = this.#patternList[0];\n        return typeof p === 'string' && this.isAbsolute() && this.#index === 0\n            ? p\n            : '';\n    }\n    /**\n     * Check to see if the current globstar pattern is allowed to follow\n     * a symbolic link.\n     */\n    checkFollowGlobstar() {\n        return !(this.#index === 0 ||\n            !this.isGlobstar() ||\n            !this.#followGlobstar);\n    }\n    /**\n     * Mark that the current globstar pattern is following a symbolic link\n     */\n    markFollowGlobstar() {\n        if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)\n            return false;\n        this.#followGlobstar = false;\n        return true;\n    }\n}\nexports.Pattern = Pattern;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}