{"ast":null,"code":"var _asyncToGenerator = require(\"I:/Angular/angular-blog/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst Fetcher = require('./fetcher.js');\nconst RemoteFetcher = require('./remote.js');\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved');\nconst pacoteVersion = require('../package.json').version;\nconst removeTrailingSlashes = require('./util/trailing-slashes.js');\nconst rpj = require('read-package-json-fast');\nconst pickManifest = require('npm-pick-manifest');\nconst ssri = require('ssri');\nconst crypto = require('crypto');\n\n// Corgis are cute. üêïüê∂\nconst corgiDoc = 'application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*';\nconst fullDoc = 'application/json';\nconst fetch = require('npm-registry-fetch');\nconst _headers = Symbol('_headers');\nclass RegistryFetcher extends Fetcher {\n  constructor(spec, opts) {\n    super(spec, opts);\n\n    // you usually don't want to fetch the same packument multiple times in\n    // the span of a given script or command, no matter how many pacote calls\n    // are made, so this lets us avoid doing that.  It's only relevant for\n    // registry fetchers, because other types simulate their packument from\n    // the manifest, which they memoize on this.package, so it's very cheap\n    // already.\n    this.packumentCache = this.opts.packumentCache || null;\n    this.registry = fetch.pickRegistry(spec, opts);\n    this.packumentUrl = removeTrailingSlashes(this.registry) + '/' + this.spec.escapedName;\n    const parsed = new URL(this.registry);\n    const regKey = `//${parsed.host}${parsed.pathname}`;\n    // unlike the nerf-darted auth keys, this one does *not* allow a mismatch\n    // of trailing slashes.  It must match exactly.\n    if (this.opts[`${regKey}:_keys`]) {\n      this.registryKeys = this.opts[`${regKey}:_keys`];\n    }\n\n    // XXX pacote <=9 has some logic to ignore opts.resolved if\n    // the resolved URL doesn't go to the same registry.\n    // Consider reproducing that here, to throw away this.resolved\n    // in that case.\n  }\n\n  resolve() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // fetching the manifest sets resolved and (if present) integrity\n      yield _this.manifest();\n      if (!_this.resolved) {\n        throw Object.assign(new Error('Invalid package manifest: no `dist.tarball` field'), {\n          package: _this.spec.toString()\n        });\n      }\n      return _this.resolved;\n    })();\n  }\n  [_headers]() {\n    return {\n      // npm will override UA, but ensure that we always send *something*\n      'user-agent': this.opts.userAgent || `pacote/${pacoteVersion} node/${process.version}`,\n      ...(this.opts.headers || {}),\n      'pacote-version': pacoteVersion,\n      'pacote-req-type': 'packument',\n      'pacote-pkg-id': `registry:${this.spec.name}`,\n      accept: this.fullMetadata ? fullDoc : corgiDoc\n    };\n  }\n  packument() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      // note this might be either an in-flight promise for a request,\n      // or the actual packument, but we never want to make more than\n      // one request at a time for the same thing regardless.\n      if (_this2.packumentCache && _this2.packumentCache.has(_this2.packumentUrl)) {\n        return _this2.packumentCache.get(_this2.packumentUrl);\n      }\n\n      // npm-registry-fetch the packument\n      // set the appropriate header for corgis if fullMetadata isn't set\n      // return the res.json() promise\n      try {\n        const res = yield fetch(_this2.packumentUrl, {\n          ..._this2.opts,\n          headers: _this2[_headers](),\n          spec: _this2.spec,\n          // never check integrity for packuments themselves\n          integrity: null\n        });\n        const packument = yield res.json();\n        packument._contentLength = +res.headers.get('content-length');\n        if (_this2.packumentCache) {\n          _this2.packumentCache.set(_this2.packumentUrl, packument);\n        }\n        return packument;\n      } catch (err) {\n        if (_this2.packumentCache) {\n          _this2.packumentCache.delete(_this2.packumentUrl);\n        }\n        if (err.code !== 'E404' || _this2.fullMetadata) {\n          throw err;\n        }\n        // possible that corgis are not supported by this registry\n        _this2.fullMetadata = true;\n        return _this2.packument();\n      }\n    })();\n  }\n  manifest() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (_this3.package) {\n        return _this3.package;\n      }\n      const packument = yield _this3.packument();\n      let mani = yield pickManifest(packument, _this3.spec.fetchSpec, {\n        ..._this3.opts,\n        defaultTag: _this3.defaultTag,\n        before: _this3.before\n      });\n      mani = rpj.normalize(mani);\n      /* XXX add ETARGET and E403 revalidation of cached packuments here */\n\n      // add _resolved and _integrity from dist object\n      const {\n        dist\n      } = mani;\n      if (dist) {\n        _this3.resolved = mani._resolved = dist.tarball;\n        mani._from = _this3.from;\n        const distIntegrity = dist.integrity ? ssri.parse(dist.integrity) : dist.shasum ? ssri.fromHex(dist.shasum, 'sha1', {\n          ..._this3.opts\n        }) : null;\n        if (distIntegrity) {\n          if (_this3.integrity && !_this3.integrity.match(distIntegrity)) {\n            // only bork if they have algos in common.\n            // otherwise we end up breaking if we have saved a sha512\n            // previously for the tarball, but the manifest only\n            // provides a sha1, which is possible for older publishes.\n            // Otherwise, this is almost certainly a case of holding it\n            // wrong, and will result in weird or insecure behavior\n            // later on when building package tree.\n            for (const algo of Object.keys(_this3.integrity)) {\n              if (distIntegrity[algo]) {\n                throw Object.assign(new Error(`Integrity checksum failed when using ${algo}: ` + `wanted ${_this3.integrity} but got ${distIntegrity}.`), {\n                  code: 'EINTEGRITY'\n                });\n              }\n            }\n          }\n          // made it this far, the integrity is worthwhile.  accept it.\n          // the setter here will take care of merging it into what we already\n          // had.\n          _this3.integrity = distIntegrity;\n        }\n      }\n      if (_this3.integrity) {\n        mani._integrity = String(_this3.integrity);\n        if (dist.signatures) {\n          if (_this3.opts.verifySignatures) {\n            // validate and throw on error, then set _signatures\n            const message = `${mani._id}:${mani._integrity}`;\n            for (const signature of dist.signatures) {\n              const publicKey = _this3.registryKeys && _this3.registryKeys.filter(key => key.keyid === signature.keyid)[0];\n              if (!publicKey) {\n                throw Object.assign(new Error(`${mani._id} has a registry signature with keyid: ${signature.keyid} ` + 'but no corresponding public key can be found'), {\n                  code: 'EMISSINGSIGNATUREKEY'\n                });\n              }\n              const validPublicKey = !publicKey.expires || Date.parse(publicKey.expires) > Date.now();\n              if (!validPublicKey) {\n                throw Object.assign(new Error(`${mani._id} has a registry signature with keyid: ${signature.keyid} ` + `but the corresponding public key has expired ${publicKey.expires}`), {\n                  code: 'EEXPIREDSIGNATUREKEY'\n                });\n              }\n              const verifier = crypto.createVerify('SHA256');\n              verifier.write(message);\n              verifier.end();\n              const valid = verifier.verify(publicKey.pemkey, signature.sig, 'base64');\n              if (!valid) {\n                throw Object.assign(new Error(`${mani._id} has an invalid registry signature with ` + `keyid: ${publicKey.keyid} and signature: ${signature.sig}`), {\n                  code: 'EINTEGRITYSIGNATURE',\n                  keyid: publicKey.keyid,\n                  signature: signature.sig,\n                  resolved: mani._resolved,\n                  integrity: mani._integrity\n                });\n              }\n            }\n            mani._signatures = dist.signatures;\n          } else {\n            mani._signatures = dist.signatures;\n          }\n        }\n      }\n      _this3.package = mani;\n      return _this3.package;\n    })();\n  }\n  [_tarballFromResolved]() {\n    // we use a RemoteFetcher to get the actual tarball stream\n    return new RemoteFetcher(this.resolved, {\n      ...this.opts,\n      resolved: this.resolved,\n      pkgid: `registry:${this.spec.name}@${this.resolved}`\n    })[_tarballFromResolved]();\n  }\n  get types() {\n    return ['tag', 'version', 'range'];\n  }\n}\nmodule.exports = RegistryFetcher;","map":{"version":3,"names":["Fetcher","require","RemoteFetcher","_tarballFromResolved","Symbol","for","pacoteVersion","version","removeTrailingSlashes","rpj","pickManifest","ssri","crypto","corgiDoc","fullDoc","fetch","_headers","RegistryFetcher","constructor","spec","opts","packumentCache","registry","pickRegistry","packumentUrl","escapedName","parsed","URL","regKey","host","pathname","registryKeys","resolve","manifest","resolved","Object","assign","Error","package","toString","userAgent","process","headers","name","accept","fullMetadata","packument","has","get","res","integrity","json","_contentLength","set","err","delete","code","mani","fetchSpec","defaultTag","before","normalize","dist","_resolved","tarball","_from","from","distIntegrity","parse","shasum","fromHex","match","algo","keys","_integrity","String","signatures","verifySignatures","message","_id","signature","publicKey","filter","key","keyid","validPublicKey","expires","Date","now","verifier","createVerify","write","end","valid","verify","pemkey","sig","_signatures","pkgid","types","module","exports"],"sources":["I:/Angular/angular-blog/node_modules/pacote/lib/registry.js"],"sourcesContent":["const Fetcher = require('./fetcher.js')\nconst RemoteFetcher = require('./remote.js')\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved')\nconst pacoteVersion = require('../package.json').version\nconst removeTrailingSlashes = require('./util/trailing-slashes.js')\nconst rpj = require('read-package-json-fast')\nconst pickManifest = require('npm-pick-manifest')\nconst ssri = require('ssri')\nconst crypto = require('crypto')\n\n// Corgis are cute. üêïüê∂\nconst corgiDoc = 'application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*'\nconst fullDoc = 'application/json'\n\nconst fetch = require('npm-registry-fetch')\n\nconst _headers = Symbol('_headers')\nclass RegistryFetcher extends Fetcher {\n  constructor (spec, opts) {\n    super(spec, opts)\n\n    // you usually don't want to fetch the same packument multiple times in\n    // the span of a given script or command, no matter how many pacote calls\n    // are made, so this lets us avoid doing that.  It's only relevant for\n    // registry fetchers, because other types simulate their packument from\n    // the manifest, which they memoize on this.package, so it's very cheap\n    // already.\n    this.packumentCache = this.opts.packumentCache || null\n\n    this.registry = fetch.pickRegistry(spec, opts)\n    this.packumentUrl = removeTrailingSlashes(this.registry) + '/' +\n      this.spec.escapedName\n\n    const parsed = new URL(this.registry)\n    const regKey = `//${parsed.host}${parsed.pathname}`\n    // unlike the nerf-darted auth keys, this one does *not* allow a mismatch\n    // of trailing slashes.  It must match exactly.\n    if (this.opts[`${regKey}:_keys`]) {\n      this.registryKeys = this.opts[`${regKey}:_keys`]\n    }\n\n    // XXX pacote <=9 has some logic to ignore opts.resolved if\n    // the resolved URL doesn't go to the same registry.\n    // Consider reproducing that here, to throw away this.resolved\n    // in that case.\n  }\n\n  async resolve () {\n    // fetching the manifest sets resolved and (if present) integrity\n    await this.manifest()\n    if (!this.resolved) {\n      throw Object.assign(\n        new Error('Invalid package manifest: no `dist.tarball` field'),\n        { package: this.spec.toString() }\n      )\n    }\n    return this.resolved\n  }\n\n  [_headers] () {\n    return {\n      // npm will override UA, but ensure that we always send *something*\n      'user-agent': this.opts.userAgent ||\n        `pacote/${pacoteVersion} node/${process.version}`,\n      ...(this.opts.headers || {}),\n      'pacote-version': pacoteVersion,\n      'pacote-req-type': 'packument',\n      'pacote-pkg-id': `registry:${this.spec.name}`,\n      accept: this.fullMetadata ? fullDoc : corgiDoc,\n    }\n  }\n\n  async packument () {\n    // note this might be either an in-flight promise for a request,\n    // or the actual packument, but we never want to make more than\n    // one request at a time for the same thing regardless.\n    if (this.packumentCache && this.packumentCache.has(this.packumentUrl)) {\n      return this.packumentCache.get(this.packumentUrl)\n    }\n\n    // npm-registry-fetch the packument\n    // set the appropriate header for corgis if fullMetadata isn't set\n    // return the res.json() promise\n    try {\n      const res = await fetch(this.packumentUrl, {\n        ...this.opts,\n        headers: this[_headers](),\n        spec: this.spec,\n        // never check integrity for packuments themselves\n        integrity: null,\n      })\n      const packument = await res.json()\n      packument._contentLength = +res.headers.get('content-length')\n      if (this.packumentCache) {\n        this.packumentCache.set(this.packumentUrl, packument)\n      }\n      return packument\n    } catch (err) {\n      if (this.packumentCache) {\n        this.packumentCache.delete(this.packumentUrl)\n      }\n      if (err.code !== 'E404' || this.fullMetadata) {\n        throw err\n      }\n      // possible that corgis are not supported by this registry\n      this.fullMetadata = true\n      return this.packument()\n    }\n  }\n\n  async manifest () {\n    if (this.package) {\n      return this.package\n    }\n\n    const packument = await this.packument()\n    let mani = await pickManifest(packument, this.spec.fetchSpec, {\n      ...this.opts,\n      defaultTag: this.defaultTag,\n      before: this.before,\n    })\n    mani = rpj.normalize(mani)\n    /* XXX add ETARGET and E403 revalidation of cached packuments here */\n\n    // add _resolved and _integrity from dist object\n    const { dist } = mani\n    if (dist) {\n      this.resolved = mani._resolved = dist.tarball\n      mani._from = this.from\n      const distIntegrity = dist.integrity ? ssri.parse(dist.integrity)\n        : dist.shasum ? ssri.fromHex(dist.shasum, 'sha1', { ...this.opts })\n        : null\n      if (distIntegrity) {\n        if (this.integrity && !this.integrity.match(distIntegrity)) {\n          // only bork if they have algos in common.\n          // otherwise we end up breaking if we have saved a sha512\n          // previously for the tarball, but the manifest only\n          // provides a sha1, which is possible for older publishes.\n          // Otherwise, this is almost certainly a case of holding it\n          // wrong, and will result in weird or insecure behavior\n          // later on when building package tree.\n          for (const algo of Object.keys(this.integrity)) {\n            if (distIntegrity[algo]) {\n              throw Object.assign(new Error(\n                `Integrity checksum failed when using ${algo}: ` +\n                `wanted ${this.integrity} but got ${distIntegrity}.`\n              ), { code: 'EINTEGRITY' })\n            }\n          }\n        }\n        // made it this far, the integrity is worthwhile.  accept it.\n        // the setter here will take care of merging it into what we already\n        // had.\n        this.integrity = distIntegrity\n      }\n    }\n    if (this.integrity) {\n      mani._integrity = String(this.integrity)\n      if (dist.signatures) {\n        if (this.opts.verifySignatures) {\n          // validate and throw on error, then set _signatures\n          const message = `${mani._id}:${mani._integrity}`\n          for (const signature of dist.signatures) {\n            const publicKey = this.registryKeys &&\n              this.registryKeys.filter(key => (key.keyid === signature.keyid))[0]\n            if (!publicKey) {\n              throw Object.assign(new Error(\n                  `${mani._id} has a registry signature with keyid: ${signature.keyid} ` +\n                  'but no corresponding public key can be found'\n              ), { code: 'EMISSINGSIGNATUREKEY' })\n            }\n            const validPublicKey =\n              !publicKey.expires || (Date.parse(publicKey.expires) > Date.now())\n            if (!validPublicKey) {\n              throw Object.assign(new Error(\n                  `${mani._id} has a registry signature with keyid: ${signature.keyid} ` +\n                  `but the corresponding public key has expired ${publicKey.expires}`\n              ), { code: 'EEXPIREDSIGNATUREKEY' })\n            }\n            const verifier = crypto.createVerify('SHA256')\n            verifier.write(message)\n            verifier.end()\n            const valid = verifier.verify(\n              publicKey.pemkey,\n              signature.sig,\n              'base64'\n            )\n            if (!valid) {\n              throw Object.assign(new Error(\n                  `${mani._id} has an invalid registry signature with ` +\n                  `keyid: ${publicKey.keyid} and signature: ${signature.sig}`\n              ), {\n                code: 'EINTEGRITYSIGNATURE',\n                keyid: publicKey.keyid,\n                signature: signature.sig,\n                resolved: mani._resolved,\n                integrity: mani._integrity,\n              })\n            }\n          }\n          mani._signatures = dist.signatures\n        } else {\n          mani._signatures = dist.signatures\n        }\n      }\n    }\n    this.package = mani\n    return this.package\n  }\n\n  [_tarballFromResolved] () {\n    // we use a RemoteFetcher to get the actual tarball stream\n    return new RemoteFetcher(this.resolved, {\n      ...this.opts,\n      resolved: this.resolved,\n      pkgid: `registry:${this.spec.name}@${this.resolved}`,\n    })[_tarballFromResolved]()\n  }\n\n  get types () {\n    return [\n      'tag',\n      'version',\n      'range',\n    ]\n  }\n}\nmodule.exports = RegistryFetcher\n"],"mappings":";AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,cAAc,CAAC;AACvC,MAAMC,aAAa,GAAGD,OAAO,CAAC,aAAa,CAAC;AAC5C,MAAME,oBAAoB,GAAGC,MAAM,CAACC,GAAG,CAAC,qCAAqC,CAAC;AAC9E,MAAMC,aAAa,GAAGL,OAAO,CAAC,iBAAiB,CAAC,CAACM,OAAO;AACxD,MAAMC,qBAAqB,GAAGP,OAAO,CAAC,4BAA4B,CAAC;AACnE,MAAMQ,GAAG,GAAGR,OAAO,CAAC,wBAAwB,CAAC;AAC7C,MAAMS,YAAY,GAAGT,OAAO,CAAC,mBAAmB,CAAC;AACjD,MAAMU,IAAI,GAAGV,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAMW,MAAM,GAAGX,OAAO,CAAC,QAAQ,CAAC;;AAEhC;AACA,MAAMY,QAAQ,GAAG,0EAA0E;AAC3F,MAAMC,OAAO,GAAG,kBAAkB;AAElC,MAAMC,KAAK,GAAGd,OAAO,CAAC,oBAAoB,CAAC;AAE3C,MAAMe,QAAQ,GAAGZ,MAAM,CAAC,UAAU,CAAC;AACnC,MAAMa,eAAe,SAASjB,OAAO,CAAC;EACpCkB,WAAW,CAAEC,IAAI,EAAEC,IAAI,EAAE;IACvB,KAAK,CAACD,IAAI,EAAEC,IAAI,CAAC;;IAEjB;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,CAACC,cAAc,GAAG,IAAI,CAACD,IAAI,CAACC,cAAc,IAAI,IAAI;IAEtD,IAAI,CAACC,QAAQ,GAAGP,KAAK,CAACQ,YAAY,CAACJ,IAAI,EAAEC,IAAI,CAAC;IAC9C,IAAI,CAACI,YAAY,GAAGhB,qBAAqB,CAAC,IAAI,CAACc,QAAQ,CAAC,GAAG,GAAG,GAC5D,IAAI,CAACH,IAAI,CAACM,WAAW;IAEvB,MAAMC,MAAM,GAAG,IAAIC,GAAG,CAAC,IAAI,CAACL,QAAQ,CAAC;IACrC,MAAMM,MAAM,GAAI,KAAIF,MAAM,CAACG,IAAK,GAAEH,MAAM,CAACI,QAAS,EAAC;IACnD;IACA;IACA,IAAI,IAAI,CAACV,IAAI,CAAE,GAAEQ,MAAO,QAAO,CAAC,EAAE;MAChC,IAAI,CAACG,YAAY,GAAG,IAAI,CAACX,IAAI,CAAE,GAAEQ,MAAO,QAAO,CAAC;IAClD;;IAEA;IACA;IACA;IACA;EACF;;EAEMI,OAAO,GAAI;IAAA;IAAA;MACf;MACA,MAAM,KAAI,CAACC,QAAQ,EAAE;MACrB,IAAI,CAAC,KAAI,CAACC,QAAQ,EAAE;QAClB,MAAMC,MAAM,CAACC,MAAM,CACjB,IAAIC,KAAK,CAAC,mDAAmD,CAAC,EAC9D;UAAEC,OAAO,EAAE,KAAI,CAACnB,IAAI,CAACoB,QAAQ;QAAG,CAAC,CAClC;MACH;MACA,OAAO,KAAI,CAACL,QAAQ;IAAA;EACtB;EAEA,CAAClB,QAAQ,IAAK;IACZ,OAAO;MACL;MACA,YAAY,EAAE,IAAI,CAACI,IAAI,CAACoB,SAAS,IAC9B,UAASlC,aAAc,SAAQmC,OAAO,CAAClC,OAAQ,EAAC;MACnD,IAAI,IAAI,CAACa,IAAI,CAACsB,OAAO,IAAI,CAAC,CAAC,CAAC;MAC5B,gBAAgB,EAAEpC,aAAa;MAC/B,iBAAiB,EAAE,WAAW;MAC9B,eAAe,EAAG,YAAW,IAAI,CAACa,IAAI,CAACwB,IAAK,EAAC;MAC7CC,MAAM,EAAE,IAAI,CAACC,YAAY,GAAG/B,OAAO,GAAGD;IACxC,CAAC;EACH;EAEMiC,SAAS,GAAI;IAAA;IAAA;MACjB;MACA;MACA;MACA,IAAI,MAAI,CAACzB,cAAc,IAAI,MAAI,CAACA,cAAc,CAAC0B,GAAG,CAAC,MAAI,CAACvB,YAAY,CAAC,EAAE;QACrE,OAAO,MAAI,CAACH,cAAc,CAAC2B,GAAG,CAAC,MAAI,CAACxB,YAAY,CAAC;MACnD;;MAEA;MACA;MACA;MACA,IAAI;QACF,MAAMyB,GAAG,SAASlC,KAAK,CAAC,MAAI,CAACS,YAAY,EAAE;UACzC,GAAG,MAAI,CAACJ,IAAI;UACZsB,OAAO,EAAE,MAAI,CAAC1B,QAAQ,CAAC,EAAE;UACzBG,IAAI,EAAE,MAAI,CAACA,IAAI;UACf;UACA+B,SAAS,EAAE;QACb,CAAC,CAAC;QACF,MAAMJ,SAAS,SAASG,GAAG,CAACE,IAAI,EAAE;QAClCL,SAAS,CAACM,cAAc,GAAG,CAACH,GAAG,CAACP,OAAO,CAACM,GAAG,CAAC,gBAAgB,CAAC;QAC7D,IAAI,MAAI,CAAC3B,cAAc,EAAE;UACvB,MAAI,CAACA,cAAc,CAACgC,GAAG,CAAC,MAAI,CAAC7B,YAAY,EAAEsB,SAAS,CAAC;QACvD;QACA,OAAOA,SAAS;MAClB,CAAC,CAAC,OAAOQ,GAAG,EAAE;QACZ,IAAI,MAAI,CAACjC,cAAc,EAAE;UACvB,MAAI,CAACA,cAAc,CAACkC,MAAM,CAAC,MAAI,CAAC/B,YAAY,CAAC;QAC/C;QACA,IAAI8B,GAAG,CAACE,IAAI,KAAK,MAAM,IAAI,MAAI,CAACX,YAAY,EAAE;UAC5C,MAAMS,GAAG;QACX;QACA;QACA,MAAI,CAACT,YAAY,GAAG,IAAI;QACxB,OAAO,MAAI,CAACC,SAAS,EAAE;MACzB;IAAC;EACH;EAEMb,QAAQ,GAAI;IAAA;IAAA;MAChB,IAAI,MAAI,CAACK,OAAO,EAAE;QAChB,OAAO,MAAI,CAACA,OAAO;MACrB;MAEA,MAAMQ,SAAS,SAAS,MAAI,CAACA,SAAS,EAAE;MACxC,IAAIW,IAAI,SAAS/C,YAAY,CAACoC,SAAS,EAAE,MAAI,CAAC3B,IAAI,CAACuC,SAAS,EAAE;QAC5D,GAAG,MAAI,CAACtC,IAAI;QACZuC,UAAU,EAAE,MAAI,CAACA,UAAU;QAC3BC,MAAM,EAAE,MAAI,CAACA;MACf,CAAC,CAAC;MACFH,IAAI,GAAGhD,GAAG,CAACoD,SAAS,CAACJ,IAAI,CAAC;MAC1B;;MAEA;MACA,MAAM;QAAEK;MAAK,CAAC,GAAGL,IAAI;MACrB,IAAIK,IAAI,EAAE;QACR,MAAI,CAAC5B,QAAQ,GAAGuB,IAAI,CAACM,SAAS,GAAGD,IAAI,CAACE,OAAO;QAC7CP,IAAI,CAACQ,KAAK,GAAG,MAAI,CAACC,IAAI;QACtB,MAAMC,aAAa,GAAGL,IAAI,CAACZ,SAAS,GAAGvC,IAAI,CAACyD,KAAK,CAACN,IAAI,CAACZ,SAAS,CAAC,GAC7DY,IAAI,CAACO,MAAM,GAAG1D,IAAI,CAAC2D,OAAO,CAACR,IAAI,CAACO,MAAM,EAAE,MAAM,EAAE;UAAE,GAAG,MAAI,CAACjD;QAAK,CAAC,CAAC,GACjE,IAAI;QACR,IAAI+C,aAAa,EAAE;UACjB,IAAI,MAAI,CAACjB,SAAS,IAAI,CAAC,MAAI,CAACA,SAAS,CAACqB,KAAK,CAACJ,aAAa,CAAC,EAAE;YAC1D;YACA;YACA;YACA;YACA;YACA;YACA;YACA,KAAK,MAAMK,IAAI,IAAIrC,MAAM,CAACsC,IAAI,CAAC,MAAI,CAACvB,SAAS,CAAC,EAAE;cAC9C,IAAIiB,aAAa,CAACK,IAAI,CAAC,EAAE;gBACvB,MAAMrC,MAAM,CAACC,MAAM,CAAC,IAAIC,KAAK,CAC1B,wCAAuCmC,IAAK,IAAG,GAC/C,UAAS,MAAI,CAACtB,SAAU,YAAWiB,aAAc,GAAE,CACrD,EAAE;kBAAEX,IAAI,EAAE;gBAAa,CAAC,CAAC;cAC5B;YACF;UACF;UACA;UACA;UACA;UACA,MAAI,CAACN,SAAS,GAAGiB,aAAa;QAChC;MACF;MACA,IAAI,MAAI,CAACjB,SAAS,EAAE;QAClBO,IAAI,CAACiB,UAAU,GAAGC,MAAM,CAAC,MAAI,CAACzB,SAAS,CAAC;QACxC,IAAIY,IAAI,CAACc,UAAU,EAAE;UACnB,IAAI,MAAI,CAACxD,IAAI,CAACyD,gBAAgB,EAAE;YAC9B;YACA,MAAMC,OAAO,GAAI,GAAErB,IAAI,CAACsB,GAAI,IAAGtB,IAAI,CAACiB,UAAW,EAAC;YAChD,KAAK,MAAMM,SAAS,IAAIlB,IAAI,CAACc,UAAU,EAAE;cACvC,MAAMK,SAAS,GAAG,MAAI,CAAClD,YAAY,IACjC,MAAI,CAACA,YAAY,CAACmD,MAAM,CAACC,GAAG,IAAKA,GAAG,CAACC,KAAK,KAAKJ,SAAS,CAACI,KAAM,CAAC,CAAC,CAAC,CAAC;cACrE,IAAI,CAACH,SAAS,EAAE;gBACd,MAAM9C,MAAM,CAACC,MAAM,CAAC,IAAIC,KAAK,CACxB,GAAEoB,IAAI,CAACsB,GAAI,yCAAwCC,SAAS,CAACI,KAAM,GAAE,GACtE,8CAA8C,CACjD,EAAE;kBAAE5B,IAAI,EAAE;gBAAuB,CAAC,CAAC;cACtC;cACA,MAAM6B,cAAc,GAClB,CAACJ,SAAS,CAACK,OAAO,IAAKC,IAAI,CAACnB,KAAK,CAACa,SAAS,CAACK,OAAO,CAAC,GAAGC,IAAI,CAACC,GAAG,EAAG;cACpE,IAAI,CAACH,cAAc,EAAE;gBACnB,MAAMlD,MAAM,CAACC,MAAM,CAAC,IAAIC,KAAK,CACxB,GAAEoB,IAAI,CAACsB,GAAI,yCAAwCC,SAAS,CAACI,KAAM,GAAE,GACrE,gDAA+CH,SAAS,CAACK,OAAQ,EAAC,CACtE,EAAE;kBAAE9B,IAAI,EAAE;gBAAuB,CAAC,CAAC;cACtC;cACA,MAAMiC,QAAQ,GAAG7E,MAAM,CAAC8E,YAAY,CAAC,QAAQ,CAAC;cAC9CD,QAAQ,CAACE,KAAK,CAACb,OAAO,CAAC;cACvBW,QAAQ,CAACG,GAAG,EAAE;cACd,MAAMC,KAAK,GAAGJ,QAAQ,CAACK,MAAM,CAC3Bb,SAAS,CAACc,MAAM,EAChBf,SAAS,CAACgB,GAAG,EACb,QAAQ,CACT;cACD,IAAI,CAACH,KAAK,EAAE;gBACV,MAAM1D,MAAM,CAACC,MAAM,CAAC,IAAIC,KAAK,CACxB,GAAEoB,IAAI,CAACsB,GAAI,0CAAyC,GACpD,UAASE,SAAS,CAACG,KAAM,mBAAkBJ,SAAS,CAACgB,GAAI,EAAC,CAC9D,EAAE;kBACDxC,IAAI,EAAE,qBAAqB;kBAC3B4B,KAAK,EAAEH,SAAS,CAACG,KAAK;kBACtBJ,SAAS,EAAEA,SAAS,CAACgB,GAAG;kBACxB9D,QAAQ,EAAEuB,IAAI,CAACM,SAAS;kBACxBb,SAAS,EAAEO,IAAI,CAACiB;gBAClB,CAAC,CAAC;cACJ;YACF;YACAjB,IAAI,CAACwC,WAAW,GAAGnC,IAAI,CAACc,UAAU;UACpC,CAAC,MAAM;YACLnB,IAAI,CAACwC,WAAW,GAAGnC,IAAI,CAACc,UAAU;UACpC;QACF;MACF;MACA,MAAI,CAACtC,OAAO,GAAGmB,IAAI;MACnB,OAAO,MAAI,CAACnB,OAAO;IAAA;EACrB;EAEA,CAACnC,oBAAoB,IAAK;IACxB;IACA,OAAO,IAAID,aAAa,CAAC,IAAI,CAACgC,QAAQ,EAAE;MACtC,GAAG,IAAI,CAACd,IAAI;MACZc,QAAQ,EAAE,IAAI,CAACA,QAAQ;MACvBgE,KAAK,EAAG,YAAW,IAAI,CAAC/E,IAAI,CAACwB,IAAK,IAAG,IAAI,CAACT,QAAS;IACrD,CAAC,CAAC,CAAC/B,oBAAoB,CAAC,EAAE;EAC5B;EAEA,IAAIgG,KAAK,GAAI;IACX,OAAO,CACL,KAAK,EACL,SAAS,EACT,OAAO,CACR;EACH;AACF;AACAC,MAAM,CAACC,OAAO,GAAGpF,eAAe"},"metadata":{},"sourceType":"script","externalDependencies":[]}