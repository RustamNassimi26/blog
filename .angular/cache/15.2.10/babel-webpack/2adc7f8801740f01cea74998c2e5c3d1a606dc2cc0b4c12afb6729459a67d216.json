{"ast":null,"code":"'use strict';\n\nmodule.exports = npa;\nmodule.exports.resolve = resolve;\nmodule.exports.toPurl = toPurl;\nmodule.exports.Result = Result;\nconst url = require('url');\nconst HostedGit = require('hosted-git-info');\nconst semver = require('semver');\nconst path = global.FAKE_WINDOWS ? require('path').win32 : require('path');\nconst validatePackageName = require('validate-npm-package-name');\nconst {\n  homedir\n} = require('os');\nconst log = require('proc-log');\nconst isWindows = process.platform === 'win32' || global.FAKE_WINDOWS;\nconst hasSlashes = isWindows ? /\\\\|[/]/ : /[/]/;\nconst isURL = /^(?:git[+])?[a-z]+:/i;\nconst isGit = /^[^@]+@[^:.]+\\.[^:]+:.+$/i;\nconst isFilename = /[.](?:tgz|tar.gz|tar)$/i;\nfunction npa(arg, where) {\n  let name;\n  let spec;\n  if (typeof arg === 'object') {\n    if (arg instanceof Result && (!where || where === arg.where)) {\n      return arg;\n    } else if (arg.name && arg.rawSpec) {\n      return npa.resolve(arg.name, arg.rawSpec, where || arg.where);\n    } else {\n      return npa(arg.raw, where || arg.where);\n    }\n  }\n  const nameEndsAt = arg[0] === '@' ? arg.slice(1).indexOf('@') + 1 : arg.indexOf('@');\n  const namePart = nameEndsAt > 0 ? arg.slice(0, nameEndsAt) : arg;\n  if (isURL.test(arg)) {\n    spec = arg;\n  } else if (isGit.test(arg)) {\n    spec = `git+ssh://${arg}`;\n  } else if (namePart[0] !== '@' && (hasSlashes.test(namePart) || isFilename.test(namePart))) {\n    spec = arg;\n  } else if (nameEndsAt > 0) {\n    name = namePart;\n    spec = arg.slice(nameEndsAt + 1) || '*';\n  } else {\n    const valid = validatePackageName(arg);\n    if (valid.validForOldPackages) {\n      name = arg;\n      spec = '*';\n    } else {\n      spec = arg;\n    }\n  }\n  return resolve(name, spec, where, arg);\n}\nconst isFilespec = isWindows ? /^(?:[.]|~[/]|[/\\\\]|[a-zA-Z]:)/ : /^(?:[.]|~[/]|[/]|[a-zA-Z]:)/;\nfunction resolve(name, spec, where, arg) {\n  const res = new Result({\n    raw: arg,\n    name: name,\n    rawSpec: spec,\n    fromArgument: arg != null\n  });\n  if (name) {\n    res.setName(name);\n  }\n  if (spec && (isFilespec.test(spec) || /^file:/i.test(spec))) {\n    return fromFile(res, where);\n  } else if (spec && /^npm:/i.test(spec)) {\n    return fromAlias(res, where);\n  }\n  const hosted = HostedGit.fromUrl(spec, {\n    noGitPlus: true,\n    noCommittish: true\n  });\n  if (hosted) {\n    return fromHostedGit(res, hosted);\n  } else if (spec && isURL.test(spec)) {\n    return fromURL(res);\n  } else if (spec && (hasSlashes.test(spec) || isFilename.test(spec))) {\n    return fromFile(res, where);\n  } else {\n    return fromRegistry(res);\n  }\n}\nconst defaultRegistry = 'https://registry.npmjs.org';\nfunction toPurl(arg, reg = defaultRegistry) {\n  const res = npa(arg);\n  if (res.type !== 'version') {\n    throw invalidPurlType(res.type, res.raw);\n  }\n\n  // URI-encode leading @ of scoped packages\n  let purl = 'pkg:npm/' + res.name.replace(/^@/, '%40') + '@' + res.rawSpec;\n  if (reg !== defaultRegistry) {\n    purl += '?repository_url=' + reg;\n  }\n  return purl;\n}\nfunction invalidPackageName(name, valid, raw) {\n  // eslint-disable-next-line max-len\n  const err = new Error(`Invalid package name \"${name}\" of package \"${raw}\": ${valid.errors.join('; ')}.`);\n  err.code = 'EINVALIDPACKAGENAME';\n  return err;\n}\nfunction invalidTagName(name, raw) {\n  // eslint-disable-next-line max-len\n  const err = new Error(`Invalid tag name \"${name}\" of package \"${raw}\": Tags may not have any characters that encodeURIComponent encodes.`);\n  err.code = 'EINVALIDTAGNAME';\n  return err;\n}\nfunction invalidPurlType(type, raw) {\n  // eslint-disable-next-line max-len\n  const err = new Error(`Invalid type \"${type}\" of package \"${raw}\": Purl can only be generated for \"version\" types.`);\n  err.code = 'EINVALIDPURLTYPE';\n  return err;\n}\nfunction Result(opts) {\n  this.type = opts.type;\n  this.registry = opts.registry;\n  this.where = opts.where;\n  if (opts.raw == null) {\n    this.raw = opts.name ? opts.name + '@' + opts.rawSpec : opts.rawSpec;\n  } else {\n    this.raw = opts.raw;\n  }\n  this.name = undefined;\n  this.escapedName = undefined;\n  this.scope = undefined;\n  this.rawSpec = opts.rawSpec || '';\n  this.saveSpec = opts.saveSpec;\n  this.fetchSpec = opts.fetchSpec;\n  if (opts.name) {\n    this.setName(opts.name);\n  }\n  this.gitRange = opts.gitRange;\n  this.gitCommittish = opts.gitCommittish;\n  this.gitSubdir = opts.gitSubdir;\n  this.hosted = opts.hosted;\n}\nResult.prototype.setName = function (name) {\n  const valid = validatePackageName(name);\n  if (!valid.validForOldPackages) {\n    throw invalidPackageName(name, valid, this.raw);\n  }\n  this.name = name;\n  this.scope = name[0] === '@' ? name.slice(0, name.indexOf('/')) : undefined;\n  // scoped packages in couch must have slash url-encoded, e.g. @foo%2Fbar\n  this.escapedName = name.replace('/', '%2f');\n  return this;\n};\nResult.prototype.toString = function () {\n  const full = [];\n  if (this.name != null && this.name !== '') {\n    full.push(this.name);\n  }\n  const spec = this.saveSpec || this.fetchSpec || this.rawSpec;\n  if (spec != null && spec !== '') {\n    full.push(spec);\n  }\n  return full.length ? full.join('@') : this.raw;\n};\nResult.prototype.toJSON = function () {\n  const result = Object.assign({}, this);\n  delete result.hosted;\n  return result;\n};\nfunction setGitCommittish(res, committish) {\n  if (!committish) {\n    res.gitCommittish = null;\n    return res;\n  }\n\n  // for each :: separated item:\n  for (const part of committish.split('::')) {\n    // if the item has no : the n it is a commit-ish\n    if (!part.includes(':')) {\n      if (res.gitRange) {\n        throw new Error('cannot override existing semver range with a committish');\n      }\n      if (res.gitCommittish) {\n        throw new Error('cannot override existing committish with a second committish');\n      }\n      res.gitCommittish = part;\n      continue;\n    }\n    // split on name:value\n    const [name, value] = part.split(':');\n    // if name is semver do semver lookup of ref or tag\n    if (name === 'semver') {\n      if (res.gitCommittish) {\n        throw new Error('cannot override existing committish with a semver range');\n      }\n      if (res.gitRange) {\n        throw new Error('cannot override existing semver range with a second semver range');\n      }\n      res.gitRange = decodeURIComponent(value);\n      continue;\n    }\n    if (name === 'path') {\n      if (res.gitSubdir) {\n        throw new Error('cannot override existing path with a second path');\n      }\n      res.gitSubdir = `/${value}`;\n      continue;\n    }\n    log.warn('npm-package-arg', `ignoring unknown key \"${name}\"`);\n  }\n  return res;\n}\nfunction fromFile(res, where) {\n  if (!where) {\n    where = process.cwd();\n  }\n  res.type = isFilename.test(res.rawSpec) ? 'file' : 'directory';\n  res.where = where;\n\n  // always put the '/' on where when resolving urls, or else\n  // file:foo from /path/to/bar goes to /path/to/foo, when we want\n  // it to be /path/to/bar/foo\n\n  let specUrl;\n  let resolvedUrl;\n  const prefix = !/^file:/.test(res.rawSpec) ? 'file:' : '';\n  const rawWithPrefix = prefix + res.rawSpec;\n  let rawNoPrefix = rawWithPrefix.replace(/^file:/, '');\n  try {\n    resolvedUrl = new url.URL(rawWithPrefix, `file://${path.resolve(where)}/`);\n    specUrl = new url.URL(rawWithPrefix);\n  } catch (originalError) {\n    const er = new Error('Invalid file: URL, must comply with RFC 8909');\n    throw Object.assign(er, {\n      raw: res.rawSpec,\n      spec: res,\n      where,\n      originalError\n    });\n  }\n\n  // environment switch for testing\n  if (process.env.NPM_PACKAGE_ARG_8909_STRICT !== '1') {\n    // XXX backwards compatibility lack of compliance with 8909\n    // Remove when we want a breaking change to come into RFC compliance.\n    if (resolvedUrl.host && resolvedUrl.host !== 'localhost') {\n      const rawSpec = res.rawSpec.replace(/^file:\\/\\//, 'file:///');\n      resolvedUrl = new url.URL(rawSpec, `file://${path.resolve(where)}/`);\n      specUrl = new url.URL(rawSpec);\n      rawNoPrefix = rawSpec.replace(/^file:/, '');\n    }\n    // turn file:/../foo into file:../foo\n    // for 1, 2 or 3 leading slashes since we attempted\n    // in the previous step to make it a file protocol url with a leading slash\n    if (/^\\/{1,3}\\.\\.?(\\/|$)/.test(rawNoPrefix)) {\n      const rawSpec = res.rawSpec.replace(/^file:\\/{1,3}/, 'file:');\n      resolvedUrl = new url.URL(rawSpec, `file://${path.resolve(where)}/`);\n      specUrl = new url.URL(rawSpec);\n      rawNoPrefix = rawSpec.replace(/^file:/, '');\n    }\n    // XXX end 8909 violation backwards compatibility section\n  }\n\n  // file:foo - relative url to ./foo\n  // file:/foo - absolute path /foo\n  // file:///foo - absolute path to /foo, no authority host\n  // file://localhost/foo - absolute path to /foo, on localhost\n  // file://foo - absolute path to / on foo host (error!)\n  if (resolvedUrl.host && resolvedUrl.host !== 'localhost') {\n    const msg = `Invalid file: URL, must be absolute if // present`;\n    throw Object.assign(new Error(msg), {\n      raw: res.rawSpec,\n      parsed: resolvedUrl\n    });\n  }\n\n  // turn /C:/blah into just C:/blah on windows\n  let specPath = decodeURIComponent(specUrl.pathname);\n  let resolvedPath = decodeURIComponent(resolvedUrl.pathname);\n  if (isWindows) {\n    specPath = specPath.replace(/^\\/+([a-z]:\\/)/i, '$1');\n    resolvedPath = resolvedPath.replace(/^\\/+([a-z]:\\/)/i, '$1');\n  }\n\n  // replace ~ with homedir, but keep the ~ in the saveSpec\n  // otherwise, make it relative to where param\n  if (/^\\/~(\\/|$)/.test(specPath)) {\n    res.saveSpec = `file:${specPath.substr(1)}`;\n    resolvedPath = path.resolve(homedir(), specPath.substr(3));\n  } else if (!path.isAbsolute(rawNoPrefix)) {\n    res.saveSpec = `file:${path.relative(where, resolvedPath)}`;\n  } else {\n    res.saveSpec = `file:${path.resolve(resolvedPath)}`;\n  }\n  res.fetchSpec = path.resolve(where, resolvedPath);\n  return res;\n}\nfunction fromHostedGit(res, hosted) {\n  res.type = 'git';\n  res.hosted = hosted;\n  res.saveSpec = hosted.toString({\n    noGitPlus: false,\n    noCommittish: false\n  });\n  res.fetchSpec = hosted.getDefaultRepresentation() === 'shortcut' ? null : hosted.toString();\n  return setGitCommittish(res, hosted.committish);\n}\nfunction unsupportedURLType(protocol, spec) {\n  const err = new Error(`Unsupported URL Type \"${protocol}\": ${spec}`);\n  err.code = 'EUNSUPPORTEDPROTOCOL';\n  return err;\n}\nfunction matchGitScp(spec) {\n  // git ssh specifiers are overloaded to also use scp-style git\n  // specifiers, so we have to parse those out and treat them special.\n  // They are NOT true URIs, so we can't hand them to `url.parse`.\n  //\n  // This regex looks for things that look like:\n  // git+ssh://git@my.custom.git.com:username/project.git#deadbeef\n  //\n  // ...and various combinations. The username in the beginning is *required*.\n  const matched = spec.match(/^git\\+ssh:\\/\\/([^:#]+:[^#]+(?:\\.git)?)(?:#(.*))?$/i);\n  return matched && !matched[1].match(/:[0-9]+\\/?.*$/i) && {\n    fetchSpec: matched[1],\n    gitCommittish: matched[2] == null ? null : matched[2]\n  };\n}\nfunction fromURL(res) {\n  // eslint-disable-next-line node/no-deprecated-api\n  const urlparse = url.parse(res.rawSpec);\n  res.saveSpec = res.rawSpec;\n  // check the protocol, and then see if it's git or not\n  switch (urlparse.protocol) {\n    case 'git:':\n    case 'git+http:':\n    case 'git+https:':\n    case 'git+rsync:':\n    case 'git+ftp:':\n    case 'git+file:':\n    case 'git+ssh:':\n      {\n        res.type = 'git';\n        const match = urlparse.protocol === 'git+ssh:' ? matchGitScp(res.rawSpec) : null;\n        if (match) {\n          setGitCommittish(res, match.gitCommittish);\n          res.fetchSpec = match.fetchSpec;\n        } else {\n          setGitCommittish(res, urlparse.hash != null ? urlparse.hash.slice(1) : '');\n          urlparse.protocol = urlparse.protocol.replace(/^git[+]/, '');\n          if (urlparse.protocol === 'file:' && /^git\\+file:\\/\\/[a-z]:/i.test(res.rawSpec)) {\n            // keep the drive letter : on windows file paths\n            urlparse.host += ':';\n            urlparse.hostname += ':';\n          }\n          delete urlparse.hash;\n          res.fetchSpec = url.format(urlparse);\n        }\n        break;\n      }\n    case 'http:':\n    case 'https:':\n      res.type = 'remote';\n      res.fetchSpec = res.saveSpec;\n      break;\n    default:\n      throw unsupportedURLType(urlparse.protocol, res.rawSpec);\n  }\n  return res;\n}\nfunction fromAlias(res, where) {\n  const subSpec = npa(res.rawSpec.substr(4), where);\n  if (subSpec.type === 'alias') {\n    throw new Error('nested aliases not supported');\n  }\n  if (!subSpec.registry) {\n    throw new Error('aliases only work for registry deps');\n  }\n  res.subSpec = subSpec;\n  res.registry = true;\n  res.type = 'alias';\n  res.saveSpec = null;\n  res.fetchSpec = null;\n  return res;\n}\nfunction fromRegistry(res) {\n  res.registry = true;\n  const spec = res.rawSpec.trim();\n  // no save spec for registry components as we save based on the fetched\n  // version, not on the argument so this can't compute that.\n  res.saveSpec = null;\n  res.fetchSpec = spec;\n  const version = semver.valid(spec, true);\n  const range = semver.validRange(spec, true);\n  if (version) {\n    res.type = 'version';\n  } else if (range) {\n    res.type = 'range';\n  } else {\n    if (encodeURIComponent(spec) !== spec) {\n      throw invalidTagName(spec, res.raw);\n    }\n    res.type = 'tag';\n  }\n  return res;\n}","map":{"version":3,"names":["module","exports","npa","resolve","toPurl","Result","url","require","HostedGit","semver","path","global","FAKE_WINDOWS","win32","validatePackageName","homedir","log","isWindows","process","platform","hasSlashes","isURL","isGit","isFilename","arg","where","name","spec","rawSpec","raw","nameEndsAt","slice","indexOf","namePart","test","valid","validForOldPackages","isFilespec","res","fromArgument","setName","fromFile","fromAlias","hosted","fromUrl","noGitPlus","noCommittish","fromHostedGit","fromURL","fromRegistry","defaultRegistry","reg","type","invalidPurlType","purl","replace","invalidPackageName","err","Error","errors","join","code","invalidTagName","opts","registry","undefined","escapedName","scope","saveSpec","fetchSpec","gitRange","gitCommittish","gitSubdir","prototype","toString","full","push","length","toJSON","result","Object","assign","setGitCommittish","committish","part","split","includes","value","decodeURIComponent","warn","cwd","specUrl","resolvedUrl","prefix","rawWithPrefix","rawNoPrefix","URL","originalError","er","env","NPM_PACKAGE_ARG_8909_STRICT","host","msg","parsed","specPath","pathname","resolvedPath","substr","isAbsolute","relative","getDefaultRepresentation","unsupportedURLType","protocol","matchGitScp","matched","match","urlparse","parse","hash","hostname","format","subSpec","trim","version","range","validRange","encodeURIComponent"],"sources":["I:/Angular/angular-blog/node_modules/npm-pick-manifest/node_modules/npm-package-arg/lib/npa.js"],"sourcesContent":["'use strict'\nmodule.exports = npa\nmodule.exports.resolve = resolve\nmodule.exports.toPurl = toPurl\nmodule.exports.Result = Result\n\nconst url = require('url')\nconst HostedGit = require('hosted-git-info')\nconst semver = require('semver')\nconst path = global.FAKE_WINDOWS ? require('path').win32 : require('path')\nconst validatePackageName = require('validate-npm-package-name')\nconst { homedir } = require('os')\nconst log = require('proc-log')\n\nconst isWindows = process.platform === 'win32' || global.FAKE_WINDOWS\nconst hasSlashes = isWindows ? /\\\\|[/]/ : /[/]/\nconst isURL = /^(?:git[+])?[a-z]+:/i\nconst isGit = /^[^@]+@[^:.]+\\.[^:]+:.+$/i\nconst isFilename = /[.](?:tgz|tar.gz|tar)$/i\n\nfunction npa (arg, where) {\n  let name\n  let spec\n  if (typeof arg === 'object') {\n    if (arg instanceof Result && (!where || where === arg.where)) {\n      return arg\n    } else if (arg.name && arg.rawSpec) {\n      return npa.resolve(arg.name, arg.rawSpec, where || arg.where)\n    } else {\n      return npa(arg.raw, where || arg.where)\n    }\n  }\n  const nameEndsAt = arg[0] === '@' ? arg.slice(1).indexOf('@') + 1 : arg.indexOf('@')\n  const namePart = nameEndsAt > 0 ? arg.slice(0, nameEndsAt) : arg\n  if (isURL.test(arg)) {\n    spec = arg\n  } else if (isGit.test(arg)) {\n    spec = `git+ssh://${arg}`\n  } else if (namePart[0] !== '@' && (hasSlashes.test(namePart) || isFilename.test(namePart))) {\n    spec = arg\n  } else if (nameEndsAt > 0) {\n    name = namePart\n    spec = arg.slice(nameEndsAt + 1) || '*'\n  } else {\n    const valid = validatePackageName(arg)\n    if (valid.validForOldPackages) {\n      name = arg\n      spec = '*'\n    } else {\n      spec = arg\n    }\n  }\n  return resolve(name, spec, where, arg)\n}\n\nconst isFilespec = isWindows ? /^(?:[.]|~[/]|[/\\\\]|[a-zA-Z]:)/ : /^(?:[.]|~[/]|[/]|[a-zA-Z]:)/\n\nfunction resolve (name, spec, where, arg) {\n  const res = new Result({\n    raw: arg,\n    name: name,\n    rawSpec: spec,\n    fromArgument: arg != null,\n  })\n\n  if (name) {\n    res.setName(name)\n  }\n\n  if (spec && (isFilespec.test(spec) || /^file:/i.test(spec))) {\n    return fromFile(res, where)\n  } else if (spec && /^npm:/i.test(spec)) {\n    return fromAlias(res, where)\n  }\n\n  const hosted = HostedGit.fromUrl(spec, {\n    noGitPlus: true,\n    noCommittish: true,\n  })\n  if (hosted) {\n    return fromHostedGit(res, hosted)\n  } else if (spec && isURL.test(spec)) {\n    return fromURL(res)\n  } else if (spec && (hasSlashes.test(spec) || isFilename.test(spec))) {\n    return fromFile(res, where)\n  } else {\n    return fromRegistry(res)\n  }\n}\n\nconst defaultRegistry = 'https://registry.npmjs.org'\n\nfunction toPurl (arg, reg = defaultRegistry) {\n  const res = npa(arg)\n\n  if (res.type !== 'version') {\n    throw invalidPurlType(res.type, res.raw)\n  }\n\n  // URI-encode leading @ of scoped packages\n  let purl = 'pkg:npm/' + res.name.replace(/^@/, '%40') + '@' + res.rawSpec\n  if (reg !== defaultRegistry) {\n    purl += '?repository_url=' + reg\n  }\n\n  return purl\n}\n\nfunction invalidPackageName (name, valid, raw) {\n  // eslint-disable-next-line max-len\n  const err = new Error(`Invalid package name \"${name}\" of package \"${raw}\": ${valid.errors.join('; ')}.`)\n  err.code = 'EINVALIDPACKAGENAME'\n  return err\n}\n\nfunction invalidTagName (name, raw) {\n  // eslint-disable-next-line max-len\n  const err = new Error(`Invalid tag name \"${name}\" of package \"${raw}\": Tags may not have any characters that encodeURIComponent encodes.`)\n  err.code = 'EINVALIDTAGNAME'\n  return err\n}\n\nfunction invalidPurlType (type, raw) {\n  // eslint-disable-next-line max-len\n  const err = new Error(`Invalid type \"${type}\" of package \"${raw}\": Purl can only be generated for \"version\" types.`)\n  err.code = 'EINVALIDPURLTYPE'\n  return err\n}\n\nfunction Result (opts) {\n  this.type = opts.type\n  this.registry = opts.registry\n  this.where = opts.where\n  if (opts.raw == null) {\n    this.raw = opts.name ? opts.name + '@' + opts.rawSpec : opts.rawSpec\n  } else {\n    this.raw = opts.raw\n  }\n\n  this.name = undefined\n  this.escapedName = undefined\n  this.scope = undefined\n  this.rawSpec = opts.rawSpec || ''\n  this.saveSpec = opts.saveSpec\n  this.fetchSpec = opts.fetchSpec\n  if (opts.name) {\n    this.setName(opts.name)\n  }\n  this.gitRange = opts.gitRange\n  this.gitCommittish = opts.gitCommittish\n  this.gitSubdir = opts.gitSubdir\n  this.hosted = opts.hosted\n}\n\nResult.prototype.setName = function (name) {\n  const valid = validatePackageName(name)\n  if (!valid.validForOldPackages) {\n    throw invalidPackageName(name, valid, this.raw)\n  }\n\n  this.name = name\n  this.scope = name[0] === '@' ? name.slice(0, name.indexOf('/')) : undefined\n  // scoped packages in couch must have slash url-encoded, e.g. @foo%2Fbar\n  this.escapedName = name.replace('/', '%2f')\n  return this\n}\n\nResult.prototype.toString = function () {\n  const full = []\n  if (this.name != null && this.name !== '') {\n    full.push(this.name)\n  }\n  const spec = this.saveSpec || this.fetchSpec || this.rawSpec\n  if (spec != null && spec !== '') {\n    full.push(spec)\n  }\n  return full.length ? full.join('@') : this.raw\n}\n\nResult.prototype.toJSON = function () {\n  const result = Object.assign({}, this)\n  delete result.hosted\n  return result\n}\n\nfunction setGitCommittish (res, committish) {\n  if (!committish) {\n    res.gitCommittish = null\n    return res\n  }\n\n  // for each :: separated item:\n  for (const part of committish.split('::')) {\n    // if the item has no : the n it is a commit-ish\n    if (!part.includes(':')) {\n      if (res.gitRange) {\n        throw new Error('cannot override existing semver range with a committish')\n      }\n      if (res.gitCommittish) {\n        throw new Error('cannot override existing committish with a second committish')\n      }\n      res.gitCommittish = part\n      continue\n    }\n    // split on name:value\n    const [name, value] = part.split(':')\n    // if name is semver do semver lookup of ref or tag\n    if (name === 'semver') {\n      if (res.gitCommittish) {\n        throw new Error('cannot override existing committish with a semver range')\n      }\n      if (res.gitRange) {\n        throw new Error('cannot override existing semver range with a second semver range')\n      }\n      res.gitRange = decodeURIComponent(value)\n      continue\n    }\n    if (name === 'path') {\n      if (res.gitSubdir) {\n        throw new Error('cannot override existing path with a second path')\n      }\n      res.gitSubdir = `/${value}`\n      continue\n    }\n    log.warn('npm-package-arg', `ignoring unknown key \"${name}\"`)\n  }\n\n  return res\n}\n\nfunction fromFile (res, where) {\n  if (!where) {\n    where = process.cwd()\n  }\n  res.type = isFilename.test(res.rawSpec) ? 'file' : 'directory'\n  res.where = where\n\n  // always put the '/' on where when resolving urls, or else\n  // file:foo from /path/to/bar goes to /path/to/foo, when we want\n  // it to be /path/to/bar/foo\n\n  let specUrl\n  let resolvedUrl\n  const prefix = (!/^file:/.test(res.rawSpec) ? 'file:' : '')\n  const rawWithPrefix = prefix + res.rawSpec\n  let rawNoPrefix = rawWithPrefix.replace(/^file:/, '')\n  try {\n    resolvedUrl = new url.URL(rawWithPrefix, `file://${path.resolve(where)}/`)\n    specUrl = new url.URL(rawWithPrefix)\n  } catch (originalError) {\n    const er = new Error('Invalid file: URL, must comply with RFC 8909')\n    throw Object.assign(er, {\n      raw: res.rawSpec,\n      spec: res,\n      where,\n      originalError,\n    })\n  }\n\n  // environment switch for testing\n  if (process.env.NPM_PACKAGE_ARG_8909_STRICT !== '1') {\n    // XXX backwards compatibility lack of compliance with 8909\n    // Remove when we want a breaking change to come into RFC compliance.\n    if (resolvedUrl.host && resolvedUrl.host !== 'localhost') {\n      const rawSpec = res.rawSpec.replace(/^file:\\/\\//, 'file:///')\n      resolvedUrl = new url.URL(rawSpec, `file://${path.resolve(where)}/`)\n      specUrl = new url.URL(rawSpec)\n      rawNoPrefix = rawSpec.replace(/^file:/, '')\n    }\n    // turn file:/../foo into file:../foo\n    // for 1, 2 or 3 leading slashes since we attempted\n    // in the previous step to make it a file protocol url with a leading slash\n    if (/^\\/{1,3}\\.\\.?(\\/|$)/.test(rawNoPrefix)) {\n      const rawSpec = res.rawSpec.replace(/^file:\\/{1,3}/, 'file:')\n      resolvedUrl = new url.URL(rawSpec, `file://${path.resolve(where)}/`)\n      specUrl = new url.URL(rawSpec)\n      rawNoPrefix = rawSpec.replace(/^file:/, '')\n    }\n    // XXX end 8909 violation backwards compatibility section\n  }\n\n  // file:foo - relative url to ./foo\n  // file:/foo - absolute path /foo\n  // file:///foo - absolute path to /foo, no authority host\n  // file://localhost/foo - absolute path to /foo, on localhost\n  // file://foo - absolute path to / on foo host (error!)\n  if (resolvedUrl.host && resolvedUrl.host !== 'localhost') {\n    const msg = `Invalid file: URL, must be absolute if // present`\n    throw Object.assign(new Error(msg), {\n      raw: res.rawSpec,\n      parsed: resolvedUrl,\n    })\n  }\n\n  // turn /C:/blah into just C:/blah on windows\n  let specPath = decodeURIComponent(specUrl.pathname)\n  let resolvedPath = decodeURIComponent(resolvedUrl.pathname)\n  if (isWindows) {\n    specPath = specPath.replace(/^\\/+([a-z]:\\/)/i, '$1')\n    resolvedPath = resolvedPath.replace(/^\\/+([a-z]:\\/)/i, '$1')\n  }\n\n  // replace ~ with homedir, but keep the ~ in the saveSpec\n  // otherwise, make it relative to where param\n  if (/^\\/~(\\/|$)/.test(specPath)) {\n    res.saveSpec = `file:${specPath.substr(1)}`\n    resolvedPath = path.resolve(homedir(), specPath.substr(3))\n  } else if (!path.isAbsolute(rawNoPrefix)) {\n    res.saveSpec = `file:${path.relative(where, resolvedPath)}`\n  } else {\n    res.saveSpec = `file:${path.resolve(resolvedPath)}`\n  }\n\n  res.fetchSpec = path.resolve(where, resolvedPath)\n  return res\n}\n\nfunction fromHostedGit (res, hosted) {\n  res.type = 'git'\n  res.hosted = hosted\n  res.saveSpec = hosted.toString({ noGitPlus: false, noCommittish: false })\n  res.fetchSpec = hosted.getDefaultRepresentation() === 'shortcut' ? null : hosted.toString()\n  return setGitCommittish(res, hosted.committish)\n}\n\nfunction unsupportedURLType (protocol, spec) {\n  const err = new Error(`Unsupported URL Type \"${protocol}\": ${spec}`)\n  err.code = 'EUNSUPPORTEDPROTOCOL'\n  return err\n}\n\nfunction matchGitScp (spec) {\n  // git ssh specifiers are overloaded to also use scp-style git\n  // specifiers, so we have to parse those out and treat them special.\n  // They are NOT true URIs, so we can't hand them to `url.parse`.\n  //\n  // This regex looks for things that look like:\n  // git+ssh://git@my.custom.git.com:username/project.git#deadbeef\n  //\n  // ...and various combinations. The username in the beginning is *required*.\n  const matched = spec.match(/^git\\+ssh:\\/\\/([^:#]+:[^#]+(?:\\.git)?)(?:#(.*))?$/i)\n  return matched && !matched[1].match(/:[0-9]+\\/?.*$/i) && {\n    fetchSpec: matched[1],\n    gitCommittish: matched[2] == null ? null : matched[2],\n  }\n}\n\nfunction fromURL (res) {\n  // eslint-disable-next-line node/no-deprecated-api\n  const urlparse = url.parse(res.rawSpec)\n  res.saveSpec = res.rawSpec\n  // check the protocol, and then see if it's git or not\n  switch (urlparse.protocol) {\n    case 'git:':\n    case 'git+http:':\n    case 'git+https:':\n    case 'git+rsync:':\n    case 'git+ftp:':\n    case 'git+file:':\n    case 'git+ssh:': {\n      res.type = 'git'\n      const match = urlparse.protocol === 'git+ssh:' ? matchGitScp(res.rawSpec)\n        : null\n      if (match) {\n        setGitCommittish(res, match.gitCommittish)\n        res.fetchSpec = match.fetchSpec\n      } else {\n        setGitCommittish(res, urlparse.hash != null ? urlparse.hash.slice(1) : '')\n        urlparse.protocol = urlparse.protocol.replace(/^git[+]/, '')\n        if (urlparse.protocol === 'file:' && /^git\\+file:\\/\\/[a-z]:/i.test(res.rawSpec)) {\n          // keep the drive letter : on windows file paths\n          urlparse.host += ':'\n          urlparse.hostname += ':'\n        }\n        delete urlparse.hash\n        res.fetchSpec = url.format(urlparse)\n      }\n      break\n    }\n    case 'http:':\n    case 'https:':\n      res.type = 'remote'\n      res.fetchSpec = res.saveSpec\n      break\n\n    default:\n      throw unsupportedURLType(urlparse.protocol, res.rawSpec)\n  }\n\n  return res\n}\n\nfunction fromAlias (res, where) {\n  const subSpec = npa(res.rawSpec.substr(4), where)\n  if (subSpec.type === 'alias') {\n    throw new Error('nested aliases not supported')\n  }\n\n  if (!subSpec.registry) {\n    throw new Error('aliases only work for registry deps')\n  }\n\n  res.subSpec = subSpec\n  res.registry = true\n  res.type = 'alias'\n  res.saveSpec = null\n  res.fetchSpec = null\n  return res\n}\n\nfunction fromRegistry (res) {\n  res.registry = true\n  const spec = res.rawSpec.trim()\n  // no save spec for registry components as we save based on the fetched\n  // version, not on the argument so this can't compute that.\n  res.saveSpec = null\n  res.fetchSpec = spec\n  const version = semver.valid(spec, true)\n  const range = semver.validRange(spec, true)\n  if (version) {\n    res.type = 'version'\n  } else if (range) {\n    res.type = 'range'\n  } else {\n    if (encodeURIComponent(spec) !== spec) {\n      throw invalidTagName(spec, res.raw)\n    }\n    res.type = 'tag'\n  }\n  return res\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}