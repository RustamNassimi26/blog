{"ast":null,"code":"var _asyncToGenerator = require(\"I:/Angular/angular-blog/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst {\n  dirname,\n  resolve\n} = require('path');\nconst url = require('url');\nconst fs = require('../fs.js');\n\n// given a path, find the owner of the nearest parent\nconst find = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (path) {\n    // if we have no getuid, permissions are irrelevant on this platform\n    if (!process.getuid) {\n      return {};\n    }\n\n    // fs methods accept URL objects with a scheme of file: so we need to unwrap\n    // those into an actual path string before we can resolve it\n    const resolved = path != null && path.href && path.origin ? resolve(url.fileURLToPath(path)) : resolve(path);\n    let stat;\n    try {\n      stat = yield fs.lstat(resolved);\n    } finally {\n      // if we got a stat, return its contents\n      if (stat) {\n        return {\n          uid: stat.uid,\n          gid: stat.gid\n        };\n      }\n\n      // try the parent directory\n      if (resolved !== dirname(resolved)) {\n        return find(dirname(resolved));\n      }\n\n      // no more parents, never got a stat, just return an empty object\n      return {};\n    }\n  });\n  return function find(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\n// given a path, uid, and gid update the ownership of the path if necessary\nconst update = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (path, uid, gid) {\n    // nothing to update, just exit\n    if (uid === undefined && gid === undefined) {\n      return;\n    }\n    try {\n      // see if the permissions are already the same, if they are we don't\n      // need to do anything, so return early\n      const stat = yield fs.stat(path);\n      if (uid === stat.uid && gid === stat.gid) {\n        return;\n      }\n    } catch {\n      // ignore errors\n    }\n    try {\n      yield fs.chown(path, uid, gid);\n    } catch {\n      // ignore errors\n    }\n  });\n  return function update(_x2, _x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\n// accepts a `path` and the `owner` property of an options object and normalizes\n// it into an object with numerical `uid` and `gid`\nconst validate = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (path, input) {\n    let uid;\n    let gid;\n    if (typeof input === 'string' || typeof input === 'number') {\n      uid = input;\n      gid = input;\n    } else if (input && typeof input === 'object') {\n      uid = input.uid;\n      gid = input.gid;\n    }\n    if (uid === 'inherit' || gid === 'inherit') {\n      const owner = yield find(path);\n      if (uid === 'inherit') {\n        uid = owner.uid;\n      }\n      if (gid === 'inherit') {\n        gid = owner.gid;\n      }\n    }\n    return {\n      uid,\n      gid\n    };\n  });\n  return function validate(_x5, _x6) {\n    return _ref3.apply(this, arguments);\n  };\n}();\nmodule.exports = {\n  find,\n  update,\n  validate\n};","map":{"version":3,"names":["dirname","resolve","require","url","fs","find","path","process","getuid","resolved","href","origin","fileURLToPath","stat","lstat","uid","gid","update","undefined","chown","validate","input","owner","module","exports"],"sources":["I:/Angular/angular-blog/node_modules/make-fetch-happen/node_modules/@npmcli/fs/lib/common/owner.js"],"sourcesContent":["const { dirname, resolve } = require('path')\nconst url = require('url')\n\nconst fs = require('../fs.js')\n\n// given a path, find the owner of the nearest parent\nconst find = async (path) => {\n  // if we have no getuid, permissions are irrelevant on this platform\n  if (!process.getuid) {\n    return {}\n  }\n\n  // fs methods accept URL objects with a scheme of file: so we need to unwrap\n  // those into an actual path string before we can resolve it\n  const resolved = path != null && path.href && path.origin\n    ? resolve(url.fileURLToPath(path))\n    : resolve(path)\n\n  let stat\n\n  try {\n    stat = await fs.lstat(resolved)\n  } finally {\n    // if we got a stat, return its contents\n    if (stat) {\n      return { uid: stat.uid, gid: stat.gid }\n    }\n\n    // try the parent directory\n    if (resolved !== dirname(resolved)) {\n      return find(dirname(resolved))\n    }\n\n    // no more parents, never got a stat, just return an empty object\n    return {}\n  }\n}\n\n// given a path, uid, and gid update the ownership of the path if necessary\nconst update = async (path, uid, gid) => {\n  // nothing to update, just exit\n  if (uid === undefined && gid === undefined) {\n    return\n  }\n\n  try {\n    // see if the permissions are already the same, if they are we don't\n    // need to do anything, so return early\n    const stat = await fs.stat(path)\n    if (uid === stat.uid && gid === stat.gid) {\n      return\n    }\n  } catch {\n    // ignore errors\n  }\n\n  try {\n    await fs.chown(path, uid, gid)\n  } catch {\n    // ignore errors\n  }\n}\n\n// accepts a `path` and the `owner` property of an options object and normalizes\n// it into an object with numerical `uid` and `gid`\nconst validate = async (path, input) => {\n  let uid\n  let gid\n\n  if (typeof input === 'string' || typeof input === 'number') {\n    uid = input\n    gid = input\n  } else if (input && typeof input === 'object') {\n    uid = input.uid\n    gid = input.gid\n  }\n\n  if (uid === 'inherit' || gid === 'inherit') {\n    const owner = await find(path)\n    if (uid === 'inherit') {\n      uid = owner.uid\n    }\n\n    if (gid === 'inherit') {\n      gid = owner.gid\n    }\n  }\n\n  return { uid, gid }\n}\n\nmodule.exports = {\n  find,\n  update,\n  validate,\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}