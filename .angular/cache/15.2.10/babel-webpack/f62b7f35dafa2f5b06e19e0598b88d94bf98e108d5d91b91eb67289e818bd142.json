{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst EE = require('events').EventEmitter;\nconst Minimatch = require('minimatch').Minimatch;\nclass Walker extends EE {\n  constructor(opts) {\n    opts = opts || {};\n    super(opts);\n    // set to true if this.path is a symlink, whether follow is true or not\n    this.isSymbolicLink = opts.isSymbolicLink;\n    this.path = opts.path || process.cwd();\n    this.basename = path.basename(this.path);\n    this.ignoreFiles = opts.ignoreFiles || ['.ignore'];\n    this.ignoreRules = {};\n    this.parent = opts.parent || null;\n    this.includeEmpty = !!opts.includeEmpty;\n    this.root = this.parent ? this.parent.root : this.path;\n    this.follow = !!opts.follow;\n    this.result = this.parent ? this.parent.result : new Set();\n    this.entries = null;\n    this.sawError = false;\n    this.exact = opts.exact;\n  }\n  sort(a, b) {\n    return a.localeCompare(b, 'en');\n  }\n  emit(ev, data) {\n    let ret = false;\n    if (!(this.sawError && ev === 'error')) {\n      if (ev === 'error') {\n        this.sawError = true;\n      } else if (ev === 'done' && !this.parent) {\n        data = Array.from(data).map(e => /^@/.test(e) ? `./${e}` : e).sort(this.sort);\n        this.result = data;\n      }\n      if (ev === 'error' && this.parent) {\n        ret = this.parent.emit('error', data);\n      } else {\n        ret = super.emit(ev, data);\n      }\n    }\n    return ret;\n  }\n  start() {\n    fs.readdir(this.path, (er, entries) => er ? this.emit('error', er) : this.onReaddir(entries));\n    return this;\n  }\n  isIgnoreFile(e) {\n    return e !== '.' && e !== '..' && this.ignoreFiles.indexOf(e) !== -1;\n  }\n  onReaddir(entries) {\n    this.entries = entries;\n    if (entries.length === 0) {\n      if (this.includeEmpty) {\n        this.result.add(this.path.slice(this.root.length + 1));\n      }\n      this.emit('done', this.result);\n    } else {\n      const hasIg = this.entries.some(e => this.isIgnoreFile(e));\n      if (hasIg) {\n        this.addIgnoreFiles();\n      } else {\n        this.filterEntries();\n      }\n    }\n  }\n  addIgnoreFiles() {\n    const newIg = this.entries.filter(e => this.isIgnoreFile(e));\n    let igCount = newIg.length;\n    const then = _ => {\n      if (--igCount === 0) {\n        this.filterEntries();\n      }\n    };\n    newIg.forEach(e => this.addIgnoreFile(e, then));\n  }\n  addIgnoreFile(file, then) {\n    const ig = path.resolve(this.path, file);\n    fs.readFile(ig, 'utf8', (er, data) => er ? this.emit('error', er) : this.onReadIgnoreFile(file, data, then));\n  }\n  onReadIgnoreFile(file, data, then) {\n    const mmopt = {\n      matchBase: true,\n      dot: true,\n      flipNegate: true,\n      nocase: true\n    };\n    const rules = data.split(/\\r?\\n/).filter(line => !/^#|^$/.test(line.trim())).map(rule => {\n      return new Minimatch(rule.trim(), mmopt);\n    });\n    this.ignoreRules[file] = rules;\n    then();\n  }\n  filterEntries() {\n    // at this point we either have ignore rules, or just inheriting\n    // this exclusion is at the point where we know the list of\n    // entries in the dir, but don't know what they are.  since\n    // some of them *might* be directories, we have to run the\n    // match in dir-mode as well, so that we'll pick up partials\n    // of files that will be included later.  Anything included\n    // at this point will be checked again later once we know\n    // what it is.\n    const filtered = this.entries.map(entry => {\n      // at this point, we don't know if it's a dir or not.\n      const passFile = this.filterEntry(entry);\n      const passDir = this.filterEntry(entry, true);\n      return passFile || passDir ? [entry, passFile, passDir] : false;\n    }).filter(e => e);\n\n    // now we stat them all\n    // if it's a dir, and passes as a dir, then recurse\n    // if it's not a dir, but passes as a file, add to set\n    let entryCount = filtered.length;\n    if (entryCount === 0) {\n      this.emit('done', this.result);\n    } else {\n      const then = _ => {\n        if (--entryCount === 0) {\n          this.emit('done', this.result);\n        }\n      };\n      filtered.forEach(filt => {\n        const entry = filt[0];\n        const file = filt[1];\n        const dir = filt[2];\n        this.stat({\n          entry,\n          file,\n          dir\n        }, then);\n      });\n    }\n  }\n  onstat({\n    st,\n    entry,\n    file,\n    dir,\n    isSymbolicLink\n  }, then) {\n    const abs = this.path + '/' + entry;\n    if (!st.isDirectory()) {\n      if (file) {\n        this.result.add(abs.slice(this.root.length + 1));\n      }\n      then();\n    } else {\n      // is a directory\n      if (dir) {\n        this.walker(entry, {\n          isSymbolicLink,\n          exact: file || this.filterEntry(entry + '/')\n        }, then);\n      } else {\n        then();\n      }\n    }\n  }\n  stat({\n    entry,\n    file,\n    dir\n  }, then) {\n    const abs = this.path + '/' + entry;\n    fs.lstat(abs, (lstatErr, lstatResult) => {\n      if (lstatErr) {\n        this.emit('error', lstatErr);\n      } else {\n        const isSymbolicLink = lstatResult.isSymbolicLink();\n        if (this.follow && isSymbolicLink) {\n          fs.stat(abs, (statErr, statResult) => {\n            if (statErr) {\n              this.emit('error', statErr);\n            } else {\n              this.onstat({\n                st: statResult,\n                entry,\n                file,\n                dir,\n                isSymbolicLink\n              }, then);\n            }\n          });\n        } else {\n          this.onstat({\n            st: lstatResult,\n            entry,\n            file,\n            dir,\n            isSymbolicLink\n          }, then);\n        }\n      }\n    });\n  }\n  walkerOpt(entry, opts) {\n    return {\n      path: this.path + '/' + entry,\n      parent: this,\n      ignoreFiles: this.ignoreFiles,\n      follow: this.follow,\n      includeEmpty: this.includeEmpty,\n      ...opts\n    };\n  }\n  walker(entry, opts, then) {\n    new Walker(this.walkerOpt(entry, opts)).on('done', then).start();\n  }\n  filterEntry(entry, partial, entryBasename) {\n    let included = true;\n\n    // this = /a/b/c\n    // entry = d\n    // parent /a/b sees c/d\n    if (this.parent && this.parent.filterEntry) {\n      const parentEntry = this.basename + '/' + entry;\n      const parentBasename = entryBasename || entry;\n      included = this.parent.filterEntry(parentEntry, partial, parentBasename);\n      if (!included && !this.exact) {\n        return false;\n      }\n    }\n    this.ignoreFiles.forEach(f => {\n      if (this.ignoreRules[f]) {\n        this.ignoreRules[f].forEach(rule => {\n          // negation means inclusion\n          // so if it's negated, and already included, no need to check\n          // likewise if it's neither negated nor included\n          if (rule.negate !== included) {\n            const isRelativeRule = entryBasename && rule.globParts.some(part => part.length <= (part.slice(-1)[0] ? 1 : 2));\n\n            // first, match against /foo/bar\n            // then, against foo/bar\n            // then, in the case of partials, match with a /\n            //   then, if also the rule is relative, match against basename\n            const match = rule.match('/' + entry) || rule.match(entry) || !!partial && (rule.match('/' + entry + '/') || rule.match(entry + '/') || rule.negate && (rule.match('/' + entry, true) || rule.match(entry, true)) || isRelativeRule && (rule.match('/' + entryBasename + '/') || rule.match(entryBasename + '/') || rule.negate && (rule.match('/' + entryBasename, true) || rule.match(entryBasename, true))));\n            if (match) {\n              included = rule.negate;\n            }\n          }\n        });\n      }\n    });\n    return included;\n  }\n}\nclass WalkerSync extends Walker {\n  start() {\n    this.onReaddir(fs.readdirSync(this.path));\n    return this;\n  }\n  addIgnoreFile(file, then) {\n    const ig = path.resolve(this.path, file);\n    this.onReadIgnoreFile(file, fs.readFileSync(ig, 'utf8'), then);\n  }\n  stat({\n    entry,\n    file,\n    dir\n  }, then) {\n    const abs = this.path + '/' + entry;\n    let st = fs.lstatSync(abs);\n    const isSymbolicLink = st.isSymbolicLink();\n    if (this.follow && isSymbolicLink) {\n      st = fs.statSync(abs);\n    }\n\n    // console.error('STAT SYNC', {st, entry, file, dir, isSymbolicLink, then})\n    this.onstat({\n      st,\n      entry,\n      file,\n      dir,\n      isSymbolicLink\n    }, then);\n  }\n  walker(entry, opts, then) {\n    new WalkerSync(this.walkerOpt(entry, opts)).start();\n    then();\n  }\n}\nconst walk = (opts, callback) => {\n  const p = new Promise((resolve, reject) => {\n    new Walker(opts).on('done', resolve).on('error', reject).start();\n  });\n  return callback ? p.then(res => callback(null, res), callback) : p;\n};\nconst walkSync = opts => new WalkerSync(opts).start().result;\nmodule.exports = walk;\nwalk.sync = walkSync;\nwalk.Walker = Walker;\nwalk.WalkerSync = WalkerSync;","map":{"version":3,"names":["fs","require","path","EE","EventEmitter","Minimatch","Walker","constructor","opts","isSymbolicLink","process","cwd","basename","ignoreFiles","ignoreRules","parent","includeEmpty","root","follow","result","Set","entries","sawError","exact","sort","a","b","localeCompare","emit","ev","data","ret","Array","from","map","e","test","start","readdir","er","onReaddir","isIgnoreFile","indexOf","length","add","slice","hasIg","some","addIgnoreFiles","filterEntries","newIg","filter","igCount","then","_","forEach","addIgnoreFile","file","ig","resolve","readFile","onReadIgnoreFile","mmopt","matchBase","dot","flipNegate","nocase","rules","split","line","trim","rule","filtered","entry","passFile","filterEntry","passDir","entryCount","filt","dir","stat","onstat","st","abs","isDirectory","walker","lstat","lstatErr","lstatResult","statErr","statResult","walkerOpt","on","partial","entryBasename","included","parentEntry","parentBasename","f","negate","isRelativeRule","globParts","part","match","WalkerSync","readdirSync","readFileSync","lstatSync","statSync","walk","callback","p","Promise","reject","res","walkSync","module","exports","sync"],"sources":["I:/Angular/angular-blog/node_modules/ignore-walk/lib/index.js"],"sourcesContent":["'use strict'\n\nconst fs = require('fs')\nconst path = require('path')\nconst EE = require('events').EventEmitter\nconst Minimatch = require('minimatch').Minimatch\n\nclass Walker extends EE {\n  constructor (opts) {\n    opts = opts || {}\n    super(opts)\n    // set to true if this.path is a symlink, whether follow is true or not\n    this.isSymbolicLink = opts.isSymbolicLink\n    this.path = opts.path || process.cwd()\n    this.basename = path.basename(this.path)\n    this.ignoreFiles = opts.ignoreFiles || ['.ignore']\n    this.ignoreRules = {}\n    this.parent = opts.parent || null\n    this.includeEmpty = !!opts.includeEmpty\n    this.root = this.parent ? this.parent.root : this.path\n    this.follow = !!opts.follow\n    this.result = this.parent ? this.parent.result : new Set()\n    this.entries = null\n    this.sawError = false\n    this.exact = opts.exact\n  }\n\n  sort (a, b) {\n    return a.localeCompare(b, 'en')\n  }\n\n  emit (ev, data) {\n    let ret = false\n    if (!(this.sawError && ev === 'error')) {\n      if (ev === 'error') {\n        this.sawError = true\n      } else if (ev === 'done' && !this.parent) {\n        data = Array.from(data)\n          .map(e => /^@/.test(e) ? `./${e}` : e).sort(this.sort)\n        this.result = data\n      }\n\n      if (ev === 'error' && this.parent) {\n        ret = this.parent.emit('error', data)\n      } else {\n        ret = super.emit(ev, data)\n      }\n    }\n    return ret\n  }\n\n  start () {\n    fs.readdir(this.path, (er, entries) =>\n      er ? this.emit('error', er) : this.onReaddir(entries))\n    return this\n  }\n\n  isIgnoreFile (e) {\n    return e !== '.' &&\n      e !== '..' &&\n      this.ignoreFiles.indexOf(e) !== -1\n  }\n\n  onReaddir (entries) {\n    this.entries = entries\n    if (entries.length === 0) {\n      if (this.includeEmpty) {\n        this.result.add(this.path.slice(this.root.length + 1))\n      }\n      this.emit('done', this.result)\n    } else {\n      const hasIg = this.entries.some(e =>\n        this.isIgnoreFile(e))\n\n      if (hasIg) {\n        this.addIgnoreFiles()\n      } else {\n        this.filterEntries()\n      }\n    }\n  }\n\n  addIgnoreFiles () {\n    const newIg = this.entries\n      .filter(e => this.isIgnoreFile(e))\n\n    let igCount = newIg.length\n    const then = _ => {\n      if (--igCount === 0) {\n        this.filterEntries()\n      }\n    }\n\n    newIg.forEach(e => this.addIgnoreFile(e, then))\n  }\n\n  addIgnoreFile (file, then) {\n    const ig = path.resolve(this.path, file)\n    fs.readFile(ig, 'utf8', (er, data) =>\n      er ? this.emit('error', er) : this.onReadIgnoreFile(file, data, then))\n  }\n\n  onReadIgnoreFile (file, data, then) {\n    const mmopt = {\n      matchBase: true,\n      dot: true,\n      flipNegate: true,\n      nocase: true,\n    }\n    const rules = data.split(/\\r?\\n/)\n      .filter(line => !/^#|^$/.test(line.trim()))\n      .map(rule => {\n        return new Minimatch(rule.trim(), mmopt)\n      })\n\n    this.ignoreRules[file] = rules\n\n    then()\n  }\n\n  filterEntries () {\n    // at this point we either have ignore rules, or just inheriting\n    // this exclusion is at the point where we know the list of\n    // entries in the dir, but don't know what they are.  since\n    // some of them *might* be directories, we have to run the\n    // match in dir-mode as well, so that we'll pick up partials\n    // of files that will be included later.  Anything included\n    // at this point will be checked again later once we know\n    // what it is.\n    const filtered = this.entries.map(entry => {\n      // at this point, we don't know if it's a dir or not.\n      const passFile = this.filterEntry(entry)\n      const passDir = this.filterEntry(entry, true)\n      return (passFile || passDir) ? [entry, passFile, passDir] : false\n    }).filter(e => e)\n\n    // now we stat them all\n    // if it's a dir, and passes as a dir, then recurse\n    // if it's not a dir, but passes as a file, add to set\n    let entryCount = filtered.length\n    if (entryCount === 0) {\n      this.emit('done', this.result)\n    } else {\n      const then = _ => {\n        if (--entryCount === 0) {\n          this.emit('done', this.result)\n        }\n      }\n      filtered.forEach(filt => {\n        const entry = filt[0]\n        const file = filt[1]\n        const dir = filt[2]\n        this.stat({ entry, file, dir }, then)\n      })\n    }\n  }\n\n  onstat ({ st, entry, file, dir, isSymbolicLink }, then) {\n    const abs = this.path + '/' + entry\n    if (!st.isDirectory()) {\n      if (file) {\n        this.result.add(abs.slice(this.root.length + 1))\n      }\n      then()\n    } else {\n      // is a directory\n      if (dir) {\n        this.walker(entry, { isSymbolicLink, exact: file || this.filterEntry(entry + '/') }, then)\n      } else {\n        then()\n      }\n    }\n  }\n\n  stat ({ entry, file, dir }, then) {\n    const abs = this.path + '/' + entry\n    fs.lstat(abs, (lstatErr, lstatResult) => {\n      if (lstatErr) {\n        this.emit('error', lstatErr)\n      } else {\n        const isSymbolicLink = lstatResult.isSymbolicLink()\n        if (this.follow && isSymbolicLink) {\n          fs.stat(abs, (statErr, statResult) => {\n            if (statErr) {\n              this.emit('error', statErr)\n            } else {\n              this.onstat({ st: statResult, entry, file, dir, isSymbolicLink }, then)\n            }\n          })\n        } else {\n          this.onstat({ st: lstatResult, entry, file, dir, isSymbolicLink }, then)\n        }\n      }\n    })\n  }\n\n  walkerOpt (entry, opts) {\n    return {\n      path: this.path + '/' + entry,\n      parent: this,\n      ignoreFiles: this.ignoreFiles,\n      follow: this.follow,\n      includeEmpty: this.includeEmpty,\n      ...opts,\n    }\n  }\n\n  walker (entry, opts, then) {\n    new Walker(this.walkerOpt(entry, opts)).on('done', then).start()\n  }\n\n  filterEntry (entry, partial, entryBasename) {\n    let included = true\n\n    // this = /a/b/c\n    // entry = d\n    // parent /a/b sees c/d\n    if (this.parent && this.parent.filterEntry) {\n      const parentEntry = this.basename + '/' + entry\n      const parentBasename = entryBasename || entry\n      included = this.parent.filterEntry(parentEntry, partial, parentBasename)\n      if (!included && !this.exact) {\n        return false\n      }\n    }\n\n    this.ignoreFiles.forEach(f => {\n      if (this.ignoreRules[f]) {\n        this.ignoreRules[f].forEach(rule => {\n          // negation means inclusion\n          // so if it's negated, and already included, no need to check\n          // likewise if it's neither negated nor included\n          if (rule.negate !== included) {\n            const isRelativeRule = entryBasename && rule.globParts.some(part =>\n              part.length <= (part.slice(-1)[0] ? 1 : 2)\n            )\n\n            // first, match against /foo/bar\n            // then, against foo/bar\n            // then, in the case of partials, match with a /\n            //   then, if also the rule is relative, match against basename\n            const match = rule.match('/' + entry) ||\n              rule.match(entry) ||\n              !!partial && (\n                rule.match('/' + entry + '/') ||\n                rule.match(entry + '/') ||\n                rule.negate && (\n                  rule.match('/' + entry, true) ||\n                  rule.match(entry, true)) ||\n                isRelativeRule && (\n                  rule.match('/' + entryBasename + '/') ||\n                  rule.match(entryBasename + '/') ||\n                  rule.negate && (\n                    rule.match('/' + entryBasename, true) ||\n                    rule.match(entryBasename, true))))\n\n            if (match) {\n              included = rule.negate\n            }\n          }\n        })\n      }\n    })\n\n    return included\n  }\n}\n\nclass WalkerSync extends Walker {\n  start () {\n    this.onReaddir(fs.readdirSync(this.path))\n    return this\n  }\n\n  addIgnoreFile (file, then) {\n    const ig = path.resolve(this.path, file)\n    this.onReadIgnoreFile(file, fs.readFileSync(ig, 'utf8'), then)\n  }\n\n  stat ({ entry, file, dir }, then) {\n    const abs = this.path + '/' + entry\n    let st = fs.lstatSync(abs)\n    const isSymbolicLink = st.isSymbolicLink()\n    if (this.follow && isSymbolicLink) {\n      st = fs.statSync(abs)\n    }\n\n    // console.error('STAT SYNC', {st, entry, file, dir, isSymbolicLink, then})\n    this.onstat({ st, entry, file, dir, isSymbolicLink }, then)\n  }\n\n  walker (entry, opts, then) {\n    new WalkerSync(this.walkerOpt(entry, opts)).start()\n    then()\n  }\n}\n\nconst walk = (opts, callback) => {\n  const p = new Promise((resolve, reject) => {\n    new Walker(opts).on('done', resolve).on('error', reject).start()\n  })\n  return callback ? p.then(res => callback(null, res), callback) : p\n}\n\nconst walkSync = opts => new WalkerSync(opts).start().result\n\nmodule.exports = walk\nwalk.sync = walkSync\nwalk.Walker = Walker\nwalk.WalkerSync = WalkerSync\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}