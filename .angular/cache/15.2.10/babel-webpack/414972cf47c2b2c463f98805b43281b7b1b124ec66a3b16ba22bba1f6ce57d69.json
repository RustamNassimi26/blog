{"ast":null,"code":"'use strict';\n\nconst parseUrl = require('./parse-url');\n\n// look for github shorthand inputs, such as npm/cli\nconst isGitHubShorthand = arg => {\n  // it cannot contain whitespace before the first #\n  // it cannot start with a / because that's probably an absolute file path\n  // but it must include a slash since repos are username/repository\n  // it cannot start with a . because that's probably a relative file path\n  // it cannot start with an @ because that's a scoped package if it passes the other tests\n  // it cannot contain a : before a # because that tells us that there's a protocol\n  // a second / may not exist before a #\n  const firstHash = arg.indexOf('#');\n  const firstSlash = arg.indexOf('/');\n  const secondSlash = arg.indexOf('/', firstSlash + 1);\n  const firstColon = arg.indexOf(':');\n  const firstSpace = /\\s/.exec(arg);\n  const firstAt = arg.indexOf('@');\n  const spaceOnlyAfterHash = !firstSpace || firstHash > -1 && firstSpace.index > firstHash;\n  const atOnlyAfterHash = firstAt === -1 || firstHash > -1 && firstAt > firstHash;\n  const colonOnlyAfterHash = firstColon === -1 || firstHash > -1 && firstColon > firstHash;\n  const secondSlashOnlyAfterHash = secondSlash === -1 || firstHash > -1 && secondSlash > firstHash;\n  const hasSlash = firstSlash > 0;\n  // if a # is found, what we really want to know is that the character\n  // immediately before # is not a /\n  const doesNotEndWithSlash = firstHash > -1 ? arg[firstHash - 1] !== '/' : !arg.endsWith('/');\n  const doesNotStartWithDot = !arg.startsWith('.');\n  return spaceOnlyAfterHash && hasSlash && doesNotEndWithSlash && doesNotStartWithDot && atOnlyAfterHash && colonOnlyAfterHash && secondSlashOnlyAfterHash;\n};\nmodule.exports = (giturl, opts, {\n  gitHosts,\n  protocols\n}) => {\n  if (!giturl) {\n    return;\n  }\n  const correctedUrl = isGitHubShorthand(giturl) ? `github:${giturl}` : giturl;\n  const parsed = parseUrl(correctedUrl, protocols);\n  if (!parsed) {\n    return;\n  }\n  const gitHostShortcut = gitHosts.byShortcut[parsed.protocol];\n  const gitHostDomain = gitHosts.byDomain[parsed.hostname.startsWith('www.') ? parsed.hostname.slice(4) : parsed.hostname];\n  const gitHostName = gitHostShortcut || gitHostDomain;\n  if (!gitHostName) {\n    return;\n  }\n  const gitHostInfo = gitHosts[gitHostShortcut || gitHostDomain];\n  let auth = null;\n  if (protocols[parsed.protocol]?.auth && (parsed.username || parsed.password)) {\n    auth = `${parsed.username}${parsed.password ? ':' + parsed.password : ''}`;\n  }\n  let committish = null;\n  let user = null;\n  let project = null;\n  let defaultRepresentation = null;\n  try {\n    if (gitHostShortcut) {\n      let pathname = parsed.pathname.startsWith('/') ? parsed.pathname.slice(1) : parsed.pathname;\n      const firstAt = pathname.indexOf('@');\n      // we ignore auth for shortcuts, so just trim it out\n      if (firstAt > -1) {\n        pathname = pathname.slice(firstAt + 1);\n      }\n      const lastSlash = pathname.lastIndexOf('/');\n      if (lastSlash > -1) {\n        user = decodeURIComponent(pathname.slice(0, lastSlash));\n        // we want nulls only, never empty strings\n        if (!user) {\n          user = null;\n        }\n        project = decodeURIComponent(pathname.slice(lastSlash + 1));\n      } else {\n        project = decodeURIComponent(pathname);\n      }\n      if (project.endsWith('.git')) {\n        project = project.slice(0, -4);\n      }\n      if (parsed.hash) {\n        committish = decodeURIComponent(parsed.hash.slice(1));\n      }\n      defaultRepresentation = 'shortcut';\n    } else {\n      if (!gitHostInfo.protocols.includes(parsed.protocol)) {\n        return;\n      }\n      const segments = gitHostInfo.extract(parsed);\n      if (!segments) {\n        return;\n      }\n      user = segments.user && decodeURIComponent(segments.user);\n      project = decodeURIComponent(segments.project);\n      committish = decodeURIComponent(segments.committish);\n      defaultRepresentation = protocols[parsed.protocol]?.name || parsed.protocol.slice(0, -1);\n    }\n  } catch (err) {\n    /* istanbul ignore else */\n    if (err instanceof URIError) {\n      return;\n    } else {\n      throw err;\n    }\n  }\n  return [gitHostName, user, auth, project, committish, defaultRepresentation, opts];\n};","map":{"version":3,"names":["parseUrl","require","isGitHubShorthand","arg","firstHash","indexOf","firstSlash","secondSlash","firstColon","firstSpace","exec","firstAt","spaceOnlyAfterHash","index","atOnlyAfterHash","colonOnlyAfterHash","secondSlashOnlyAfterHash","hasSlash","doesNotEndWithSlash","endsWith","doesNotStartWithDot","startsWith","module","exports","giturl","opts","gitHosts","protocols","correctedUrl","parsed","gitHostShortcut","byShortcut","protocol","gitHostDomain","byDomain","hostname","slice","gitHostName","gitHostInfo","auth","username","password","committish","user","project","defaultRepresentation","pathname","lastSlash","lastIndexOf","decodeURIComponent","hash","includes","segments","extract","name","err","URIError"],"sources":["I:/Angular/angular-blog/node_modules/npm-pick-manifest/node_modules/hosted-git-info/lib/from-url.js"],"sourcesContent":["'use strict'\n\nconst parseUrl = require('./parse-url')\n\n// look for github shorthand inputs, such as npm/cli\nconst isGitHubShorthand = (arg) => {\n  // it cannot contain whitespace before the first #\n  // it cannot start with a / because that's probably an absolute file path\n  // but it must include a slash since repos are username/repository\n  // it cannot start with a . because that's probably a relative file path\n  // it cannot start with an @ because that's a scoped package if it passes the other tests\n  // it cannot contain a : before a # because that tells us that there's a protocol\n  // a second / may not exist before a #\n  const firstHash = arg.indexOf('#')\n  const firstSlash = arg.indexOf('/')\n  const secondSlash = arg.indexOf('/', firstSlash + 1)\n  const firstColon = arg.indexOf(':')\n  const firstSpace = /\\s/.exec(arg)\n  const firstAt = arg.indexOf('@')\n\n  const spaceOnlyAfterHash = !firstSpace || (firstHash > -1 && firstSpace.index > firstHash)\n  const atOnlyAfterHash = firstAt === -1 || (firstHash > -1 && firstAt > firstHash)\n  const colonOnlyAfterHash = firstColon === -1 || (firstHash > -1 && firstColon > firstHash)\n  const secondSlashOnlyAfterHash = secondSlash === -1 || (firstHash > -1 && secondSlash > firstHash)\n  const hasSlash = firstSlash > 0\n  // if a # is found, what we really want to know is that the character\n  // immediately before # is not a /\n  const doesNotEndWithSlash = firstHash > -1 ? arg[firstHash - 1] !== '/' : !arg.endsWith('/')\n  const doesNotStartWithDot = !arg.startsWith('.')\n\n  return spaceOnlyAfterHash && hasSlash && doesNotEndWithSlash &&\n    doesNotStartWithDot && atOnlyAfterHash && colonOnlyAfterHash &&\n    secondSlashOnlyAfterHash\n}\n\nmodule.exports = (giturl, opts, { gitHosts, protocols }) => {\n  if (!giturl) {\n    return\n  }\n\n  const correctedUrl = isGitHubShorthand(giturl) ? `github:${giturl}` : giturl\n  const parsed = parseUrl(correctedUrl, protocols)\n  if (!parsed) {\n    return\n  }\n\n  const gitHostShortcut = gitHosts.byShortcut[parsed.protocol]\n  const gitHostDomain = gitHosts.byDomain[parsed.hostname.startsWith('www.')\n    ? parsed.hostname.slice(4)\n    : parsed.hostname]\n  const gitHostName = gitHostShortcut || gitHostDomain\n  if (!gitHostName) {\n    return\n  }\n\n  const gitHostInfo = gitHosts[gitHostShortcut || gitHostDomain]\n  let auth = null\n  if (protocols[parsed.protocol]?.auth && (parsed.username || parsed.password)) {\n    auth = `${parsed.username}${parsed.password ? ':' + parsed.password : ''}`\n  }\n\n  let committish = null\n  let user = null\n  let project = null\n  let defaultRepresentation = null\n\n  try {\n    if (gitHostShortcut) {\n      let pathname = parsed.pathname.startsWith('/') ? parsed.pathname.slice(1) : parsed.pathname\n      const firstAt = pathname.indexOf('@')\n      // we ignore auth for shortcuts, so just trim it out\n      if (firstAt > -1) {\n        pathname = pathname.slice(firstAt + 1)\n      }\n\n      const lastSlash = pathname.lastIndexOf('/')\n      if (lastSlash > -1) {\n        user = decodeURIComponent(pathname.slice(0, lastSlash))\n        // we want nulls only, never empty strings\n        if (!user) {\n          user = null\n        }\n        project = decodeURIComponent(pathname.slice(lastSlash + 1))\n      } else {\n        project = decodeURIComponent(pathname)\n      }\n\n      if (project.endsWith('.git')) {\n        project = project.slice(0, -4)\n      }\n\n      if (parsed.hash) {\n        committish = decodeURIComponent(parsed.hash.slice(1))\n      }\n\n      defaultRepresentation = 'shortcut'\n    } else {\n      if (!gitHostInfo.protocols.includes(parsed.protocol)) {\n        return\n      }\n\n      const segments = gitHostInfo.extract(parsed)\n      if (!segments) {\n        return\n      }\n\n      user = segments.user && decodeURIComponent(segments.user)\n      project = decodeURIComponent(segments.project)\n      committish = decodeURIComponent(segments.committish)\n      defaultRepresentation = protocols[parsed.protocol]?.name || parsed.protocol.slice(0, -1)\n    }\n  } catch (err) {\n    /* istanbul ignore else */\n    if (err instanceof URIError) {\n      return\n    } else {\n      throw err\n    }\n  }\n\n  return [gitHostName, user, auth, project, committish, defaultRepresentation, opts]\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}